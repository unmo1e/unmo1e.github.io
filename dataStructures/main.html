<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-10-02 Mon 13:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Data Structures</title>
<meta name="author" content="Anmol Nawani" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" href="src/org.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Data Structures</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org163c7a1">1. Stack</a>
<ul>
<li><a href="#org0748c04">1.1. Operation on stack</a></li>
</ul>
</li>
<li><a href="#org2763bb4">2. Direct Address Table</a></li>
<li><a href="#orgd364274">3. Hash Table</a>
<ul>
<li><a href="#org8173f79">3.1. Collision</a>
<ul>
<li><a href="#org04f7f67">3.1.1. Chaining</a></li>
<li><a href="#org581f1ed">3.1.2. Performance of chaining hash table</a></li>
<li><a href="#org92ce119">3.1.3. Open Addressing</a>
<ul>
<li><a href="#org00395eb">3.1.3.1. Linear probing</a></li>
<li><a href="#org7ff686c">3.1.3.2. Quadratic probing</a></li>
<li><a href="#orgeb11d50">3.1.3.3. Double Hashing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org370e99a">3.2. Hash Functions</a>
<ul>
<li><a href="#org56149ae">3.2.1. The division method</a></li>
<li><a href="#orgf3fa455">3.2.2. The multiplication method</a></li>
<li><a href="#orgb06e422">3.2.3. Mid square method</a></li>
<li><a href="#org5aae66e">3.2.4. Folding method</a></li>
</ul>
</li>
<li><a href="#orgb2f422e">3.3. Universal Hashing</a>
<ul>
<li><a href="#org23aba84">3.3.1. Rehashing</a></li>
<li><a href="#orgbd4c14f">3.3.2. Universal family</a></li>
<li><a href="#org19214ad">3.3.3. Performance of universal hashing</a></li>
<li><a href="#orgfaf8460">3.3.4. Example for universal set of hash functions</a></li>
</ul>
</li>
<li><a href="#orgf71fb05">3.4. Perfect Hashing</a></li>
</ul>
</li>
<li><a href="#org7cbf501">4. Representing rooted trees using nodes</a>
<ul>
<li><a href="#org00f3c9f">4.1. Fixed number of children</a></li>
<li><a href="#org092967c">4.2. Unbounded number of children</a></li>
</ul>
</li>
<li><a href="#orgeea09e3">5. Binary Search Trees</a>
<ul>
<li><a href="#org068d34e">5.1. Quering a BST</a>
<ul>
<li><a href="#orgcf1d625">5.1.1. Searching for node</a></li>
<li><a href="#org1eccdb9">5.1.2. Minimum and maximum</a></li>
<li><a href="#orgd1eb8f1">5.1.3. Find Parent Node</a></li>
<li><a href="#org06aec1b">5.1.4. Is ancestor</a></li>
<li><a href="#orgad2acf4">5.1.5. Successor and predecessor</a>
<ul>
<li><a href="#orgc182038">5.1.5.1. For Successor</a></li>
<li><a href="#org4eea03a">5.1.5.2. For Predecessor</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge2c01f8">5.2. Inserting and Deleting nodes</a>
<ul>
<li><a href="#orga3817ac">5.2.1. Insertion</a></li>
<li><a href="#org43bca22">5.2.2. Deletion</a></li>
</ul>
</li>
<li><a href="#org5be9c4c">5.3. Performance of BST</a></li>
<li><a href="#orgcf9a8ac">5.4. Traversing a Binary Tree</a>
<ul>
<li><a href="#orgef80d36">5.4.1. Inorder tree walk</a></li>
<li><a href="#orgd2f801a">5.4.2. Preorder tree walk</a></li>
<li><a href="#org4720c1c">5.4.3. Postorder tree walk</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgeeca0a9">6. Binary Heap</a>
<ul>
<li><a href="#org8e7cc0a">6.1. Heap Property</a></li>
<li><a href="#orgbf5eade">6.2. Shape of Heap</a></li>
<li><a href="#orgb19ce0e">6.3. Array implementation</a></li>
<li><a href="#orgd6f65c2">6.4. Operations on heaps</a>
<ul>
<li><a href="#org43125ac">6.4.1. Parent and child indices</a></li>
<li><a href="#org05ab70a">6.4.2. Down-heapify</a></li>
<li><a href="#org399a72c">6.4.3. Up-heapify</a></li>
<li><a href="#org63bf7f2">6.4.4. Insertion</a></li>
<li><a href="#orgfcc9520">6.4.5. Deletion or Extraction</a></li>
<li><a href="#org47ce745">6.4.6. Insert then extract</a></li>
<li><a href="#org54c7a08">6.4.7. Searching</a></li>
<li><a href="#orge3a08f2">6.4.8. Deleting arbitray element</a></li>
<li><a href="#org8a91190">6.4.9. Decrease and increase keys</a></li>
</ul>
</li>
<li><a href="#orgc6cf4ef">6.5. Building a heap from array</a></li>
</ul>
</li>
<li><a href="#org3e3ed9b">7. Graphs</a>
<ul>
<li><a href="#org6625a01">7.1. Representing graphs</a>
<ul>
<li><a href="#org3138112">7.1.1. Adjacency List</a></li>
<li><a href="#org0a3e49b">7.1.2. Adjacency Matrix</a></li>
</ul>
</li>
<li><a href="#orgbcfe613">7.2. Vertex and edge attributes</a></li>
<li><a href="#org2343c63">7.3. Density of graph</a>
<ul>
<li><a href="#org73a1cdd">7.3.1. Which representation to use</a></li>
</ul>
</li>
<li><a href="#orgdb2a125">7.4. Searching Graphs</a>
<ul>
<li><a href="#orgba9fa64">7.4.1. Breadth first search</a></li>
<li><a href="#org135ed3e">7.4.2. Breadth-first trees for shortest path</a></li>
<li><a href="#orgca24b82">7.4.3. Depth first search</a></li>
<li><a href="#org08e97e1">7.4.4. Properties of DFS</a>
<ul>
<li><a href="#org6623c5a">7.4.4.1. Parenthesis theorem</a></li>
<li><a href="#org37b14f5">7.4.4.2. White path theorem</a></li>
<li><a href="#org55b5048">7.4.4.3. Classification of edges</a></li>
</ul>
</li>
<li><a href="#org1d5efc4">7.4.5. Depth-first and Breadth-first Forests</a></li>
<li><a href="#org47a752d">7.4.6. Topological sort using DFS</a></li>
</ul>
</li>
<li><a href="#orgf9dd9a8">7.5. Strongly connected components</a>
<ul>
<li><a href="#org18101bf">7.5.1. Finding strongly connected components</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org163c7a1" class="outline-2">
<h2 id="org163c7a1"><span class="section-number-2">1.</span> Stack</h2>
<div class="outline-text-2" id="text-1">
<p>
A stack is a data structure which only allows insertion and deletion from one end of the array. The insertion is always on the extreme end of the array. The deletion can only be done on the element which was most recently added.
<br />
<b>It is similar to stacking plates.</b> The plate can only be added at the <b>top</b> of the stack and also only the last added plate to the stack can be removed (which will be on top).
<br />
Due to this property, Last In elements are removed First from a stack. Therefore, it is called a <b>Last In First Out (LIFO)</b> data structure or a <b>First In Last Out (FILO)</b> data structure.
<br />
To create a stack, we will keep track of the index which is the <b>top</b> of the array. This top index will <b>increment when we insert element</b> and <b>decrement when we remove element.</b>
</p>
</div>

<div id="outline-container-org0748c04" class="outline-3">
<h3 id="org0748c04"><span class="section-number-3">1.1.</span> Operation on stack</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A stack has two operations 
</p>
<ol class="org-ol">
<li>Push</li>
<li>Pop</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org2763bb4" class="outline-2">
<h2 id="org2763bb4"><span class="section-number-2">2.</span> Direct Address Table</h2>
<div class="outline-text-2" id="text-2">
<p>
Direct Address Tables are useful when we know that key is within a small range. Then, we can allocate an array such that each possible key gets an index and just add the values according to the keys.
<br />
This also assumes that keys are integers
</p>

<ul class="org-ul">
<li>Table creation</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span>{
  <span style="color: #dcdc00; font-weight: bold;">int</span> * <span style="color: #e2e2e2;">values</span>;
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">min_key</span>;
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">max_key</span>;
};

<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #00cbcb;">create_table</span>(<span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">min_key</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">max_key</span>){
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">r</span>;
  r.values = (<span style="color: #dcdc00; font-weight: bold;">int</span> * ) malloc(<span style="color: #c25959; font-weight: bold;">sizeof</span>(<span style="color: #dcdc00; font-weight: bold;">int</span>) * (max_key - min_key + 1) );
  r.min_key = min_key;
  r.max_key = max_key;
  <span style="color: #c25959; font-weight: bold;">return</span> r;
}
</pre>
</div>

<ul class="org-ul">
<li>Table insert</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">table_insert</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">t</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>, <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(key &gt; t.max_key || key &lt; t.min_key)
    assert(<span style="color: #3eca3e;">false</span> &amp;&amp; <span style="color: #3eca3e;">"Key value out of boundry"</span>);

  t.values[key - t.min_key] = value;
}
</pre>
</div>

<ul class="org-ul">
<li>Table delete</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">table_delete</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">t</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(key &gt; t.max_key || key &lt; t.min_key)
    assert(<span style="color: #3eca3e;">false</span> &amp;&amp; <span style="color: #3eca3e;">"Key value out of boundry"</span>);

  t.values[key - t.min_key] = 0x00;
}
</pre>
</div>

<ul class="org-ul">
<li>Table Search / Table Get</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #00cbcb;">table_get</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">t</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>){
    <span style="color: #c25959; font-weight: bold;">if</span>(key &gt; t.max_key || key &lt; t.min_key)
      assert(<span style="color: #3eca3e;">false</span> &amp;&amp; <span style="color: #3eca3e;">"Key value out of boundry"</span>);

    <span style="color: #c25959; font-weight: bold;">return</span> t.values[key - t.min_key];
}
</pre>
</div>

<p>
<b>Using direct address tables is very useful when keys are enum values.</b>
</p>
</div>
</div>

<div id="outline-container-orgd364274" class="outline-2">
<h2 id="orgd364274"><span class="section-number-2">3.</span> Hash Table</h2>
<div class="outline-text-2" id="text-3">
<p>
When the set of possible keys is large, it is impractical to allocate a table big enough for all keys. In order to fit all possible keys into a small table, rather than directly using keys as the index for our array, we wil first calculate a <i><b>hash</b></i> for it using a <i><b>hash function</b></i>. Since we are relying on hashes for this addressing in the table, we call it a hash table.
<br />
<br />
For a given key \(k_i\) in <b><i>direct address table</i></b>, we store value in \(table[k_i]\).
<br />
<br />
For a given key \(k_i\) in <b><i>hash table</i></b>, we store value in \(table[h(k_i)]\), where \(h()\) is the hash function.
<br />
<br />
So the main purpose of the hash function is to reduce the range of array indices.
</p>
</div>

<div id="outline-container-org8173f79" class="outline-3">
<h3 id="org8173f79"><span class="section-number-3">3.1.</span> Collision</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Because we are reducing the range of indices, the hash function may <i><b>hash two keys to the same slot</b></i>. This is called a collision.
<br />
<br />
We should try to find a hash funtion which will minimise the number of collisions.
<br />
<br />
The number of keys is going to be greater than number of slots in table. Therefore avoiding all collisions is not possible.
<br />
There are two ways we will look at to resolve collision.
</p>
<ol class="org-ol">
<li>Chaining</li>
<li>Open addressing</li>
</ol>
</div>

<div id="outline-container-org04f7f67" class="outline-4">
<h4 id="org04f7f67"><span class="section-number-4">3.1.1.</span> Chaining</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
In chaining, rather than storing values in table slots. We will have <i><b>linked lists at each slot</b></i> which will store (key, value) pairs.
<br />
<br />
When the hash gives us a slot, we will add the value to linked list at that slot.
</p>

<ul class="org-ul">
<li>Linked List structure</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">linked_list</span>{
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>;
  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">linked_list</span> * <span style="color: #e2e2e2;">next</span>;
};
</pre>
</div>

<ul class="org-ul">
<li>Table structure</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span>{
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">linked_list</span> * <span style="color: #e2e2e2;">table</span>[];
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">table_size</span>;
};
</pre>
</div>

<ul class="org-ul">
<li>Insertion</li>
</ul>

<p>
Insertion can be done in \(\theta (1)\) time if we assume that key being inserted is not already in the linked list. But we can add a check to see if the key was already inserted and modify that value.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">linked_list_add(struct linked_list * ll, size_t key, int value)</span>
<span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">adds the given key,value to the start of the list</span>
<span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">chained_hash_insert</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">t</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>, <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>){
  linked_list_add(t.table[ h(key) ], key ,value);
}
</pre>
</div>

<ul class="org-ul">
<li>Get / Search</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">linked_list_search(struct linked_list * ll, size_t key)</span>
<span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">gets the value stored with the given key</span>
<span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">chained_hash_get</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">t</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>){
  <span style="color: #c25959; font-weight: bold;">return</span> linked_list_search(t.table[ h(key) ], key);
}
</pre>
</div>

<ul class="org-ul">
<li>Delete</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">linked_list_delete(struct linked_list * ll, size_t key)</span>
<span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">delete the node with the given key</span>
<span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">chained_hash_delete</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">table</span> <span style="color: #e2e2e2;">t</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>){
  linked_list_delete(t.table[ h(key) ], key);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org581f1ed" class="outline-4">
<h4 id="org581f1ed"><span class="section-number-4">3.1.2.</span> Performance of chaining hash table</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The <b>load factor</b> is defined as number of elements per slot and is calculated as
\[ \alpha \text{(Load factor)} = \frac{\text{number of elements in hash table}}{\text{number of slots in hash table}} \]
The worst case for chaining is when all keys are assigned to a single slot. In this case searching for an element takes \(\theta (n)\) time.
<br />
<br />
If we assume that any given element is equally likely to be hashed into any of the slots, this assumption is called <b><i>simple uniform hashing</i></b>.
<br />
<br />
If we also assume that hash funtion takes constant time, then in the average case, the time complexity for searching key in the chaining hash table is
\[ \text{Average Case Searching} : \theta (1 + \alpha) \]
</p>
</div>
</div>
<div id="outline-container-org92ce119" class="outline-4">
<h4 id="org92ce119"><span class="section-number-4">3.1.3.</span> Open Addressing</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
In open addressing, all the key and value pair of entries are stored in the table itself. Because of this, the load factor \(\left( \alpha \right)\) can never exceed 1.
<br />
<br />
When we get a key whose slot is already taken, we will look for another empty slot. This is done by what is called <b><i>probing</i></b>. To get which slot to check next, we have various methods.
<br />
<br />
The sequence in which empty slots are looked for is fixed for given key, this sequence is called <b>probe sequence</b>. <br />
It is necessary to keep probe sequence fixed for any given key, so that we can search for it later.
</p>
</div>

<div id="outline-container-org00395eb" class="outline-5">
<h5 id="org00395eb"><span class="section-number-5">3.1.3.1.</span> Linear probing</h5>
<div class="outline-text-5" id="text-3-1-3-1">
<p>
For a given <b>ordinary hash function</b> \(h(k)\), the linear probing uses the hash function
\[ linear\_h(k, i) = (h(k) + 1)\ mod\ m \]
We refer to \(h(k)\) as the <b><i>auxiliary hash function</i></b>.
<br />
<br />
In linear probing, we first check the slot [h(k)], if it is not empty, we check [h(k) + 1] then [h(k) + 2] &#x2026;. upto slot [m - 1] after which we wrap around to [1], [2] &#x2026; till we have checked all the slots.
<br />
<br />
Linear probing is easy to implement, but it suffers from <b><i>primary clustering</i></b>. In long runs of linear probing, keys tend to cluster together. This causes the performance of operations on hash table to degrade. The time to query a random element from table degrades to \(\theta (n)\).
</p>
</div>
</div>

<div id="outline-container-org7ff686c" class="outline-5">
<h5 id="org7ff686c"><span class="section-number-5">3.1.3.2.</span> Quadratic probing</h5>
<div class="outline-text-5" id="text-3-1-3-2">
<p>
For given auxiliary hash function \(h(k)\), the quadratic probing uses
\[ quadratic\_h(k, i) = \left( h(k) + c_1i + c_2i^2 \right) \ mod\ m \]
Where, \(c_1\) and \(c_2\) are positive auxiliary constants.
</p>
<ul class="org-ul">
<li>If m is not considered, we just assume \(c_1 = 0, c_2 = 1\), this is the simplest form of quadratic probing.</li>
<li>For \(m = 2^n\), a good choice for auxiliary constants is \(c_1=c_2=1/2\).</li>
<li>For \(m = n^p\) where m, n and p are positive integers greater or equal to 2, constants \(c_1 = 1, c_2 = n\) are a good choice.</li>
</ul>

<p>
Quadratic probing works much better than linear probing.
<br />
<br />
If \(quadratic\_h(k_1, 0) = quadratic\_h(k_2,0)\), then that implies that all \(quadratic\_h(k_1, i) = quadratic\_h(k_2,i)\), i.e, they will have the same <b>probe sequence</b>. This leads to a probe sequence getting clustered. This is called <i><b>secondary clustering</b></i>. This also effects performance but not as drastically as primary clustering.
</p>
</div>
</div>
<div id="outline-container-orgeb11d50" class="outline-5">
<h5 id="orgeb11d50"><span class="section-number-5">3.1.3.3.</span> Double Hashing</h5>
<div class="outline-text-5" id="text-3-1-3-3">
<p>
Double hashing is one of the best available method for open addressing. <br />
<b>Double hashing uses <i>two auxiliary hashing functions</i>.</b>
\[ double\_h(k, i) = \left( h_1(k) + i \times h_2(k) \right) \ mod\ m \]
The value of \(h_2(k)\) must be <b>relatively prime (i.e, coprime) to number of slots (m)</b>. <br />
</p>
<ul class="org-ul">
<li>A convenient way to ensure this is let <b>m be a power of 2</b> and \(h_2(k)\) be a <b>hash function that always produces an odd number</b>.</li>
<li>Another way is to let <b>m be a prime</b> and make \(h_2(k)\) such that is <b>always produces a positive integer less than m.</b></li>
</ul>
<p>
If we use one of the above two methods (either m is a power of 2 or a prime), then double hashing improves over linear and quadratic probing since keys will have distinct probe sequences.
<br />
<br />
When using the above values of m, performance of double hashing is very close to the performance of "ideal" scheme of uniform hashing.
<b>*n</b> Performace of open addressing
In open addressing <b>load factor</b> \(\left( \alpha \right) \le 1\). We will assume <b>uniform hashing</b> i.e, any element is equally likely to be hashed in any slot. We will also assume that for any key, each possible probe sequence is equally likely.
<br />
<br />
Under these assumptions, for load factor \(\alpha\). The number of probes in an unsuccessful search is at most \(1/(1 - \alpha )\)
<br />
This means that for a constant load factor, an unsuccessful search will run in \(\theta (1)\) time.
<br />
<br />
The number of probes on average for inserting an element under these assumptions is \(1/(1- \alpha )\)
<br />
The number of probes on averge in a successful search is at most \(\frac{1}{\alpha} ln\left( \frac{1}{1-\alpha} \right)\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org370e99a" class="outline-3">
<h3 id="org370e99a"><span class="section-number-3">3.2.</span> Hash Functions</h3>
<div class="outline-text-3" id="text-3-2">
<p>
A good hash funtion will approximately satisfy the <b>simple uniform hashing</b>, which means that any element is equally likely to be hashed to any slot.
</p>

<p>
\[ m : \text{Number of slots in hash table} \]
\[ n : \text{Number of elements in hash table} \]
</p>

<p>
Suppose we knew that our keys are from a set of real numbers and the keys are picked uniformly. In this case, we could simply use the hash function \(h(k) = floor(mk)\).
<br />
<br />
Similarly, in many cases we can make a reasonably good hash funtion if we know the distribution of keys.
<br />
<br />
We will look at a few ways to make a hash function.
</p>
</div>

<div id="outline-container-org56149ae" class="outline-4">
<h4 id="org56149ae"><span class="section-number-4">3.2.1.</span> The division method</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
In division method, we map a key \(k\) into one of the \(m\) slots by taking the remainder of k divided by m.
\[ h(k) = k\ mod\ m = k\ \%\ m \]
In most cases,
\[ m : \text{Number of slots in hash table} \]
But there are some cases where \(m\) is chosen to be something else.
</p>
<ul class="org-ul">
<li>If \(m\) is a <b>power of 2</b>, then \(k\ mod\ m\) will give us the least significant \(log_2m\) bits of \(k\). When making a hash function, we want a function that depends on all bits of the key. So, <b><i>we should not use this method if m is a power of 2</i></b>.</li>
<li>A <b>prime number</b> not close to a power of 2 is a good choice for \(m\) in many cases. So when deciding the number of slots for the hash table, we can <i><b>try to make \(m\) a prime</b></i> which will accomodate our elements with less load factor.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf3fa455" class="outline-4">
<h4 id="orgf3fa455"><span class="section-number-4">3.2.2.</span> The multiplication method</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
In multiplication method, we first multiply the key \(k\) with a constant \(A\) which is in range \(0 < A < 1\). Then we get the <b>fractional part</b> of \(kA\). Then we multiply the fractional part by \(m\) and floor it to get the hash.
\[ h(k) = floor(m \times decimal\_part(kA) ) \]
The advantage of multiplication method is that we can choose any value of \(m\). We can even choose \(m\) to be a power of 2.
<br />
We can choose any value of \(A\). The value depends on characteristics of data,
\[ A \approx \frac{\sqrt{5} - 1}{2} \]
will work reasonably well.
<br />
<br />
Example, Suppose
</p>

<p>
\[ key\ (k) = 1234 \]
\[ m = 128 \]
And our value of \(A\) is,
\[ A = 0.618 \]
Then to get our \(h(k)\),
\[ kA = 762.612 \]
\[ decimal\ part(kA) = 0.612 \]
\[ floor(m \times decimal\_part(kA) ) = h(k) = 78 \]
</p>

<p>
In C language,
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #00cbcb;">hash</span>(<span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">key</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">m</span>){
  <span style="color: #dcdc00; font-weight: bold;">double</span> <span style="color: #e2e2e2;">kA</span> = key * 0.618;
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">get decimal part only</span>
  <span style="color: #dcdc00; font-weight: bold;">double</span> <span style="color: #e2e2e2;">kA</span> = kA - ((<span style="color: #dcdc00; font-weight: bold;">int</span>) kA);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">floor the product of decimal part and m</span>
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">h</span> = floor(m * kA);
  <span style="color: #c25959; font-weight: bold;">return</span> h;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb06e422" class="outline-4">
<h4 id="orgb06e422"><span class="section-number-4">3.2.3.</span> Mid square method</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
In this method, we square the keys and then we choose some digits from the middle.
Example,
\[ h(10) = middle\ digit \left( 10 \times 10 \right) = midlle\ digit (100) = 0 \]
\[ h(11) = middle\ digit \left( 11 \times 11 \right) = midlle\ digit (121) = 2 \]
\[ h(12) = middle\ digit \left( 12 \times 12 \right) = midlle\ digit (144) = 4 \]
With huge numbers, we need to take care of overflow conditions in this method.
</p>
</div>
</div>

<div id="outline-container-org5aae66e" class="outline-4">
<h4 id="org5aae66e"><span class="section-number-4">3.2.4.</span> Folding method</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
While this method can be used on integers, this method is usually used where the key is segmented. For example in arrays or when key is a string.
<br />
<br />
In this method, we add all of the segments and then we mod it with the number of slots.
\[ h(k) = \left( \text{Sum of all the segments} \right) mod\ m \]
Example, for string "hello"
<br />
sum = 'h' + 'e' + 'l' + 'l' + 'o'
<br />
sum = 104 + 101 + 108 + 108 + 111 = 532
<br />
<br />
If m = 100, then
<br />
h(k) = 532 mod 100
<br />
h(k) = 32
</p>
</div>
</div>
</div>

<div id="outline-container-orgb2f422e" class="outline-3">
<h3 id="orgb2f422e"><span class="section-number-3">3.3.</span> Universal Hashing</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Suppose a malicious adversary who know's our hash function chooses the keys that are to be hashed. He can choose keys that all hash to same slot therefore degrading performance of our hash table to \(\theta (n)\).
</p>

<p>
Fixed hash functions are vulnerable to such attacks. To prevent this from happening, we create a class of function from which a function will be choosen randomly in a way that is independent of the keys, i.e, any function can be choosen for any key. This is called <b>universal hashing</b>.
</p>

<p>
The randomization of chosen hash function will almost guarentee that we won't get the worst case behaviour. The hash function is <i><b>not changed every time we do an insert or delete operation.</b></i> Changing hash function after each operation will not allow us to lookup elements in optimal time. We only change to another hash function when we do rehashing.
</p>
</div>
<div id="outline-container-org23aba84" class="outline-4">
<h4 id="org23aba84"><span class="section-number-4">3.3.1.</span> Rehashing</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
When we need to increase the size of hash table or change the hash function, we have to do rehashing.
</p>

<p>
Rehashing is the process of taking all the entries in a hash table and then reapplying the hash function (possibly changing the hash function) and adding the entries into a new hash table, whose size is usually greater than the previous hash table.
</p>

<p>
Rehashing is usually done when load factor increases to the point that it affects performace.
<br />
In universal hashing, we will change the hash function each time we rehash the hash table.
</p>
</div>
</div>
<div id="outline-container-orgbd4c14f" class="outline-4">
<h4 id="orgbd4c14f"><span class="section-number-4">3.3.2.</span> Universal family</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
For universal hashing, the set of hash functions which is used is called <b>universal family</b>.
</p>

<p>
The set of hash functions is called universal family if, for every distinct pair of keys \((x,y)\), <b>the number of functions in set where \(h(x) = h(y)\) is less than or equal to \((|H| \div m)\)</b>.
</p>

<p>
In other words, <b>the probability of collision between any two distinct keys \((x,y)\) is less than or equal to \((1/m)\)</b> if hash function is randomly choosen from the universal family.
</p>

<p>
Here, \(m\) is the number of slots in hash table.
<br />
Sometimes, universal family may be called a universal of hash functions.
</p>
</div>
</div>
<div id="outline-container-org19214ad" class="outline-4">
<h4 id="org19214ad"><span class="section-number-4">3.3.3.</span> Performance of universal hashing</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
For any hash function \(h\) from the universal. We know that the probability of collision between two keys is \((1/m)\).
<br />
Using this, we can show that when using chaining, the expected (or average) length of each list in the hash table will be \((1 + \alpha)\).
<br />
Where, alpha is the load factor of hash table.
</p>
</div>
</div>
<div id="outline-container-orgfaf8460" class="outline-4">
<h4 id="orgfaf8460"><span class="section-number-4">3.3.4.</span> Example for universal set of hash functions</h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
Suppose we have set of keys \(\{ 0,1,2,...,k \}\), we will choose a prime number \(p > k\).
Then we can define a hash funtion
\[ h_{ab}(k) = \left( (ak + b)\ mod\ p \right) \ mod\ m \]
And, the universal is
\[ H = \{ h_{ab} : a \in \{ 1,2,...,(p-1) \} \ and \ b \in \{ 0,1,...,(p-1) \} \} \]
This class of hash functions will map from set \(\{ 0,1,2,...,(p-1) \}\) to set \(\{ 0,1,2,...,(m-1) \}\).
<br />
Here, \(m\) is the number of slots in hash table.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf71fb05" class="outline-3">
<h3 id="orgf71fb05"><span class="section-number-3">3.4.</span> Perfect Hashing</h3>
<div class="outline-text-3" id="text-3-4">
<p>
TODO : Doing this or nah
NOTE : This doesn't seem to be in B.Tech syllabus, but it seems cool.
<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7cbf501" class="outline-2">
<h2 id="org7cbf501"><span class="section-number-2">4.</span> Representing rooted trees using nodes</h2>
<div class="outline-text-2" id="text-4">
<p>
We can represent trees using nodes.  A node only stores a single element of the tree. What is a node will depend on the language being used.
<br />
In C, we make a struct which will store the element and pointers to other node structs.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span>{
  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">element</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">left_child</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">right_child</span>;
};
</pre>
</div>
<p>
<br />
In languages with oop, we create node class which will store refrences to other node objects.
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #c25959; font-weight: bold;">class</span> <span style="color: #dcdc00; font-weight: bold;">Node</span> {
    <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>;
    <span style="color: #dcdc00; font-weight: bold;">Node</span> <span style="color: #e2e2e2;">left</span>;
    <span style="color: #dcdc00; font-weight: bold;">Node</span> <span style="color: #e2e2e2;">right</span>;

    Node(<span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>) {
        <span style="color: #c25959; font-weight: bold;">this</span>.value = value;
        right = <span style="color: #3eca3e;">null</span>;
        left = <span style="color: #3eca3e;">null</span>;
    }
}
</pre>
</div>
</div>

<div id="outline-container-org00f3c9f" class="outline-3">
<h3 id="org00f3c9f"><span class="section-number-3">4.1.</span> Fixed number of children</h3>
<div class="outline-text-3" id="text-4-1">
<p>
When we know how many children any given node can have, i.e, the number of children is bounded. We can just use refrences or pointers to the nodes directly.
<br />
For example, if we know we are making a binary tree, then we can just store refrence to left children and right childern.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span>{
  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">element</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">left_child</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">right_child</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org092967c" class="outline-3">
<h3 id="org092967c"><span class="section-number-3">4.2.</span> Unbounded number of children</h3>
<div class="outline-text-3" id="text-4-2">
<p>
When we don't know how many children any given node will have. Thus any node can have any number of children, we can't just use refrences. We could create an array of refrences to nodes, but some nodes will only have one or two childs and some may have no childs. This will lead to a lot of wasted memory.
<br />
There is a way to represent such trees without wasting any memory. This is done by using <b>sibling refrences or pointers</b>.
<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span>{
  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">element</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">left_child</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">right_sibling</span>;
};
</pre>
</div>

<p>
The right sibling pointer will point to the right sibling of the node. This allows us to chain siblings and have unbounded number of siblings to the given node, therefore having unbounded number of children to any given parent. To make this approach easier to use, we can also add a pointer back to the parent node, though it is not compulsary.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span>{
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">parent</span>;

  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">element</span>;

  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">left_child</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">tree_node</span> * <span style="color: #e2e2e2;">right_sibling</span>;
};
</pre>
</div>

<p>
So a tree which is like :
<br />
<img src="./imgs/tree_actual.jpg" alt="tree_actual.jpg" />
<br />
<br />
can be represented using refrences and pointers as :
<br />
<img src="./imgs/tree_representation.jpg" alt="tree_representation.jpg" />
<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgeea09e3" class="outline-2">
<h2 id="orgeea09e3"><span class="section-number-2">5.</span> Binary Search Trees</h2>
<div class="outline-text-2" id="text-5">
<p>
A tree where any node can have only two child nodes is called a <b><i>binary tree</i></b>.
<br />
A binary search tree is a tree where for any give node <b>the nodes stored in left sub-tree are less than the parent node</b> and the <b>nodes stored in right sub-tree are greater than the parent node</b> (or vice versa). So the left-subtree always have smaller elements and right sub-tree always have greater elements.
<br />
<br />
This property allows us easily search for elements from the data structure. We start our search at the root node. If the element we want is less than the current node, we will go to the left node ,else we will go to the right node. The concept is similar to the binary search on arrays.
</p>

<p>
In C, we can make a binary tree as
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span>{
  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">left_child</span>;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">right_child</span>;
};
</pre>
</div>
</div>

<div id="outline-container-org068d34e" class="outline-3">
<h3 id="org068d34e"><span class="section-number-3">5.1.</span> Quering a BST</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Some common ways in which we usually query a BST are searching for a node, minimum &amp; maximum node and successor &amp; predecessor nodes. We will also look at how we can get the parent node for a given node, if we already store a parent pointer then that algorithm will be unnecessary.
</p>
</div>
<div id="outline-container-orgcf1d625" class="outline-4">
<h4 id="orgcf1d625"><span class="section-number-4">5.1.1.</span> Searching for node</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
We can search for a node very effectively with the help of binary search tree property. The search will return the node if it is found, else it will return NULL.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *
<span style="color: #00cbcb;">search_recursively</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">root</span>, <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">If we reach a null, then value is not in tree</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(root == <span style="color: #3eca3e;">NULL</span>)
    <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if we found the value, return the current node</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(root-&gt;value == value)
    <span style="color: #c25959; font-weight: bold;">return</span> root;
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">compare value we are looking for</span>
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">and go to either left or right sub-tree</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(value &lt; root-&gt;value)
    <span style="color: #c25959; font-weight: bold;">return</span> search_recursively(root-&gt;left, value);
  <span style="color: #c25959; font-weight: bold;">else</span>
    <span style="color: #c25959; font-weight: bold;">return</span> search_recursively(root-&gt;right, value);
}
</pre>
</div>
<p>
We can also search iteratively rather than recursively.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *
<span style="color: #00cbcb;">search_iterative</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">root</span>, <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">value</span>){
  <span style="color: #c25959; font-weight: bold;">while</span>(root != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if we found the value, return the current node</span>
    <span style="color: #c25959; font-weight: bold;">if</span>(root-&gt;value == value) <span style="color: #c25959; font-weight: bold;">return</span> root;
    <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">compare value and go to left or right sub-tree</span>
    root = (value &lt; root-&gt;value) ? root-&gt;left : root-&gt;right;
  }
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if not found then return NULL</span>
  <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1eccdb9" class="outline-4">
<h4 id="org1eccdb9"><span class="section-number-4">5.1.2.</span> Minimum and maximum</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Finding the minimum and maximum is simple in a Binary Search Tree. The minimum element will be the leftmost node and maximum will be the rightmost node. We can get the minimum and maximum nodes by using these algorithms.
</p>
<ul class="org-ul">
<li>For minimum node</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #00cbcb;">minimum</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">root</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(root == <span style="color: #3eca3e;">NULL</span>) <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
  <span style="color: #c25959; font-weight: bold;">while</span>(root-&gt;left != <span style="color: #3eca3e;">NULL</span>)
    root = root-&gt;left;
  <span style="color: #c25959; font-weight: bold;">return</span> root;
}
</pre>
</div>
<ul class="org-ul">
<li>For maximum node</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #00cbcb;">maximum</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">root</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(root == <span style="color: #3eca3e;">NULL</span>) <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
  <span style="color: #c25959; font-weight: bold;">while</span>(root-&gt;right != <span style="color: #3eca3e;">NULL</span>)
    root = root-&gt;right;
  <span style="color: #c25959; font-weight: bold;">return</span> root;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd1eb8f1" class="outline-4">
<h4 id="orgd1eb8f1"><span class="section-number-4">5.1.3.</span> Find Parent Node</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
This algorithm will return the parent node. It uses a trailing node to get the parent. If the root node is given, then it will return NULL. <b>This algorithm makes the assumption that the node is in the tree</b>.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * 
<span style="color: #00cbcb;">find_parent</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">tree</span>, <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">node</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(tree == node) <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;

  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">current_node</span> = tree;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">trailing_node</span> = tree;

  <span style="color: #c25959; font-weight: bold;">while</span>(current_node != node){
    trailing_node = current_node;
    current_node = (node-&gt;value &lt; current_node-&gt;value) ?
      current_node-&gt;left :
      current_node-&gt;right;
  }

  <span style="color: #c25959; font-weight: bold;">return</span> trailing_node;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org06aec1b" class="outline-4">
<h4 id="org06aec1b"><span class="section-number-4">5.1.4.</span> Is ancestor</h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
This algorithm will take two nodes, ancestor and descendant. Then it will check if ancestor node is really the ancestor of descendant node.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">bool</span>
<span style="color: #00cbcb;">is_ancestor</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">ancestor</span>,
            <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">descendant</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">both ancestor and descendant</span>
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">should not be NULL</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(ancestor == <span style="color: #3eca3e;">NULL</span> || descendant == <span style="color: #3eca3e;">NULL</span>)
    <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">false</span>;

  <span style="color: #c25959; font-weight: bold;">while</span>(ancestor != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">if</span>(ancestor == descendant) <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">true</span>;
    ancestor = (descendant-&gt;value &lt; ancestor-&gt;value) ?
               ancestor-&gt;left :
               ancestor-&gt;right;
  }
  <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">false</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgad2acf4" class="outline-4">
<h4 id="orgad2acf4"><span class="section-number-4">5.1.5.</span> Successor and predecessor</h4>
<div class="outline-text-4" id="text-5-1-5">
<p>
We often need to find the successor or predecessor of an element in a Binary Search Tree. The search for predecessor and succesor is divided in to two cases.
</p>
</div>

<div id="outline-container-orgc182038" class="outline-5">
<h5 id="orgc182038"><span class="section-number-5">5.1.5.1.</span> For Successor</h5>
<div class="outline-text-5" id="text-5-1-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">get successor of x</span>
<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *
<span style="color: #00cbcb;">successor</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">tree</span>, <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">x</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 1 : right subtree is non-empty</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(x-&gt;right != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">return</span> minimum(x-&gt;right);
  }
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 2 : right subtree is empty</span>
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">y</span> = find_parent(tree, x);
  <span style="color: #c25959; font-weight: bold;">while</span>(y != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">if</span>(is_ancestor(y, x) &amp;&amp; is_ancestor(y-&gt;left, x)) <span style="color: #c25959; font-weight: bold;">return</span> y;
    y = find_parent(tree, y);
  }
  <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
}
</pre>
</div>
<p>
<b>Case 1</b> : If the node x has a right subtree, then the minimum of right subtree of x is the succesor.
<br />
<b>Case 2</b> : If the node x has no right subtree, then successor may or may not exist. If it exists, the successor node will be the ancestor of x whose own left node is also the ancestor of x.
</p>
</div>
</div>
<div id="outline-container-org4eea03a" class="outline-5">
<h5 id="org4eea03a"><span class="section-number-5">5.1.5.2.</span> For Predecessor</h5>
<div class="outline-text-5" id="text-5-1-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *
<span style="color: #00cbcb;">predecessor</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">tree</span>, <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">x</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 1 : left subtree is non-empty</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(x-&gt;left != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">return</span> maximum(x-&gt;left);
  }
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 2 : left subtree is empty</span>
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">y</span> = find_parent(tree, x);
  <span style="color: #c25959; font-weight: bold;">while</span>(y != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">if</span>(is_ancestor(y, x) &amp;&amp; is_ancestor(y-&gt;right, x)) <span style="color: #c25959; font-weight: bold;">return</span> y;
    y = find_parent(tree, y);
  }
  <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
}
</pre>
</div>
<p>
<b>Case 1</b> : If the node x has a left subtree, then the maximum of left subtree of x is the predecessor.
<br />
<b>Case 2</b> : If the node x has no left subtree, then predecessor may or may not exist. If it exists, the predecessor node will be the ancestor of x whose own right node is also the ancestor of x.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge2c01f8" class="outline-3">
<h3 id="orge2c01f8"><span class="section-number-3">5.2.</span> Inserting and Deleting nodes</h3>
<div class="outline-text-3" id="text-5-2">
<p>
When inserting and deleting nodes in BST, we need to make sure that the Binary Search Tree property continues to hold. Inserting node is easier in a binary search tree than deleting a node.
</p>
</div>
<div id="outline-container-orga3817ac" class="outline-4">
<h4 id="orga3817ac"><span class="section-number-4">5.2.1.</span> Insertion</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Insertion is simple in a binary search tree. We search for the node we want to insert in the tree and insert it where we find first NULL spot.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span>
<span style="color: #00cbcb;">insert_node</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> ** <span style="color: #e2e2e2;">tree</span>, <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">node</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if found a null spot, insert the node</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(*tree == <span style="color: #3eca3e;">NULL</span>){
    *tree = node;
    <span style="color: #c25959; font-weight: bold;">return</span>;
  }  
  <span style="color: #c25959; font-weight: bold;">if</span>(node-&gt;value &lt; (*tree)-&gt;value){
    <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">the node is to be inserted into left subtree</span>
    <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> ** <span style="color: #e2e2e2;">left_tree</span> = &amp;((*tree)-&gt;left);
    insert_node(left_tree, node);
  }<span style="color: #c25959; font-weight: bold;">else</span>{
    <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">the node is to be inserted into right subtree</span>
    <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> ** <span style="color: #e2e2e2;">right_tree</span> = &amp;((*tree)-&gt;right);
    insert_node(right_tree, node);
  }
}
</pre>
</div>
<p>
The recursive algorithm for inserting into a Binary search tree is simpler than the iterative algorithm.
<br />
<br />
The algorithm for iterative insertion is
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span>
<span style="color: #00cbcb;">insert_node</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> **<span style="color: #e2e2e2;">tree</span>, <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">node</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if no nodes in tree, then just node and return</span>
  <span style="color: #c25959; font-weight: bold;">if</span>((*tree) == <span style="color: #3eca3e;">NULL</span>){
    *tree = node;
    <span style="color: #c25959; font-weight: bold;">return</span>;
  }

  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> ** <span style="color: #e2e2e2;">current_node</span> = tree;
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> ** <span style="color: #e2e2e2;">trailing_node</span> = tree;

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">look for an empty place using current_node</span>
  <span style="color: #c25959; font-weight: bold;">while</span>(*current_node != <span style="color: #3eca3e;">NULL</span>){
    trailing_node = current_node;
    current_node = (node-&gt;value &lt; (*current_node)-&gt;value) ?
      &amp;((*current_node)-&gt;left) : &amp;((*current_node)-&gt;right);
  }

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">we need to insert node on the trailing node</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(node-&gt;value &lt; (*trailing_node)-&gt;value)
    (*trailing_node)-&gt;left = node;
  <span style="color: #c25959; font-weight: bold;">else</span>
    (*trailing_node)-&gt;right = node;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org43bca22" class="outline-4">
<h4 id="org43bca22"><span class="section-number-4">5.2.2.</span> Deletion</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
Deletion in Binary Search Trees is tricky because we need to delete nodes in a way that the property of the Binary Search Tree holds after the deletion of the node. So we first have to remove the node from the tree before we can free it.
<br />
<br />
There are <b>four different cases</b> which can occur when we try to delete a node. All four have a different method to handle them. These four cases relate to how many children the node which we want to delete has.
<br />
Suppose the node is \(X\).
</p>
<ol class="org-ol">
<li>Node \(X\) has no children i.e. it is a leaf node. In this case, we can simply delete the node and replace it with NULL.</li>
<li>Node \(X\) has one child. In this case, the child of node \(X\) will take it's place and we can delete node \(X\).</li>
<li>Node \(X\) has both left and right child, and the right child of \(X\), is the successor of \(X\). In this case, we will replace the left child of successor to left child of \(X\), then replace \(X\) with it's own right child.</li>
<li>Node \(X\) has both left and right child, and the right child if not the successor of \(X\). In this case, we will replace the successor node with it's own right child. Then, we will replace both left and right child of succesor node with left and right childs of \(X\) respectively. Finally, we can replace \(X\) with the succesor node.</li>
</ol>

<p>
TODO : add images here for four cases.
</p>
<ul class="org-ul">
<li><b>Implementation in code</b></li>
</ul>
<p>
We also use a helper function called Replace Child for deletion of node. This function will simply take  parent node, old child node and new child node and replace old child with new child.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span>
<span style="color: #00cbcb;">replace_child</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">parent</span>,
              <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">old_child</span>,
              <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">new_child</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(parent-&gt;left == old_child) parent-&gt;left = new_child;
  <span style="color: #c25959; font-weight: bold;">else</span> parent-&gt;right = new_child;
}
</pre>
</div>

<p>
We will create a funtion that will remove the root node from a given subtree and then return the root node of the result subtree.
This will allow us to apply remove root node funtion on any node and then reattach the new subtree.
<br />
<br />
Making remove root node a different funtion will also allow us to not worry about attaching the the subtree immediately in the same funtion.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *
<span style="color: #00cbcb;">remove_root_node</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">root</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 1 : no child</span>
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">this case can be skipped in real implementation</span>
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">as it is covered by the case 2</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(root-&gt;left == <span style="color: #3eca3e;">NULL</span> &amp;&amp; root-&gt;right == <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">return</span> <span style="color: #3eca3e;">NULL</span>;
  }

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 2 : one child</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(root-&gt;left == <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">return</span> root-&gt;right;
  }<span style="color: #c25959; font-weight: bold;">else</span> <span style="color: #c25959; font-weight: bold;">if</span>(root-&gt;right == <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #c25959; font-weight: bold;">return</span> root-&gt;left;
  }

  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">successor</span> = minimum(root-&gt;right);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 3 : two child and successor is right node of root node</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(successor == root-&gt;right){
    successor-&gt;left = root-&gt;left;
    <span style="color: #c25959; font-weight: bold;">return</span> successor;
  }

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">case 4 : two child and successor is not the right node of root node</span>
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">successor_parent</span> = find_parent(root, successor);
  replace_child(successor_parent, successor, successor-&gt;right);
  successor-&gt;left = root-&gt;left;
  successor-&gt;right = root-&gt;right;
  <span style="color: #c25959; font-weight: bold;">return</span> successor;
}
</pre>
</div>

<p>
Now we can make a delete node function which will remove the node, reattach the subtree and also free or delete the node.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span>
<span style="color: #00cbcb;">delete_node</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tre</span> **<span style="color: #e2e2e2;">tree</span>, <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">node</span>){
  <span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> *<span style="color: #e2e2e2;">new_root</span> = remove_root_node(node);

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if deleting root node of tree</span>
  <span style="color: #c25959; font-weight: bold;">if</span>(node == (*tree)){
    (*tree) = new_root;
    free(node);
    <span style="color: #c25959; font-weight: bold;">return</span>;
  }

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">when not deleting root node of tree</span>
  replace_child(find_parent(*tree, node)
                ,node ,new_root);
  free(node);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5be9c4c" class="outline-3">
<h3 id="org5be9c4c"><span class="section-number-3">5.3.</span> Performance of BST</h3>
<div class="outline-text-3" id="text-5-3">
<p>
The performance of the search operation depends on the height of the tree. If the tree has \(n\) elements, the height of a binary tree can be between \(n\) and \(floor\left( 1+ log_2(n) \right)\).
<br />
<br />
To perform an operation on BST, we need to find the node where we have perform the operation. Since even in worst case <b>we only need to traverse the height of the search tree to search for any node</b>, the time taken to perform any operation on a Binary Search Tree is  \(\theta (h)\) where, \(h\) is the height of the tree.
<br />
<br />
A binary tree with height of \(floor(1 + log_2(n))\) is called a <b>balanced binary tree</b>, otherwise it is an unbalanced tree. A balanced binary tree is the shortest height a binary tree with that number of nodes can have.
<br />
<br />
The worst case is when tree has a single branch, making the height of tree n. In this case, the worst case for any operation takes \(\theta (n)\) time.
<br />
A balanced binary search tree in worst case for any operation will take \(\theta (log_2n)\) time.
</p>
</div>
</div>

<div id="outline-container-orgcf9a8ac" class="outline-3">
<h3 id="orgcf9a8ac"><span class="section-number-3">5.4.</span> Traversing a Binary Tree</h3>
<div class="outline-text-3" id="text-5-4">
<p>
There are three ways to traverse a binary tree, inorder tree walk, preorder tree walk and postorder tree walk. All three algorithm will take \(\theta (n)\) time to traverse the \(n\) nodes.
</p>
</div>

<div id="outline-container-orgef80d36" class="outline-4">
<h4 id="orgef80d36"><span class="section-number-4">5.4.1.</span> Inorder tree walk</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
This algorithm is named so because it first traverses the left sub-tree recursively, then the node value and then traverses right sub-tree recursively.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">inorder_print</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">node</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(node == <span style="color: #3eca3e;">NULL</span>)
    <span style="color: #c25959; font-weight: bold;">return</span>;
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">recursively print left sub-tree</span>
  inorder_print(node-&gt;left_child);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">print the node value</span>
  printf(<span style="color: #3eca3e;">"%d\t"</span>, node-&gt;value);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">recursively print right sub-tree</span>
  inorder_print(node-&gt;right_child);
}
</pre>
</div>

<ul class="org-ul">
<li><b>Inorder algorithm will traverse the binary search tree in a sorted order.</b> Thus, it can be used to get nodes in a sorted order.</li>
<li>This algorithm is not suitable to delete or free the nodes of the tree. It should not be used to delete a binary tree.</li>
<li>This algorithm cannot we used to make a copy of a binay search tree.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd2f801a" class="outline-4">
<h4 id="orgd2f801a"><span class="section-number-4">5.4.2.</span> Preorder tree walk</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
This algorithm is called preorder algorithm because it will first traverse the current node, then recursively traverses the left sub-tree and then recursively traverse the right sub-tree.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">preorder_print</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">node</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(node == <span style="color: #3eca3e;">NULL</span>)
    <span style="color: #c25959; font-weight: bold;">return</span>;
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">print the node</span>
  printf(<span style="color: #3eca3e;">"%d\t"</span>, node-&gt;value);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">recursively print left sub-tree</span>
  preorder_print(node-&gt;left_child);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">recursively print right sub-tree</span>
  preorder_print(node-&gt;right_child);
}
</pre>
</div>
<ul class="org-ul">
<li><b>This algorithm is used to create a copy of the Binary Search Tree</b>. If we store nodes in an array using this algorithm and then later insert the nodes linearly in a simple binary search tree, we will have an exact copy of the tree.</li>
<li>This algorithm traverses the tree in a <b>topologically sorted</b> order.</li>
<li>This algorithm cannot be used to delete or free the nodes of the tree.</li>
</ul>
</div>
</div>
<div id="outline-container-org4720c1c" class="outline-4">
<h4 id="org4720c1c"><span class="section-number-4">5.4.3.</span> Postorder tree walk</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
In this algorithm, we first traverse the left sub-tree recursively, then the right-sub tree recursively and finally the node.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">postorder_print</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">binary_tree</span> * <span style="color: #e2e2e2;">node</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(node == <span style="color: #3eca3e;">NULL</span>)
    <span style="color: #c25959; font-weight: bold;">return</span>;
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">recursively print left sub-tree</span>
  postorder_print(node-&gt;left_child);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">recursively print right sub-tree</span>
  postorder_print(node-&gt;right_child);
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">print the node</span>
  printf(<span style="color: #3eca3e;">"%d\t"</span>, node-&gt;value);
}
</pre>
</div>
<ul class="org-ul">
<li><b>This algorithm can be used to delete or free all the nodes of a binary tree</b>.</li>
<li>This algorithm cannot be used to create a copy of the tree</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgeeca0a9" class="outline-2">
<h2 id="orgeeca0a9"><span class="section-number-2">6.</span> Binary Heap</h2>
<div class="outline-text-2" id="text-6">
<p>
Heap is a data structure represented as a complete tree which follows the heap property. All levels in a heap tree are completely filled except possible the last one, which is filled from left to right. 
<br />
<br />
The most common implementation of the heap is a <b>binary heap</b>. The binary heap is represented as a binary tree. We can use an array to implement binary heaps.
<br />
<br />
The heap data structure is used to implement <b>priority queues</b>. In many cases we even refer to heaps as priority queues and vice versa.
</p>
</div>

<div id="outline-container-org8e7cc0a" class="outline-3">
<h3 id="org8e7cc0a"><span class="section-number-3">6.1.</span> Heap Property</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Heaps are of two types
</p>
<ul class="org-ul">
<li><b>min-heap</b> : the smallest element is at the root of the tree.</li>
<li><b>max-heap</b> : the largest element is at the root of the tree.</li>
</ul>
<p>
The heap property is different for min-heaps and max-heaps.
</p>
<ul class="org-ul">
<li><b>for min-heap</b> : the key stored in parent node is always less than or equal \((\le)\) to the key of child node.</li>
<li><b>for max-heap</b> : the key stored in parent node is always greter than or equal \((\ge)\) to the key of child node.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbf5eade" class="outline-3">
<h3 id="orgbf5eade"><span class="section-number-3">6.2.</span> Shape of Heap</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Also reffered to as <b>shape property</b> of heap.
<br />
A heap is represented as a complete tree. A complete tree is one where all the levels are completely filled except possible the last. The last level if not completely filled is filled from left to right.
</p>
</div>
</div>
<div id="outline-container-orgb19ce0e" class="outline-3">
<h3 id="orgb19ce0e"><span class="section-number-3">6.3.</span> Array implementation</h3>
<div class="outline-text-3" id="text-6-3">
<p>
We can implement binary heap using arrays. The root of tree is the first element of the array. The next two elements are elements of second level of tree and children of the root node. Similary, the next four elements are elements of third level of tree and so on.
<br />
<br />
<i><b>For a given level, the position in array from left to right is the position of elements in tree from left to right.</b></i>
<br />
<br />
For example, a max-heap implemented using array can be represented as tree as shown
<br />
<br />
<img src="./imgs/Heap-as-array.svg" alt="Heap-as-array.svg" class="org-svg" />
<br />
<br />
In C, we can create a heap struct for easier implementation of algorithms
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">heap_type</span>{
  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">array</span>[];
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">capacity</span>;
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">len</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd6f65c2" class="outline-3">
<h3 id="orgd6f65c2"><span class="section-number-3">6.4.</span> Operations on heaps</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Both insertion and deletion in heap must be done in a way which conform to the heap property as well as shape property of heap. Before we can look at insertion and deletion, we need a way to find parent and child for a given index. We will also first see up-heapify and down-heapfiy funtions.
</p>
</div>
<div id="outline-container-org43125ac" class="outline-4">
<h4 id="org43125ac"><span class="section-number-4">6.4.1.</span> Parent and child indices</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
In a binary heap, we can find parent and children for any given index using simple formulas.
</p>
<ul class="org-ul">
<li>If array is zero indexed, for element at index i
<ul class="org-ul">
<li>children at indices \((2i + 1)\) and \((2i + 2)\)</li>
<li>parent at index \(floor\left( (i - 1)/2 \right)\)</li>
</ul></li>
<li>If array is one indexed, for element at index i
<ul class="org-ul">
<li>children at indices \((2i)\) and \((2i + 1)\)</li>
<li>parent at index \(floor\left( i/2 \right)\)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org05ab70a" class="outline-4">
<h4 id="org05ab70a"><span class="section-number-4">6.4.2.</span> Down-heapify</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
The down-heapify is a function which can re-heapify an array if no element of heap violates the heap property other than index and it's two children.
<br />
This function runs in \(\theta (log_2n)\) time. The algorithm for this works as follows
</p>
<ol class="org-ol">
<li>Compare the index element with its children and stop if in correct order in relation to both children.</li>
<li>If not in correct order, swap the index element with the children which is not in correct order. Repeat till in correct order or at the lowest level.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">down_heapify</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">heap_type</span> <span style="color: #e2e2e2;">heap</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">index</span>){
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">left</span> = 2 * index  + 1;
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">right</span> = 2 * index + 2;
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">largest</span> = index;

  <span style="color: #c25959; font-weight: bold;">if</span>(left &lt; heap.len &amp;&amp; heap.array[left] &gt; heap.array[largest])
    largest = left;

  <span style="color: #c25959; font-weight: bold;">if</span>(right &lt; heap.len &amp;&amp; heap.array[right] &gt; heap.array[largest])
    largest = right;

  <span style="color: #c25959; font-weight: bold;">if</span>(largest != index){
    swap(heap.array[index], heap.array[largest]);
    down_heapify(heap, largest);
  }
}
</pre>
</div>

<p>
Since we shift element downwards, this operation is often called <i>down-heap</i> operation. It is also known as <i>trickle-down, swim-down, heapify-down, or cascade-down</i>
</p>
</div>
</div>

<div id="outline-container-org399a72c" class="outline-4">
<h4 id="org399a72c"><span class="section-number-4">6.4.3.</span> Up-heapify</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
The up-heapify is a function which can re-heapify an array if no element of heap violates the heap property other than index and it's parent.
<br />
This function runs in \(\theta (log_2n)\) time. The algorithm for this works as follows
</p>
<ol class="org-ol">
<li>Compare the index element to its parent and stop algorithm if it is in correct order.</li>
<li>If not in correct order, swap element with its parent. Repeat till element in correct position or at root position.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">up_heapify</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">heap_type</span> <span style="color: #e2e2e2;">heap</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">index</span>){
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">parent</span> = (index - 1) / 2;
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">smallest</span> = index;

  <span style="color: #c25959; font-weight: bold;">if</span>(parent &gt;= 0 &amp;&amp; heap.array[smallest] &gt; heap.array[parent])
    smallest = parent;

  <span style="color: #c25959; font-weight: bold;">if</span>(smallest != index){
    swap(heap.array[index], heap.array[smallest]);
    up_heapify(heap, smallest);
  }
}
</pre>
</div>

<p>
Since we shift element upwards, this operation is often called <i>up-heap</i> operation. It is also known as <i>trickle-up, swim-up, heapify-up, or cascade-up</i>
</p>
</div>
</div>
<div id="outline-container-org63bf7f2" class="outline-4">
<h4 id="org63bf7f2"><span class="section-number-4">6.4.4.</span> Insertion</h4>
<div class="outline-text-4" id="text-6-4-4">
<p>
Insertion takes \(\theta (log_2n)\) time in a binary heap. To insert and element in heap, we will add it to the end of the heap and then apply up-heapify operation of the elment
<br />
The code shows example of insertion in a max-heap.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">insert_element</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">heap_type</span> <span style="color: #e2e2e2;">heap</span>, <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">element</span>){
  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">add element</span>
  <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">element_index</span> = heap.len;
  <span style="color: #c25959; font-weight: bold;">if</span>(element_index == heap.capacity){
    printf(<span style="color: #3eca3e;">"Heap reached full capacity"</span>);
    <span style="color: #c25959; font-weight: bold;">return</span>;
  }

  heap.array[heap.len++] = element;
  up_heapify(heap, heap.len - 1);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfcc9520" class="outline-4">
<h4 id="orgfcc9520"><span class="section-number-4">6.4.5.</span> Deletion or Extraction</h4>
<div class="outline-text-4" id="text-6-4-5">
<p>
Like insertion, extraction also takes \(\theta (log_2n)\) time. Extraction from heap will extract the root element of the heap. We can use the down-heapify function in order to re-heapify after extracting the root node.
<br />
<br />
The code shows example of extraction in max-heap.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #00cbcb;">extract_element</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">heap_type</span> <span style="color: #e2e2e2;">heap</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(heap.len &lt; 1){
    printf(<span style="color: #3eca3e;">"No elements in the heap"</span>);
    <span style="color: #c25959; font-weight: bold;">return</span> -1;
  }

  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">r</span> = heap.array[0];
  heap.array[0] = heap.array[heap.len - 1];
  heap.len -= 1;

  down_heapify(heap, 0);

  <span style="color: #c25959; font-weight: bold;">return</span> r;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org47ce745" class="outline-4">
<h4 id="org47ce745"><span class="section-number-4">6.4.6.</span> Insert then extract</h4>
<div class="outline-text-4" id="text-6-4-6">
<p>
Inserting an element and then extracting from the heap can be done more efficiently than simply calling these functions seperately as defined previously. If we call both funtions we define above, we have to do an up-heap operation followed by a down-heap. Instead, there is a way to do just a single down-heap.
<br />
<br />
The algorithm for this will work as follows in a max-heap.
</p>
<ol class="org-ol">
<li>Compare whether the item we are trying to push is greater than root of heap.</li>
<li>If item we are pushing is greater, return it.</li>
<li>Else,
<ol class="org-ol">
<li>Replace root element with new item</li>
<li>Apply down-heapify on the root of heap</li>
<li>Return the orignal root heap which we replaced.</li>
</ol></li>
</ol>

<p>
In python, this is implemented by the name of <b><i>heap replace</i></b>.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #00cbcb;">heap_replace</span>(<span style="color: #c25959; font-weight: bold;">struct</span> <span style="color: #dcdc00; font-weight: bold;">heap_type</span> <span style="color: #e2e2e2;">heap</span>, <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">element</span>){
  <span style="color: #c25959; font-weight: bold;">if</span>(element &gt; heap.array[0])
    <span style="color: #c25959; font-weight: bold;">return</span> element;

  <span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">r</span> = heap.array[0];
  swap(heap.array[0], element);
  down_heapify(heap, 0);
  <span style="color: #c25959; font-weight: bold;">return</span> r;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org54c7a08" class="outline-4">
<h4 id="org54c7a08"><span class="section-number-4">6.4.7.</span> Searching</h4>
<div class="outline-text-4" id="text-6-4-7">
<p>
Searching for a arbitrary element takes linear time in a heap. We use linear search to search for element in array.
</p>
</div>
</div>
<div id="outline-container-orge3a08f2" class="outline-4">
<h4 id="orge3a08f2"><span class="section-number-4">6.4.8.</span> Deleting arbitray element</h4>
<div class="outline-text-4" id="text-6-4-8">
<p>
For a max-heap, deleting an arbitrary element is done as follows
</p>
<ol class="org-ol">
<li>Find the element to delete and get its index \(i\).</li>
<li>swap last element and the element at index \(i\), and decrease the size of heap.</li>
<li>apply down-heapify on index \(i\) if any of it's children violate the heap property else apply up-heapify if the parent element violates the heapify property.</li>
</ol>
</div>
</div>
<div id="outline-container-org8a91190" class="outline-4">
<h4 id="org8a91190"><span class="section-number-4">6.4.9.</span> Decrease and increase keys</h4>
<div class="outline-text-4" id="text-6-4-9">
<p>
TODO : I don't know if it is neccessary to do this operation. It looks simple to implement.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc6cf4ef" class="outline-3">
<h3 id="orgc6cf4ef"><span class="section-number-3">6.5.</span> Building a heap from array</h3>
<div class="outline-text-3" id="text-6-5">
<p>
We can convert a normal array into a heap using the down-heapify operation in linear time \(\left( \theta (n) \right)\)
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">array.array[..] contains an array which is not a heap yet</span>
<span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">this funtion will turn it into a correct heap</span>
<span style="color: #dcdc00; font-weight: bold;">void</span> <span style="color: #00cbcb;">build_heap</span>(<span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">array</span>[], <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">len</span>){
  <span style="color: #c25959; font-weight: bold;">for</span>(<span style="color: #dcdc00; font-weight: bold;">int</span> <span style="color: #e2e2e2;">i</span> = (len/2) - 1; i &gt;= 0; i--)
    down_heapify(array, i);
}
</pre>
</div>
<p>
As we see, for <b><i>zero indexed language</i></b>, the range of for loop is [(len(array)/2) - 1, 0]
<br />
If we are using a <b><i>one indexed language</i></b>, then range of for loop is [len(array)/2, 1]
</p>
</div>
</div>
</div>

<div id="outline-container-org3e3ed9b" class="outline-2">
<h2 id="org3e3ed9b"><span class="section-number-2">7.</span> Graphs</h2>
<div class="outline-text-2" id="text-7">
<p>
A graph is a data structure which consists of nodes/vertices, and edges. We sometimes write it as \(G=(V,E)\), where \(V\) is the set of vertices and \(E\) is the set of edges. When we are working on runtime of algorithms related to graphs, we represent runtime in two input sizes. \(|V|\) which we simply write as \(V\) is the number of vertices and similarly \(E\) is the number of edges. 
</p>
</div>
<div id="outline-container-org6625a01" class="outline-3">
<h3 id="org6625a01"><span class="section-number-3">7.1.</span> Representing graphs</h3>
<div class="outline-text-3" id="text-7-1">
<p>
We need a way to represent graphs in computers and to search a graph. Searching a graph means to systematically follow edges of graphs in order to reach vertices.
<br />
<br />
The two common ways of representing graphs are either using adjacency lists and adjacency matrix. Either can represent both directed and undirected graphs.
</p>
</div>

<div id="outline-container-org3138112" class="outline-4">
<h4 id="org3138112"><span class="section-number-4">7.1.1.</span> Adjacency List</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
Every node in the graph is represented by a linked list. The list contains the nodes to which the list node is connected by an edge.
<br />
Example, if list-0 contains node-3, then node-0 is connected to node-3 by an edge.
</p>
<ul class="org-ul">
<li>For <b>undirected graphs</b> this will simply work by storing all nodes in list who have a shared edge with list node.</li>
<li>For <b>directed graphs</b> we will only add node to list, if edge goes from list node to the stored node.</li>
</ul>
<p>
So in our previous example, if list-0 contains node-3, then the edge goes from 0 to 3 in the directed graph.
<br />
<br />
The space taken by adjacency list representation is \(\theta (V + E)\).
<br />
Since each node represents an edge, it is easy to convert an adjacency representation graph to a <b>weighted graph</b>. A weighted graph is a graph where each edge has an associated weight. So the weight of (u, v) edge can be stored in the node-v of u's list.
<br />
The adjacency list representation is very robust and can represent various types of graph variants.
<img src="./imgs/IMG_20230928_132750.jpg" alt="IMG_20230928_132750.jpg" />
</p>
</div>
</div>
<div id="outline-container-org0a3e49b" class="outline-4">
<h4 id="org0a3e49b"><span class="section-number-4">7.1.2.</span> Adjacency Matrix</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
We use a single matrix to represent the graph. The size of the matrix is \(\left( |V| \times |V| \right)\). When we make the matrix, all it's elements are zero, i.e the matrix is zero initialized.
<br />
<br />
If there is an edge between vertices (x , y), we show it by setting
<br />
matrix[x][y] = true <b><i>or</i></b> matrix[x][y] = 1
<br />
If there is not an edge between vertices (x , y), we set
<br />
matrix[x][y] = false <b><i>or</i></b> matrix [x][y] = 0
</p>
<ul class="org-ul">
<li>For undirected graphs, to show edge (u , v) we have to set both matrix[u][v] and matrix[v][u] to 1.</li>
<li>For directed graphs, to show edge (u , v) which goes from u to v, we only set matrix[u][v] to 1.</li>
</ul>

<p>
The space taken by adjacency matrix is \(\theta (V^2)\).
<br />
For undirected graphs, the matrix will be symmetrical along the diagonal, because matrix will be equal to it's own <b>transpose</b>. So we can save space by only storing half the matrix in memory.
<br />
<br />
When comparing asymptotic results, the adjacency list seems more efficient, but matrix has advantage of only storing 1 bit for each cell. So in denser graphs, the matrix may use less space.
<br />
<br />
We can store weighted graphs in adjacency matrix by storing the weights along with the edge information in matrix cells.
<img src="./imgs/IMG_20230928_132909.jpg" alt="IMG_20230928_132909.jpg" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgbcfe613" class="outline-3">
<h3 id="orgbcfe613"><span class="section-number-3">7.2.</span> Vertex and edge attributes</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Many times we have to store attributes with either vertices or edges or sometimes both. How this is differs by language. In notation, we will write it using a dot (.)
<br />
<br />
For example, the attribute x of  v will be denoted as v.x
<br />
Similarly, the attribute x of edge (u , v) will be denoted as (u , v).x
</p>
</div>
</div>
<div id="outline-container-org2343c63" class="outline-3">
<h3 id="org2343c63"><span class="section-number-3">7.3.</span> Density of graph</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Knowing the density of a graph can help us choose the way in which we represent our graph.
<br />
The formula for density of graph is
\[ \text{density} = \frac{\text{number of edges}}{\text{maximum possible edges}} \]
Maximum possible number of edges for a simple undirected graph is
\[ \frac{|V| \left( |V| - 1 \right)}{2} \]
Maximum possible number of edges for a simple directed graph is
\[ |V| \left( |V| - 1 \right) \]
Therefore, the density of a simple undirected graph will be
\[ \text{density (simple undirected)} = \frac{2|E|}{|V| \left( |V| - 1 \right)} \]
And density of simple directed directed graph will be
\[ \text{density (simple directed)} = \frac{|E|}{|V| \left( |V| - 1 \right)} \]
</p>

<p>
Therefore, maximum density for a graph is 1. The minimum density for a graph is 0.
<br />
Knowing this, we can say graph with low density is a sparse graph and graph with high density is a dense graph.
</p>
</div>
<div id="outline-container-org73a1cdd" class="outline-4">
<h4 id="org73a1cdd"><span class="section-number-4">7.3.1.</span> Which representation to use</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
For a quick approximation, when undirected graph and \(2|E|\) is close to \(|V|^2\), we say that graph is dense, else we say it is sparse.
<br />
Similarly, for directed graph when \(|E|\) is close to \(|V|^2\), we can say graph is dense, else it is sparse.
<br />
<br />
The list representation provides a more compact way to represent graph when the graph is <b>sparse</b>. Whereas matrix representation is better for <b>dense</b> graphs.
<br />
Another criteria is how algorithm will use the graph. If we want to traverse to neighbouring nodes, then list representation works well. If we want to quickly tell if there is an edge between two nodes, then matrix representation is better.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdb2a125" class="outline-3">
<h3 id="orgdb2a125"><span class="section-number-3">7.4.</span> Searching Graphs</h3>
<div class="outline-text-3" id="text-7-4">
<p>
Graph search (or graph traversal) algorithms are used to explore a graph to find nodes and edges. Vertices not connected by edges are not explored by such algorithms. These algorithms start at a source vertex and traverse as much of the connected graph as possible.
<br />
<br />
Searching graphs algorithm can also be used on trees, because trees are also graphs.
</p>
</div>
<div id="outline-container-orgba9fa64" class="outline-4">
<h4 id="orgba9fa64"><span class="section-number-4">7.4.1.</span> Breadth first search</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
BFS is one of the simplest algorithms for searching a graph and is used as an archetype for many other graph algorithms. This algorithm works well with the adjacency list representation.
<br />
<br />
In BFS, the nodes are explored based on their distance from the starting node. What we mean by distance between nodes is how many edges are in between the two nodes.
<br />
<br />
So in BFS, all nodes at distance 1 are explored first, then nodes at distance 2 are explored, then nodes at distance 3 and so on. That is, all nodes at distance \(k\) are explored before exploring nodes at distance \((k+1)\).
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00cbcb;">BFS</span>(<span style="color: #dcdc00; font-weight: bold;">graph_type</span> <span style="color: #e2e2e2;">graph</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">start</span>){
  <span style="color: #dcdc00; font-weight: bold;">queue_type</span> <span style="color: #e2e2e2;">queue</span>;
  start.explored = <span style="color: #3eca3e;">true</span>;
  queue.add(start);

  <span style="color: #c25959; font-weight: bold;">while</span>(queue.len != 0){
    <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">v</span> = queue.dequeue();
    <span style="color: #dcdc00; font-weight: bold;">node_list</span> <span style="color: #e2e2e2;">adjacency_list</span> = grap.adj_list(v);

    <span style="color: #c25959; font-weight: bold;">while</span>(adjacency_list != <span style="color: #3eca3e;">NULL</span>){
      <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">u</span> = adjacency_list.node;
      <span style="color: #c25959; font-weight: bold;">if</span>(u.explored == <span style="color: #3eca3e;">false</span>){
        u.explored = <span style="color: #3eca3e;">true</span>;
        queue.add(u);
      }
      adjacency_list = adjacency_list.next;
    }
  }
}
</pre>
</div>

<ul class="org-ul">
<li><b>Analysis</b></li>
</ul>
<p>
For an input graph \(G=(V,E)\), every node is enqued only once and hence, dequeued only once. The time taken to enqueue and dequeue a single node is \(\theta (1)\), then the time for \(|V|\) nodes is, \(\theta (V)\). Each node in adjacency list represents an edge, therefore the time taken to explore each node in adjacency lists is \(\theta (E)\). Therefore, the total time complexity is
\[ \text{Time complexity of BFS : } \theta(V + E) \]
</p>
</div>
</div>
<div id="outline-container-org135ed3e" class="outline-4">
<h4 id="org135ed3e"><span class="section-number-4">7.4.2.</span> Breadth-first trees for shortest path</h4>
<div class="outline-text-4" id="text-7-4-2">
<p>
For a simple graph, we may want to get the shortest path between two nodes. This can be done by making a Breadth-first tree.
<br />
<br />
When we are traversing nodes using BFS, we can create a breadth-first tree. To make this tree, we simply need to set parent of u in the inner while loop in the BFS algorithm to v. So our algorithm from earlier will become.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00cbcb;">BFS_shortest_path</span>(<span style="color: #dcdc00; font-weight: bold;">graph_type</span> <span style="color: #e2e2e2;">graph</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">start</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">end</span>){
  <span style="color: #dcdc00; font-weight: bold;">queue_type</span> <span style="color: #e2e2e2;">queue</span>;
  start.explored = <span style="color: #3eca3e;">true</span>;
  start.parent = <span style="color: #3eca3e;">NULL</span>; <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">the start node is root node of tree</span>
  queue.add(start);

  <span style="color: #c25959; font-weight: bold;">while</span>(queue.len != 0){
    <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">v</span> = queue.dequeue();
    <span style="color: #dcdc00; font-weight: bold;">node_list</span> <span style="color: #e2e2e2;">adjacency_list</span> = grap.adj_list(v);
    <span style="color: #c25959; font-weight: bold;">while</span>(adjacency_list != <span style="color: #3eca3e;">NULL</span>){
      <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">u</span> = adjacency_list.node;
      <span style="color: #c25959; font-weight: bold;">if</span>(u.explored == <span style="color: #3eca3e;">false</span>){
        u.explored = <span style="color: #3eca3e;">true</span>;
        u.parent = v; <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">the parent of u is v</span>
        queue.add(u);

        <span style="color: #c25959; font-weight: bold;">if</span>(u == end) <span style="color: #c25959; font-weight: bold;">return</span>; <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">if we found the end node,</span>
                             <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">we have the path to it.</span>
      }

      adjacency_list = adjacency_list.next;
    }
  }

  printf(<span style="color: #3eca3e;">"end node not in graph"</span>);
}
</pre>
</div>
<p>
In this tree, the path upwards from any given node to start node will be the shortest path to the start node.
<br />
Therefore, we can get the shortest path now as follows
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00cbcb;">print_shortest_path</span>(<span style="color: #dcdc00; font-weight: bold;">graph_type</span> <span style="color: #e2e2e2;">graph</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">start</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">end</span>){
  BFS_shortest_path(graph, start, end);
  <span style="color: #c25959; font-weight: bold;">while</span>(end != <span style="color: #3eca3e;">NULL</span>){
    print_node(end);
    end = end.parent;
  }
}
</pre>
</div>
<p>
This will print shortest path from end node to start node.
</p>
</div>
</div>
<div id="outline-container-orgca24b82" class="outline-4">
<h4 id="orgca24b82"><span class="section-number-4">7.4.3.</span> Depth first search</h4>
<div class="outline-text-4" id="text-7-4-3">
<p>
Unlike BFS, depth first search is more biased towards the farthest nodes of a graph. It follows a single path till it reaches the end of a path. After that, it back tracks to the last open path and follows that one. This process is repeated till all nodes are covered.
</p>

<p>
Implementation of DFS is very similar to BFS with two differences.
</p>
<ol class="org-ol">
<li>Rather than using a queue, we use a <b>stack</b>.</li>
<li>In BFS, the explored nodes are added to the queue, but in DFS unexplored nodes are added to the stack.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00cbcb;">DFS</span>(<span style="color: #dcdc00; font-weight: bold;">graph_type</span> <span style="color: #e2e2e2;">graph</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">start</span>){
  <span style="color: #dcdc00; font-weight: bold;">stack_type</span> <span style="color: #e2e2e2;">stack</span>;
  stack.push(start);

  <span style="color: #c25959; font-weight: bold;">while</span>(stack.len != 0){
    <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">v</span> = stack.pop();

    <span style="color: #c25959; font-weight: bold;">if</span>(v.discovered == <span style="color: #3eca3e;">false</span>){
      <span style="color: #3eca3e;">/* </span><span style="color: #3eca3e;">after discovering is where we work on the node</span><span style="color: #3eca3e;"> */</span>
      v.discovered = <span style="color: #3eca3e;">true</span>;

      <span style="color: #dcdc00; font-weight: bold;">node_list</span> <span style="color: #e2e2e2;">adjacency_list</span> = graph.adj_list(start);
      <span style="color: #c25959; font-weight: bold;">while</span>(adjacency_list != <span style="color: #3eca3e;">NULL</span>){
        stack.push(adjacency_list.node);
        adjacency_list = adjacency_list.next;
      }
    }
  }
}
</pre>
</div>

<p>
Another way to implement DFS is recursively.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00cbcb;">DFS</span>(<span style="color: #dcdc00; font-weight: bold;">graph_type</span> <span style="color: #e2e2e2;">graph</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">node</span>){
  <span style="color: #3eca3e;">/* </span><span style="color: #3eca3e;">Work on node here</span><span style="color: #3eca3e;"> */</span>
  node.discovered = <span style="color: #3eca3e;">true</span>;
  <span style="color: #dcdc00; font-weight: bold;">node_list</span> <span style="color: #e2e2e2;">adjacency_list</span> = graph.adj_list(node);

  <span style="color: #c25959; font-weight: bold;">while</span>(adjacency_list != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">u</span> = adjacency_list.node;
    <span style="color: #c25959; font-weight: bold;">if</span>(u.discovered == <span style="color: #3eca3e;">false</span>)
      DFS(graph, u);
    adjacency_list = adjacency_list.next;
  }

}
</pre>
</div>

<p>
The difference between recursive and iterative version of DFS is that, recursive will choose the path of first neighbour in the adjacency list, whereas the iterative will choose the path of last neighbour in the adjacency list.
</p>

<ul class="org-ul">
<li><b>Analysis</b></li>
</ul>
<p>
For an input graph \(G=(V,E)\), the time complexity for Depth first search is \(\theta (V + E)\), i.e, it is the same of breadth first search. The reasoning for this is the same as before, all nodes are pushed and popped from stack only once, giving use time complexity of \(\theta (V)\). We go through all the adjacency lists only once giving time complexity \(\theta (E)\). Thus adding the two will give us
\[ \text{Time complexity of DFS : } \theta (V + E) \]
</p>
</div>
</div>

<div id="outline-container-org08e97e1" class="outline-4">
<h4 id="org08e97e1"><span class="section-number-4">7.4.4.</span> Properties of DFS</h4>
<div class="outline-text-4" id="text-7-4-4">
<p>
DFS is very useful to <b><i>understand the structure of a graph</i></b>. To study the structure of a graph using DFS, we will get two attributes of each node using DFS. We suppose that each step in traversal takes a unit of time.
</p>
<ul class="org-ul">
<li><b>Discovery time</b> : The time when we first discovered the node. We will set this at the time we push node to stack. We will denote it as node.d</li>
<li><b>Finishing time</b> : The time when we explored the node. We will set this when we pop the node and explore it. We will denote it as node.f</li>
</ul>
<p>
So our funtion will become
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">call with time = 0</span>
<span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">or whatever inital time is</span>
<span style="color: #00cbcb;">DFS</span>(<span style="color: #dcdc00; font-weight: bold;">graph_type</span> <span style="color: #e2e2e2;">graph</span>, <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">node</span>, <span style="color: #dcdc00; font-weight: bold;">size_t</span> <span style="color: #e2e2e2;">time</span>){
  node.discovered = <span style="color: #3eca3e;">true</span>;

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">update time on node discovery</span>
  time = time + 1;
  node.d = time;

  <span style="color: #dcdc00; font-weight: bold;">node_list</span> <span style="color: #e2e2e2;">adjacency_list</span> = graph.adj_list(node);
  <span style="color: #c25959; font-weight: bold;">while</span>(adjacency_list != <span style="color: #3eca3e;">NULL</span>){
    <span style="color: #dcdc00; font-weight: bold;">node_type</span> <span style="color: #e2e2e2;">u</span> = adjacency_list.node;
    <span style="color: #c25959; font-weight: bold;">if</span>(u.discovered == <span style="color: #3eca3e;">false</span>)
      DFS(graph, u, time);
    adjacency_list = adjacency_list.next;
  }

  <span style="color: #3eca3e;">// </span><span style="color: #3eca3e;">update time on node finished</span>
  time = time + 1;
  node.f = time;
}
</pre>
</div>

<p>
This algorithm will give all nodes the (node.d) and (node.f) attribute. <b>Similar to BFS, we can create a tree from DFS.</b> Having knowledge of these attributes can tell us properites of this DFS tree.
</p>
</div>

<div id="outline-container-org6623c5a" class="outline-5">
<h5 id="org6623c5a"><span class="section-number-5">7.4.4.1.</span> Parenthesis theorem</h5>
<div class="outline-text-5" id="text-7-4-4-1">
<p>
The paranthesis theorem is used to find relationship between two nodes in the <b>Depth First Search Tree</b>.
<br />
For any two given nodes \(x\) and \(y\).
</p>
<ul class="org-ul">
<li>If range \([x.d, x.f]\) is completely within \([y.d, y.f]\), then \(x\) is a descendant of \(y\).</li>
<li>If range \([x.d, x.f]\) and \([y.d, y.f]\) are completely disjoint, then neither is descendant or ancestor of another.</li>
</ul>
<p>
So if node, \(y\) is a proper descendant of node \(x\) in the depth first tree, then
\[ \text{x is ancestor of y} : x.d < y.d < y.f < x.f \]
</p>
</div>
</div>
<div id="outline-container-org37b14f5" class="outline-5">
<h5 id="org37b14f5"><span class="section-number-5">7.4.4.2.</span> White path theorem</h5>
<div class="outline-text-5" id="text-7-4-4-2">
<p>
If \(y\) is a descendant of \(x\) in graph G, then at time \(t = x.d\), the path from \(u\) to \(v\) was undiscovered.
</p>

<p>
That is, all the nodes in path from \(x\) to \(y\) were undiscovered. Undiscovered nodes are shown by white vertices in visual representations of DFS, therfore this theorem was named white path theorem.
</p>
</div>
</div>
<div id="outline-container-org55b5048" class="outline-5">
<h5 id="org55b5048"><span class="section-number-5">7.4.4.3.</span> Classification of edges</h5>
<div class="outline-text-5" id="text-7-4-4-3">
<p>
We can arrange the connected nodes of a graph into the form of a Depth-first tree. When the graph is arranged in this way, the edges can be classified into four types
</p>
<ol class="org-ol">
<li>Tree edge : The edges of graph which become the edges of the depth-first tree.</li>
<li>Back edge : The edges of graph which point from a descendant node to an ancestor node of depth-first tree. They are called back edge because they point backwards to the root of the tree oppsite to all tree edges.</li>
<li>Forward edge : The edges of graph which point from a point from an ancestor node to a descendant node.</li>
<li>Cross edge : An edge of graph which points to two different nodes</li>
</ol>
<p>
The back edge, forward edge and cross edge are not a part of the depth-first tree but a part of the original graph.
</p>
<ul class="org-ul">
<li>In an <b>undirected graph</b> G, every edge is either a <b>tree edge or a back edge</b>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1d5efc4" class="outline-4">
<h4 id="org1d5efc4"><span class="section-number-4">7.4.5.</span> Depth-first and Breadth-first Forests</h4>
<div class="outline-text-4" id="text-7-4-5">
<p>
In directed graphs, the depth-first and breadth-first algorithms <b>can't traverse to nodes which are not connected by a directed edge</b>. This can leave parts of graph not mapped by a single tree.
</p>

<p>
These tree's can help us better understand the graph and get properties of nodes, so we can't leave them when converting a graph to tree.
<br />
To solve this, we have <i><b>collection of trees for the graph</b></i>. This collection of trees will cover all the nodes of the graph and is called a <b>forest</b>. The forest of graph \(G\) is represented by \(G_{\pi}\).
</p>

<p>
Thus when using DFS or BFS on a graph, we store this collection of trees i.e, forests so that we can get properties of all the nodes.
</p>

<ul class="org-ul">
<li><b>NOTE</b> : When making a depth-first forest, we <b>don't reset the the time</b> when going from one tree to another. So if finishing time of for root of a tree is \(t\), the discovery time of root node of next tree will be \((t+1)\).</li>
</ul>
</div>
</div>
<div id="outline-container-org47a752d" class="outline-4">
<h4 id="org47a752d"><span class="section-number-4">7.4.6.</span> Topological sort using DFS</h4>
<div class="outline-text-4" id="text-7-4-6">
<p>
Topological sorting can only be done on <b>directed acyclic graphs</b>. A topological sort is a linear ordering of the nodes of a directed acyclic graph (dag). It is ordering the nodes such that all the <b>the edges point right</b>.
</p>

<p>
Topological sorting is used on <b>precedence graphs</b> to tell which node will have higher precedence.
</p>

<p>
To topologically sort, we first call DFS to calculate the the finishing time for all the nodes in graph and form a depth-first forest. Then, we can just sort the finishing times of the nodes in descending order.
</p>

<p>
TODO : Add image to show process of topological sorting
</p>

<ul class="org-ul">
<li>A directed graph \(G\) is <b>acyclic if and only if</b> the depth-first forest has <b>no back edges</b>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf9dd9a8" class="outline-3">
<h3 id="orgf9dd9a8"><span class="section-number-3">7.5.</span> Strongly connected components</h3>
<div class="outline-text-3" id="text-7-5">
<p>
If we can traverse from a node \(x\) to node \(y\) in a directed graph, we show it as \(x \rightsquigarrow y\).
</p>

<ul class="org-ul">
<li>A pair of nodes \(x\) and \(y\) is called  if \(x \rightsquigarrow y\) and \(y \rightsquigarrow x\)</li>
<li>A graph is said to be strongly connected if all pairs of nodes are strongly connected in the graph.</li>
<li>If a graph is not strongly connected, we can divide the graph into subgraphs made from neighbouring nodes which are strongly connected. These subgraphs are called <b>strongly connected componnents</b>.</li>
</ul>

<p>
Example, the dotted regions are the strongly connected components (SCC) of the graph.
</p>


<div id="org1f17d88" class="figure">
<p><img src="./imgs/strongly-connected-component.svg" alt="strongly-connected-component.svg" class="org-svg" />
</p>
</div>
</div>

<div id="outline-container-org18101bf" class="outline-4">
<h4 id="org18101bf"><span class="section-number-4">7.5.1.</span> Finding strongly connected components</h4>
<div class="outline-text-4" id="text-7-5-1">
<p>
We can find the strongly connected components of a graph \(G\) using DFS. The algorithm is called Kosaraju's algorithm.
</p>

<p>
For this algorithm, we also need the transpose of graph \(G\). The transpose of graph \(G\) is denoted by \(G^T\) and is the graph with the direction of all the edges flipped. So all edges from \(x\) to \(y\) in \(G\), will go from \(y\) to \(x\) in \(G^T\).
</p>

<p>
The algorithm uses the property that transpose of a graph will have the same SCC's as the original graph.
</p>

<p>
The algorithm works as follows
</p>
<ul class="org-ul">
<li><b>Step 1</b> : Perform DFS on the tree to compute the finishing time of all vertices. When a node finishes, push it to a stack.</li>
<li><b>Step 2</b> : Find the transpose of the input graph. The transpose of graph is graph with same vertices, but the edges are flipped.</li>
<li><b>Step 3</b> : Pop a node from stack and apply DFS on it. All nodes that will be traversed by the DFS will be a part of an SCC. After the first SCC is found, begin popping nodes from stack till we get an undiscovered node. Then apply DFS on the undiscovered node to get the next SCC. Repeat this process till the stack is empty.</li>
</ul>
<p>
Example, consider the graph
</p>
<ul class="org-ul">
<li>Step 1 : we start DFS at node \(1\), push nodes to a stack when they are finished</li>
<li>Step 2 : Find transpose of the graph</li>
<li>Step 3 : pop node from stack till we find a node which is undiscovered, then apply DFS to it. In our example, first node is \(1\)</li>
</ul>

<p>
TODO : Add images for this
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: .</p>
<p class="author">Author: Anmol Nawani</p>
<p class="date">Created: 2023-10-02 Mon 13:49</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>