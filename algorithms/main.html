<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-19 Mon 18:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algorithms</title>
<meta name="author" content="Anmol Nawani" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" href="src/org2.css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Algorithms</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org68dab69">1. Data structure and Algorithm</a></li>
<li><a href="#orgb8c2042">2. Characteristics of Algorithms</a></li>
<li><a href="#org413263b">3. Behaviour of algorithm</a>
<ul>
<li><a href="#orgd774b2e">3.1. Best, Worst and Average Cases</a></li>
<li><a href="#org98b15b6">3.2. Bounds of algorithm</a></li>
</ul>
</li>
<li><a href="#org18efd2b">4. Asymptotic Notations</a>
<ul>
<li><a href="#org6214e73">4.1. Big-Oh Notation [O]</a></li>
<li><a href="#org1e4b16c">4.2. Omega Notation [ \(\Omega\) ]</a></li>
<li><a href="#org69bcf0b">4.3. Theta Notation [ \(\theta\) ]</a></li>
<li><a href="#org03912a4">4.4. Little-Oh Notation [o]</a></li>
<li><a href="#org9b90f97">4.5. Little-Omega Notation [ \(\omega\) ]</a></li>
</ul>
</li>
<li><a href="#org6681d57">5. Comparing Growth rate of funtions</a>
<ul>
<li><a href="#org86c400b">5.1. Applying limit</a></li>
<li><a href="#org72d0d77">5.2. Using logarithm</a></li>
<li><a href="#org9739844">5.3. Common funtions</a></li>
</ul>
</li>
<li><a href="#org6ef4f2c">6. Properties of Asymptotic Notations</a>
<ul>
<li><a href="#org1851289">6.1. Big-Oh</a></li>
<li><a href="#org7cfb6da">6.2. Properties</a></li>
</ul>
</li>
<li><a href="#org62423be">7. Calculating time complexity of algorithm</a>
<ul>
<li><a href="#orgea84022">7.1. Sequential instructions</a></li>
<li><a href="#orgbb1f18f">7.2. Iterative instructions</a></li>
<li><a href="#orgaa30c5a">7.3. An example for time complexities of nested loops</a></li>
</ul>
</li>
<li><a href="#org32f6302">8. Time complexity of recursive instructions</a>
<ul>
<li><a href="#orgcd8d36e">8.1. Time complexity in recursive form</a></li>
</ul>
</li>
<li><a href="#org28b4f48">9. Solving Recursive time complexities</a>
<ul>
<li><a href="#org40af1e2">9.1. Iterative method</a></li>
<li><a href="#orga41a6e4">9.2. Master Theorem for Subtract recurrences</a></li>
<li><a href="#org40498ed">9.3. Master Theorem for divide and conquer recurrences</a></li>
</ul>
</li>
<li><a href="#org8cf5427">10. Square root recurrence relations</a>
<ul>
<li><a href="#orgabf8feb">10.1. Iterative method</a></li>
<li><a href="#orge522419">10.2. Master Theorem for square root recurrence relations</a></li>
</ul>
</li>
<li><a href="#org43cee32">11. Extended Master's theorem for time complexity of recursive algorithms</a>
<ul>
<li><a href="#org0d5b6b5">11.1. For (k = -1)</a></li>
<li><a href="#org8efb0ed">11.2. For (k &lt; -1)</a></li>
</ul>
</li>
<li><a href="#orga563c9c">12. Tree method for time complexity of recursive algorithms</a>
<ul>
<li><a href="#org032d30c">12.1. Avoiding tree method</a></li>
</ul>
</li>
<li><a href="#org8e2aeab">13. Space complexity</a>
<ul>
<li><a href="#orga190f97">13.1. Auxiliary space complexity</a></li>
</ul>
</li>
<li><a href="#org4023f51">14. Calculating auxiliary space complexity</a>
<ul>
<li><a href="#org0da95ae">14.1. Data Space used</a></li>
<li><a href="#org00753db">14.2. Code Execution space in recursive algorithm</a></li>
</ul>
</li>
<li><a href="#org341a509">15. Divide and Conquer algorithms</a></li>
<li><a href="#org5967669">16. Searching for element in array</a>
<ul>
<li><a href="#org5d68a01">16.1. Straight forward approach for searching (<b>Linear Search</b>)</a></li>
<li><a href="#orgd8aa317">16.2. Divide and conquer approach (<b>Binary search</b>)</a></li>
</ul>
</li>
<li><a href="#org803348c">17. Max and Min element from array</a>
<ul>
<li><a href="#orga770d72">17.1. Straightforward approach</a></li>
<li><a href="#orgf75278d">17.2. Divide and conquer approach</a></li>
<li><a href="#org4bc7b9b">17.3. Efficient single loop approach (Increment by 2)</a></li>
</ul>
</li>
<li><a href="#orgfb9c049">18. Square matrix multiplication</a>
<ul>
<li><a href="#org79f7ead">18.1. Straight forward method</a></li>
<li><a href="#org6298e2e">18.2. Divide and conquer approach</a></li>
<li><a href="#orga332175">18.3. Strassen's algorithm</a></li>
</ul>
</li>
<li><a href="#org13d9d6a">19. Sorting algorithms</a>
<ul>
<li><a href="#org5886e84">19.1. In place vs out place sorting algorithm</a></li>
</ul>
</li>
<li><a href="#org52596bc">20. Bubble sort</a></li>
<li><a href="#org330cbf9">21. Selection sort</a>
<ul>
<li><a href="#orgb3c4020">21.1. Time complexity</a></li>
</ul>
</li>
<li><a href="#orgc7bf85b">22. Insertion sort</a>
<ul>
<li><a href="#org83561b7">22.1. Time complexity</a></li>
</ul>
</li>
<li><a href="#org5f36642">23. Inversion in array</a>
<ul>
<li><a href="#orgd81ee8c">23.1. Relation between time complexity of insertion sort and inversion</a></li>
</ul>
</li>
<li><a href="#org6311a99">24. Quick sort</a>
<ul>
<li><a href="#org26e288f">24.1. Lomuto partition</a></li>
<li><a href="#org9642c8c">24.2. Time complexity of quicksort</a></li>
<li><a href="#orgc63f850">24.3. Number of comparisions</a></li>
</ul>
</li>
<li><a href="#orgd776ee7">25. Merging two sorted arrays (2-Way Merge)</a></li>
<li><a href="#orgd053503">26. Merging k sorted arrays (k-way merge)</a></li>
<li><a href="#org7ea9774">27. Merge sort</a>
<ul>
<li><a href="#orgfdf7002">27.1. Time complexity</a></li>
<li><a href="#orgf1bbcf5">27.2. Space complexity</a></li>
</ul>
</li>
<li><a href="#org8b1d6aa">28. Stable and unstable sorting algorithms</a></li>
<li><a href="#orgd73bfa5">29. Non-comparitive sorting algorithms</a>
<ul>
<li><a href="#org5319cd3">29.1. Counting sort</a></li>
<li><a href="#org062dedd">29.2. Radix sort</a></li>
<li><a href="#orgfd9873e">29.3. Bucket sort</a>
<ul>
<li><a href="#org721cbac">29.3.1. Time complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1f7dc44">30. Dynamic Programming</a>
<ul>
<li><a href="#org70d5ed0">30.1. Use and steps of dynamic programming</a></li>
<li><a href="#orgdf0c3a0">30.2. Rod cutting (Simple example for dynamic programming)</a>
<ul>
<li><a href="#org1f49263">30.2.1. Analyzing problem</a></li>
<li><a href="#orgf824955">30.2.2. Recursive solution</a>
<ul>
<li><a href="#org31f5eb2">30.2.2.1. Time complexity</a></li>
</ul>
</li>
<li><a href="#orgc6fbeb1">30.2.3. Dynamic Programming Solutions</a></li>
<li><a href="#orgcc9a5d5">30.2.4. Top Down Memoized Solution</a></li>
<li><a href="#orgb5f340b">30.2.5. Bottom Up Solution</a></li>
<li><a href="#org79db5e8">30.2.6. Running time of Top Down and Bottom Up Solutions</a></li>
<li><a href="#orge6b222d">30.2.7. Reconstructing a solution</a></li>
</ul>
</li>
<li><a href="#org28378ca">30.3. Subproblem graph</a></li>
<li><a href="#orgf2ac9fb">30.4. Matrix-chain multiplication</a>
<ul>
<li><a href="#orga0eb72b">30.4.1. Counting number of paranthesis</a></li>
<li><a href="#org116b36c">30.4.2. Solution</a>
<ul>
<li><a href="#orga6831eb">30.4.2.1. Step 1 : Analyzing problem</a></li>
<li><a href="#org0414795">30.4.2.2. Step 2 : Creating recursive solution</a></li>
<li><a href="#orgea77a4a">30.4.2.3. Step 3 : Applying dynamic programming</a></li>
<li><a href="#orgc18f5b3">30.4.2.4. Step 4 : Constructing a solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfd5b008">30.5. Longest common subsequence</a>
<ul>
<li><a href="#org01b490d">30.5.1. Substring vs Subsequence</a></li>
<li><a href="#orgcbb32b7">30.5.2. Analyzing problem</a></li>
<li><a href="#org91f073b">30.5.3. Recursive solution</a></li>
<li><a href="#orgac9fa47">30.5.4. Applying Dynamic Programming</a></li>
<li><a href="#orgf19b0e3">30.5.5. Constructing solution</a>
<ul>
<li><a href="#org0bc97e7">30.5.5.1. Storing solution in top-down</a></li>
<li><a href="#org299ed7c">30.5.5.2. Storing solution in bottom-up</a></li>
<li><a href="#orge9e660c">30.5.5.3. Printing solution</a></li>
</ul>
</li>
<li><a href="#org133c533">30.5.6. More compact way to store solution</a></li>
</ul>
</li>
<li><a href="#org90519ec">30.6. 0/1 knapsack problem</a>
<ul>
<li><a href="#org72fc2f4">30.6.1. Analyzing problem</a></li>
<li><a href="#org4638e29">30.6.2. Recursive solution</a></li>
<li><a href="#org0fef1f8">30.6.3. Applying Dynamic Programming</a></li>
<li><a href="#orgd4efe9d">30.6.4. Constructing solution</a></li>
</ul>
</li>
<li><a href="#org34d5e30">30.7. Floyd-Warshall algorithm</a>
<ul>
<li><a href="#orge27de99">30.7.1. Analyzing problem</a></li>
<li><a href="#org0495371">30.7.2. Recursive solution</a></li>
<li><a href="#org7ebbea7">30.7.3. Dynamic Programming</a></li>
<li><a href="#org27b856e">30.7.4. Reconstructing path (solution)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org58cd23e">31. Greedy algorithm</a>
<ul>
<li><a href="#orge471206">31.1. Activity-selection problem</a>
<ul>
<li><a href="#orgea92b37">31.1.1. Analyzing problem</a></li>
<li><a href="#org38ce40b">31.1.2. Greedy solution</a></li>
</ul>
</li>
<li><a href="#org34041b7">31.2. Job Scheduling with deadlines</a>
<ul>
<li><a href="#org04017fa">31.2.1. Greedy algorithm</a></li>
<li><a href="#orga6dbc32">31.2.2. Worked Example</a></li>
</ul>
</li>
<li><a href="#org84cd44c">31.3. Fractional knapsack</a>
<ul>
<li><a href="#org65a9d94">31.3.1. Greedy algorithm</a></li>
<li><a href="#org6c822f6">31.3.2. Worked example</a></li>
</ul>
</li>
<li><a href="#org85bcb56">31.4. Huffman coding</a>
<ul>
<li><a href="#org7f2e639">31.4.1. Encoding</a>
<ul>
<li><a href="#org00f7f9b">31.4.1.1. Building Huffman tree</a></li>
<li><a href="#org7ea8e3d">31.4.1.2. Traversing huffman tree to encode</a></li>
</ul>
</li>
<li><a href="#org8c3c882">31.4.2. Decoding</a></li>
</ul>
</li>
<li><a href="#org51153fa">31.5. Minimum spanning trees</a>
<ul>
<li><a href="#orgdf5b40d">31.5.1. Kruskal's algorithm</a>
<ul>
<li><a href="#org16bb0c2">31.5.1.1. Algorithm</a></li>
<li><a href="#orgd134609">31.5.1.2. Pseudocode</a></li>
</ul>
</li>
<li><a href="#org48e5cf3">31.5.2. Prim's algorithm</a>
<ul>
<li><a href="#orgee54df8">31.5.2.1. Algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org928de1f">31.6. Single source shortest path</a></li>
</ul>
</li>
<li><a href="#org6f04cc7">32. Backtracking</a>
<ul>
<li><a href="#org0cec865">32.1. How to backtrack</a></li>
<li><a href="#org608bd26">32.2. n-Queen problem</a></li>
<li><a href="#orgff549c0">32.3. Graph coloring problem</a></li>
<li><a href="#org5b9dcad">32.4. Hamiltonian Cylces</a></li>
<li><a href="#org6cdbea8">32.5. Sum-of-subsets</a></li>
</ul>
</li>
<li><a href="#orge2aa9ed">33. Branch and Bound</a>
<ul>
<li><a href="#orge2b53cc">33.1. Travelling Salesman Problem</a>
<ul>
<li><a href="#orgbf59b4f">33.1.1. Bounding function</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org68dab69" class="outline-2">
<h2 id="org68dab69"><span class="section-number-2">1.</span> Data structure and Algorithm</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>A <b>data structure</b> is a particular way of storing and organizing data. The purpose is to effectively access and modify data effictively.</li>
<li>A procedure to solve a specific problem is called <b>Algorithm</b>.</li>
</ul>

<p>
During programming we use data structures and algorithms that work on that data.
</p>
</div>
</div>

<div id="outline-container-orgb8c2042" class="outline-2">
<h2 id="orgb8c2042"><span class="section-number-2">2.</span> Characteristics of Algorithms</h2>
<div class="outline-text-2" id="text-2">
<p>
An algorithm has follwing characteristics.
</p>
<ul class="org-ul">
<li><b>Input</b> : Zero or more quantities are externally supplied to algorithm.</li>
<li><b>Output</b> : An algorithm should produce atleast one output.</li>
<li><b>Finiteness</b> : The algorithm should terminate after a finite number of steps. It should not run infinitely.</li>
<li><b>Definiteness</b> : Algorithm should be clear and unambiguous. All instructions of an algorithm must have a single meaning.</li>
<li><b>Effectiveness</b> : Algorithm must be made using very basic and simple operations that a computer can do.</li>
<li><b>Language Independance</b> : A algorithm is language independent and can be implemented in any programming language.</li>
</ul>
</div>
</div>

<div id="outline-container-org413263b" class="outline-2">
<h2 id="org413263b"><span class="section-number-2">3.</span> Behaviour of algorithm</h2>
<div class="outline-text-2" id="text-3">
<p>
The behaviour of an algorithm is the analysis of the algorithm on basis of <b>Time</b> and <b>Space</b>.
</p>
<ul class="org-ul">
<li><b>Time complexity</b> : Amount of time required to run the algorithm.</li>
<li><b>Space complexity</b> : Amount of space (memory) required to execute the algorithm.</li>
</ul>

<p>
The behaviour of algorithm can be used to compare two algorithms which solve the same problem.
<br />
The preference is traditionally/usually given to better time complexity. But we may need to give preference to better space complexity based on needs.
</p>
</div>

<div id="outline-container-orgd774b2e" class="outline-3">
<h3 id="orgd774b2e"><span class="section-number-3">3.1.</span> Best, Worst and Average Cases</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The input size tells us the size of the input given to algorithm. Based on the size of input, the time/storage usage of the algorithm changes. <b>Example</b>, an array with larger input size (more elements) will taken more time to sort.
</p>
<ul class="org-ul">
<li>Best Case : The lowest time/storage usage for the given input size.</li>
<li>Worst Case : The highest time/storage usage for the given input size.</li>
<li>Average Case : The average time/storage usage for the given input size.</li>
</ul>
</div>
</div>

<div id="outline-container-org98b15b6" class="outline-3">
<h3 id="org98b15b6"><span class="section-number-3">3.2.</span> Bounds of algorithm</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Since algorithms are finite, they have <b>bounded time</b> taken and <b>bounded space</b> taken. Bounded is short for boundries, so they have a minimum and maximum time/space taken. These bounds are upper bound and lower bound.
</p>
<ul class="org-ul">
<li>Upper Bound : The maximum amount of space/time taken by the algorithm is the upper bound. It is shown as a function of worst cases of time/storage usage over all the possible input sizes.</li>
<li>Lower Bound : The minimum amount of space/time taken by the algorithm is the lower bound. It is shown as a function of best cases of time/storage usage over all the possible input sizes.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org18efd2b" class="outline-2">
<h2 id="org18efd2b"><span class="section-number-2">4.</span> Asymptotic Notations</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org6214e73" class="outline-3">
<h3 id="org6214e73"><span class="section-number-3">4.1.</span> Big-Oh Notation [O]</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>The Big Oh notation is used to define the upper bound of an algorithm.</li>
<li>Given a non negative funtion f(n) and other non negative funtion g(n), we say that \(f(n) = O(g(n)\) if there exists a positive number \(n_0\) and a positive constant \(c\), such that \[ f(n) \le c.g(n) \ \ \forall n \ge n_0  \]</li>
<li>So if growth rate of g(n) is greater than or equal to growth rate of f(n), then \(f(n) = O(g(n))\).</li>
</ul>
</div>
</div>

<div id="outline-container-org1e4b16c" class="outline-3">
<h3 id="org1e4b16c"><span class="section-number-3">4.2.</span> Omega Notation [ \(\Omega\) ]</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>It is used to shown the lower bound of the algorithm.</li>
<li>For any positive integer \(n_0\) and a positive constant \(c\), we say that, \(f(n) = \Omega (g(n))\) if \[ f(n) \ge c.g(n) \ \ \forall n \ge n_0 \]</li>
<li>So growth rate of \(g(n)\) should be less than or equal to growth rate of \(f(n)\)</li>
</ul>

<p>
<b>Note</b> : If \(f(n) = O(g(n))\) then \(g(n) = \Omega (f(n))\)
</p>
</div>
</div>

<div id="outline-container-org69bcf0b" class="outline-3">
<h3 id="org69bcf0b"><span class="section-number-3">4.3.</span> Theta Notation [ \(\theta\) ]</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>If is used to provide the asymptotic <b>equal bound</b>.</li>
<li>\(f(n) = \theta (g(n))\) if there exists a positive integer \(n_0\) and a positive constants \(c_1\) and \(c_2\) such that \[ c_1 . g(n) \le f(n) \le c_2 . g(n) \ \ \forall n \ge n_0 \]</li>
<li>So the growth rate of \(f(n)\) and \(g(n)\) should be equal.</li>
</ul>

<p>
<b>Note</b> : So if \(f(n) = O(g(n))\) and \(f(n) = \Omega (g(n))\), then \(f(n) = \theta (g(n))\)
</p>
</div>
</div>

<div id="outline-container-org03912a4" class="outline-3">
<h3 id="org03912a4"><span class="section-number-3">4.4.</span> Little-Oh Notation [o]</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>The little o notation defines the strict upper bound of an algorithm.</li>
<li>We say that \(f(n) = o(g(n))\) if there exists positive integer \(n_0\) and positive constant \(c\) such that, \[ f(n) < c.g(n) \ \ \forall n \ge n_0 \]</li>
<li>Notice how condition is &lt;, rather than \(\le\) which is used in Big-Oh. So growth rate of \(g(n)\) is strictly  greater than that of \(f(n)\).</li>
</ul>
</div>
</div>

<div id="outline-container-org9b90f97" class="outline-3">
<h3 id="org9b90f97"><span class="section-number-3">4.5.</span> Little-Omega Notation [ \(\omega\) ]</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>The little omega notation defines the strict lower bound of an algorithm.</li>
<li>We say that \(f(n) = \omega (g(n))\) if there exists positive integer \(n_0\) and positive constant \(c\) such that, \[ f(n) > c.g(n) \ \ \forall n \ge n_0 \]</li>
<li>Notice how condition is &gt;, rather than \(\ge\) which is used in Big-Omega. So growth rate of \(g(n)\) is strictly less than that of \(f(n)\).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6681d57" class="outline-2">
<h2 id="org6681d57"><span class="section-number-2">5.</span> Comparing Growth rate of funtions</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org86c400b" class="outline-3">
<h3 id="org86c400b"><span class="section-number-3">5.1.</span> Applying limit</h3>
<div class="outline-text-3" id="text-5-1">
<p>
To compare two funtions \(f(n)\) and \(g(n)\). We can use limit
\[ \lim_{n\to\infty} \frac{f(n)}{g(n)} \]
</p>
<ul class="org-ul">
<li>If result is 0 then growth of \(g(n)\) &gt; growth of \(f(n)\)</li>
<li>If result is \(\infty\) then growth of \(g(n)\) &lt; growth of \(f(n)\)</li>
<li>If result is any finite number (constant), then growth of \(g(n)\) = growth of \(f(n)\)</li>
</ul>
<p>
<b>Note</b> : L'Hôpital's rule can be used in this limit.
</p>
</div>
</div>

<div id="outline-container-org72d0d77" class="outline-3">
<h3 id="org72d0d77"><span class="section-number-3">5.2.</span> Using logarithm</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Using logarithm can be useful to compare exponential functions. When comaparing functions \(f(n)\) and \(g(n)\), 
</p>
<ul class="org-ul">
<li>If growth of \(\log(f(n))\) is greater than growth of \(\log(g(n))\), then growth of \(f(n)\) is greater than growth of \(g(n)\)</li>
<li>If growth of \(\log(f(n))\) is less than growth of \(\log(g(n))\), then growth of \(f(n)\) is less than growth of \(g(n)\)</li>
<li>When using log for comparing growth, comaparing constants after applying log is also required. For example, if functions are \(2^n\) and \(3^n\), then their logs are \(n.log(2)\) and \(n.log(3)\). Since \(log(2) < log(3)\), the growth rate of \(3^n\) will be higher.</li>
<li>On equal growth after applying log, we can't decide which function grows faster.</li>
</ul>
</div>
</div>

<div id="outline-container-org9739844" class="outline-3">
<h3 id="org9739844"><span class="section-number-3">5.3.</span> Common funtions</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Commonly, growth rate in increasing order is
\[  c < c.log(log(n)) < c.log(n) < c.n < n.log(n) < c.n^2 < c.n^3 < c.n^4 ...  \]
\[ n^c < c^n < n! < n^n  \]
Where \(c\) is any constant.
</p>
</div>
</div>
</div>

<div id="outline-container-org6ef4f2c" class="outline-2">
<h2 id="org6ef4f2c"><span class="section-number-2">6.</span> Properties of Asymptotic Notations</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org1851289" class="outline-3">
<h3 id="org1851289"><span class="section-number-3">6.1.</span> Big-Oh</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li><b>Product</b> :  \[ Given\ f_1 = O(g_1)\ \ and\ f_2 = O(g_2) \implies f_1 f_2 = O(g_1 g_2) \] \[ Also\  f.O(g) = O(f g) \]</li>

<li><b>Sum</b> : For a sum of two functions, the big-oh can be represented with only with funcion having higer growth rate. \[ O(f_1 + f_2 + ... + f_i) = O(max\ growth\ rate(f_1, f_2, .... , f_i )) \]</li>

<li><b>Constants</b> : For a constant \(c\) \[ O(c.g(n)) = O(g(n)) \], this is because the constants don't effect the growth rate.</li>
</ul>
</div>
</div>

<div id="outline-container-org7cfb6da" class="outline-3">
<h3 id="org7cfb6da"><span class="section-number-3">6.2.</span> Properties</h3>
<div class="outline-text-3" id="text-6-2">

<div id="org06c7035" class="figure">
<p><img src="lectures/imgs/asymptotic-notations-properties.png" alt="asymptotic-notations-properties.png" />
</p>
</div>

<ul class="org-ul">
<li><b>Reflexive</b> :  \(f(n) = O(f(n)\) and \(f(n) = \Omega (f(n))\) and \(f(n) = \theta (f(n))\)</li>
<li><b>Symmetric</b> : If \(f(n) = \theta (g(n))\) then \(g(n) = \theta (f(n))\)</li>
<li><b>Transitive</b> : If \(f(n) = O(g(n))\) and \(g(n) = O(h(n))\) then \(f(n) = O(h(n))\)</li>
<li><b>Transpose</b> : If \(f(n) = O(g(n))\) then we can also conclude that \(g(n) = \Omega (f(n))\) so we say Big-Oh is transpose of Big-Omega and vice-versa.</li>
<li><b>Antisymmetric</b> : If \(f(n) = O(g(n))\) and \(g(n) = O(f(n))\) then we conclude that \(f(n) = g(n)\)</li>
<li><b>Asymmetric</b> : If \(f(n) = \omega (g(n))\) then we can conclude that \(g(n) \ne \omega (f(n))\)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org62423be" class="outline-2">
<h2 id="org62423be"><span class="section-number-2">7.</span> Calculating time complexity of algorithm</h2>
<div class="outline-text-2" id="text-7">
<p>
We will look at three types of situations
</p>
<ul class="org-ul">
<li>Sequential instructions</li>
<li>Iterative instructions</li>
<li>Recursive instructions</li>
</ul>
</div>

<div id="outline-container-orgea84022" class="outline-3">
<h3 id="orgea84022"><span class="section-number-3">7.1.</span> Sequential instructions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
A sequential set of instructions are instructions in a sequence without iterations and recursions. It is a simple block of instructions with no branches. A sequential set of instructions has <b>time complexity of O(1)</b>, i.e., it has <b>constant time complexity</b>.
</p>
</div>
</div>

<div id="outline-container-orgbb1f18f" class="outline-3">
<h3 id="orgbb1f18f"><span class="section-number-3">7.2.</span> Iterative instructions</h3>
<div class="outline-text-3" id="text-7-2">
<p>
A set of instructions in a loop. Iterative instructions can have different complexities based on how many iterations occurs depending on input size. 
</p>

<ul class="org-ul">
<li>For fixed number of iterations (number of iterations known at compile time i.e. independant of the input size), the time complexity is constant, O(1). Example for(int i = 0; i &lt; 100; i++) { &#x2026; } will always have 100 iterations, so constant time complexity.</li>
<li>For n number of iterations ( n is the input size ), the time complexity is O(n). Example, a loop for(int i = 0; i &lt; n; i++){ &#x2026; } will have n iterations where n is the input size, so complexity is O(n). Loop for(int i = 0; i &lt; n/2; i++){&#x2026;} also has time complexity O(n) because n/2 iterations are done by loop and 1/2 is constant thus not in big-oh notation.</li>
<li>For a loop like for(int i = 1; i &lt;= n; i = i*2){&#x2026;} the value of i is update as *=2, so the number of iterations will be \(log_2 (n)\). Therefore, the time complexity is \(O(log_2 (n))\).</li>
<li>For a loop like for(int i = n; i &gt; 1; i = i/2){&#x2026;} the value of i is update as *=2, so the number of iterations will be \(log_2 (n)\). Therefore, the time complexity is \(O(log_2 (n))\).</li>
</ul>

<p>
<b><span class="underline">Nested Loops</span></b>
<br />
</p>
<ul class="org-ul">
<li>If <b>inner loop iterator doesn't depend on outer loop</b>, the complexity of the inner loop is multiplied by the number of times outer loop runs to get the time complexity For example, suppose we have loop as</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; n; i++){
  ...
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; n; j *= 2){
    ...
  }
  ...
}
</pre>
</div>

<p>
Here, the outer loop will <b>n</b> times and the inner loop will run <b>log(n)</b> times. Therefore, the total number of time statements in the inner loop run is n.log(n) times.
Thus the time complexity is <b>O(n.log(n))</b>.
</p>

<ul class="org-ul">
<li>If <b>inner loop and outer loop are related</b>, then complexities have to be computed using sums. Example, we have loop</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt;= n; i++){
  ...
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt;= i; j++){
    ...
  }
  ...
}
</pre>
</div>

<p>
Here the outer loop will run <b>n</b> times, so i goes from <b>0 to n</b>. The number of times inner loop runs is j, which depends on <b>i</b>. 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Value of i</th>
<th scope="col" class="org-left">Number of times inner loop runs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">0</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">2</td>
<td class="org-left">2</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">n</td>
<td class="org-left">n</td>
</tr>
</tbody>
</table>

<p>
So the total number of times inner loop runs = \(1+2+3+....+n\)
<br />
total number of times inner loop runs = \(\frac{n.(n+1)}{2}\)
<br />
total number of times inner loop runs = \(\frac{n^2}{2} + \frac{n}{2}\)
<br />
<b><i>Therefore, time complexity is</i></b> \(O(\frac{n^2}{2} + \frac{n}{2}) = O(n^2)\)
<br />
<b>Another example,</b>
<br />
Suppose we have loop
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= n; i++){
  ...
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= i; j *= 2){
    ...
  }
  ...
}
</pre>
</div>

<p>
The outer loop will run n times with i from <b>1 to n</b>, and inner will run log(i) times.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Value of i</th>
<th scope="col" class="org-left">Number of times inner loop runs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">1</td>
<td class="org-left">log(1)</td>
</tr>

<tr>
<td class="org-left">2</td>
<td class="org-left">log(2)</td>
</tr>

<tr>
<td class="org-left">3</td>
<td class="org-left">log(3)</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">n</td>
<td class="org-left">log(n)</td>
</tr>
</tbody>
</table>

<p>
Thus, total number of times the inner loop runs is \(log(1) + log(2) + log(3) + ... + log(n)\).
<br />
total number of times inner loop runs = \(log(1.2.3...n)\)
<br />
total number of times inner loop runs = \(log(n!)\)
<br />
Using <b><i>Stirling's approximation</i></b>, we know that \(log(n!) = n.log(n) - n + 1\)
<br />
total number of times inner loop runs = \(n.log(n) - n + 1\)
<br />
Time complexity = \(O(n.log(n))\)
</p>
</div>
</div>

<div id="outline-container-orgaa30c5a" class="outline-3">
<h3 id="orgaa30c5a"><span class="section-number-3">7.3.</span> An example for time complexities of nested loops</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Suppose a loop,
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= n; <span style="color: #c18401;">i</span> *= 2){
  ...
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= i; j *= 2){
    ...
  }
  ...
}
</pre>
</div>
<p>
Here, outer loop will run <b>log(n)</b> times. Let's consider for some given n, it runs <b>k</b> times, i.e, let 
\[ k = log(n) \]
</p>

<p>
The inner loop will run <b>log(i)</b> times, so number of loops with changing values of i is
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Value of i</th>
<th scope="col" class="org-left">Number of times inner loop runs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">1</td>
<td class="org-left">log(1)</td>
</tr>

<tr>
<td class="org-left">2<sup>1</sup></td>
<td class="org-left">log(2)</td>
</tr>

<tr>
<td class="org-left">2<sup>2</sup></td>
<td class="org-left">2.log(2)</td>
</tr>

<tr>
<td class="org-left">2<sup>3</sup></td>
<td class="org-left">3.log(2)</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">2<sup>k-1</sup></td>
<td class="org-left">(k-1).log(2)</td>
</tr>
</tbody>
</table>

<p>
So the total number of times inner loop runs is \(log(1) + log(2) + 2.log(2) + 3.log(2) + ... + (k-1).log(2)\)
\[ \text{number of times inner loop runs} = log(1) + log(2).[1+2+3+...+(k-1)] \]
\[ \text{number of times inner loop runs} = log(1) + log(2). \frac{(k-1).k}{2} \]
\[ \text{number of times inner loop runs} = log(1) + log(2). \frac{k^2}{2} - \frac{k}{2} \]
Putting value \(k = log(n)\)
\[ \text{number of times inner loop runs} = log(1) + log(2). \frac{log^2(n)}{2} - \frac{log(n)}{2} \]
\[ \text{Time complexity} = O(log^2(n)) \]
</p>
</div>
</div>
</div>
<div id="outline-container-org32f6302" class="outline-2">
<h2 id="org32f6302"><span class="section-number-2">8.</span> Time complexity of recursive instructions</h2>
<div class="outline-text-2" id="text-8">
<p>
To get time complexity of recursive functions/calls, we first also show time complexity as recursive manner. 
</p>
</div>

<div id="outline-container-orgcd8d36e" class="outline-3">
<h3 id="orgcd8d36e"><span class="section-number-3">8.1.</span> Time complexity in recursive form</h3>
<div class="outline-text-3" id="text-8-1">
<p>
We first have to create a way to describe time complexity of recursive functions in form of an equation as,
\[ T(n) = ( \text{Recursive calls by the function} ) + ( \text{Time taken per call, i.e, the time taken except for recursive calls in the function} ) \]
</p>

<ul class="org-ul">
<li>Example, suppose we have a recursive function</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">fact</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a626a4;">if</span>(n == 0 || n == 1)
    <span style="color: #a626a4;">return</span> 1;
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> n * fact(n-1);
}
</pre>
</div>

<p>
in this example, the recursive call is fact(n-1), therefore the time complexity of recursive call is T(n-1) and the time complexity of function except for recursive call is constant (let's assume <b>c</b>). So the time complexity is 
\[ T(n) = T(n-1) + c \]
\[ T(1) = T(0) = C\ \text{where C is constant time} \]
</p>
<ul class="org-ul">
<li>Another example,</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">func</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a626a4;">if</span>(n == 0 || n == 1)
    <span style="color: #a626a4;">return</span> 1;
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> func(n - 1) * func(n - 2);
}
</pre>
</div>

<p>
Here, the recursive calls are func(n-1) and func(n-2), therefore time complexities of recursive calls is T(n-1) and T(n-2). The time complexity of function except the recursive calls is constant (let's assume <b>c</b>), so the time complexity is 
\[ T(n) = T(n-1) + T(n-2) + c \]
\[ T(1) = T(0) = C\ \text{where C is constant time} \]
</p>

<ul class="org-ul">
<li>Another example,</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">func</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span> = 0;
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; n; i++)
    r += i;

  <span style="color: #a626a4;">if</span>(n == 0 || n == 1)
    <span style="color: #a626a4;">return</span> r;
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> r * func(n - 1) * func(n - 2);
}
</pre>
</div>

<p>
Here, the recursive calls are func(n-1) and func(n-2), therefore time complexities of recursive calls is T(n-1) and T(n-2). The time complexity of function except the recursive calls is <b>&theta; (n)</b> because of the for loop, so the time complexity is 
</p>

<p>
\[ T(n) = T(n-1) + T(n-2) + n \]
\[ T(1) = T(0) = C\ \text{where C is constant time} \]
</p>
</div>
</div>
</div>

<div id="outline-container-org28b4f48" class="outline-2">
<h2 id="org28b4f48"><span class="section-number-2">9.</span> Solving Recursive time complexities</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org40af1e2" class="outline-3">
<h3 id="org40af1e2"><span class="section-number-3">9.1.</span> Iterative method</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>Take for example,</li>
</ul>
<p>
\[ T(1) = T(0) = C\ \text{where C is constant time} \]
\[ T(n) = T(n-1) + c \]
</p>

<p>
We can expand T(n-1).
\[ T(n) = [ T(n - 2) + c ] + c \]
\[ T(n) = T(n-2) + 2.c \]
Then we can expand T(n-2)
\[ T(n) =  [ T(n - 3) + c ] + 2.c \]
\[ T(n) =  T(n - 3) + 3.c \]
</p>

<p>
So, if we expand it k times, we will get
</p>

<p>
\[ T(n) = T(n - k) + k.c \]
Since we know this recursion <b>ends at T(1)</b>, let's put \(n-k=1\).
Therefore, \(k = n-1\).
\[ T(n) = T(1) + (n-1).c \]
</p>

<p>
Since T(1) = C
\[ T(n) = C + (n-1).c \]
So time complexity is,
\[ T(n) = O(n) \]
</p>

<ul class="org-ul">
<li>Another example,</li>
</ul>
<p>
\[ T(1) = C\ \text{where C is constant time} \]
\[ T(n) = T(n-1) + n \]
</p>

<p>
Expanding T(n-1),
\[ T(n) = [ T(n-2) + n - 1 ] + n \]
\[ T(n) = T(n-2) + 2.n - 1 \]
</p>

<p>
Expanding T(n-2),
\[ T(n) = [ T(n-3) + n - 2 ] + 2.n - 1 \]
\[ T(n) = T(n-3) + 3.n  - 1  - 2 \]
</p>

<p>
Expanding T(n-3),
\[ T(n) = [ T(n-4) + n - 3 ] + 3.n  - 1 - 2 \]
\[ T(n) = T(n-4) + 4.n  - 1 - 2 - 3  \]
</p>

<p>
So expanding till T(n-k)
\[ T(n) = T(n-k) + k.n - [ 1 + 2 + 3 + .... + k ] \]
\[ T(n) = T(n-k) + k.n - \frac{k.(k+1)}{2} \]
</p>

<p>
Putting \(n-k=1\). Therefore, \(k=n-1\).
\[ T(n) = T(1) + (n-1).n - \frac{(n-1).(n)}{2} \]
\[ T(n) = C + n^2 - n - \frac{n^2}{2} + \frac{n}{2} \]
</p>

<p>
Time complexity is
\[ T(n) = O(n^2) \]
</p>
</div>
</div>
<div id="outline-container-orga41a6e4" class="outline-3">
<h3 id="orga41a6e4"><span class="section-number-3">9.2.</span> Master Theorem for Subtract recurrences</h3>
<div class="outline-text-3" id="text-9-2">
<p>
For recurrence relation of type
</p>

<p>
\[ T(n) = c\ for\ n \le 1 \]
\[ T(n) = a.T(n-b) + f(n)\ for\ n > 1 \]
\[ \text{where for f(n) we can say, } f(n) = O(n^k) \]
\[ \text{where, a > 0, b > 0 and k}  \ge 0  \]
</p>

<ul class="org-ul">
<li>If a &lt; 1, then T(n) = O(n<sup>k</sup>)</li>
<li>If a = 1, then T(n) = O(n<sup>k+1</sup>)</li>
<li>If a &gt; 1, then T(n) = O(n<sup>k</sup> . a<sup>n/b</sup>)</li>
</ul>

<p>
Example, \[ T(n) = 3T(n-1) + n^2 \]
Here, f(n) = O(n<sup>2</sup>), therfore k = 2,
<br />
Also, a = 3 and b = 1
<br />
Since a &gt; 1, \(T(n) = O(n^2 . 3^n)\)
</p>
</div>
</div>

<div id="outline-container-org40498ed" class="outline-3">
<h3 id="org40498ed"><span class="section-number-3">9.3.</span> Master Theorem for divide and conquer recurrences</h3>
<div class="outline-text-3" id="text-9-3">
<p>
\[ T(n) = aT(n/b) + f(n).(log(n))^k \]
\[ \text{here, f(n) is a polynomial function} \]
\[ \text{and, a > 0, b > 0 and k } \ge 0 \]
We calculate a value \(n^{log_b a}\)
</p>
<ul class="org-ul">
<li>If \(\theta (f(n)) < \theta ( n^{log_b a} )\) then \(T(n) = \theta (n^{log_b a})\)</li>
<li>If \(\theta (f(n)) > \theta ( n^{log_b a} )\) then \(T(n) = \theta (f(n).(log(n))^k )\)</li>
<li>If \(\theta (f(n)) = \theta ( n^{log_b a} )\) then \(T(n) = \theta (f(n) . (log(n))^{k+1})\)</li>
</ul>
<p>
For the above comparision, we say higher growth rate is greater than slower growth rate. Eg, &theta; (n<sup>2</sup>) &gt; &theta; (n).
</p>

<p>
Example, calculating complexity for
\[ T(n) = T(n/2) + 1 \]
Here, f(n) = 1
<br />
Also, a = 1, b = 2 and k = 0.
<br />
Calculating n<sup>log<sub>b</sub> a</sup> = n<sup>log<sub>21</sub></sup> = n<sup>0</sup> = 1
<br />
Therfore, &theta; (f(n)) = &theta; (n<sup>log<sub>ba</sub></sup>)
<br />
So time complexity is 
\[ T(n) = \theta ( 1 . (log(n))^{0 + 1} ) \]
\[ T(n) = \theta (log(n)) \]
</p>

<p>
Another example, calculate complexity for
\[ T(n) = 2T(n/2) + nlog(n) \]
</p>

<p>
Here, f(n) = n
<br />
Also, a = 2, b = 2 and k = 1
<br />
Calculating n<sup>log<sub>ba</sub></sup> = n<sup>log<sub>22</sub></sup> = n
<br />
Therefore, &theta; (f(n)) = &theta; (n<sup>log<sub>ba</sub></sup>)
<br />
So time complexity is,
\[ T(n) = \theta ( n . (log(n))^{2}) \]
</p>
</div>
</div>
</div>

<div id="outline-container-org8cf5427" class="outline-2">
<h2 id="org8cf5427"><span class="section-number-2">10.</span> Square root recurrence relations</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-orgabf8feb" class="outline-3">
<h3 id="orgabf8feb"><span class="section-number-3">10.1.</span> Iterative method</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Example, 
\[ T(n) = T( \sqrt{n} ) + 1 \]
we can write this as,
\[ T(n) = T( n^{1/2}) + 1 \]
Now, we expand \(T( n^{1/2})\)
\[ T(n) = [ T(n^{1/4}) + 1 ] + 1 \]
\[ T(n) = T(n^{1/(2^2)}) + 1 + 1 \]
Expand, \(T(n^{1/4})\)
\[ T(n) = [ T(n^{1/8}) + 1 ] + 1 + 1 \]
\[ T(n) =  T(n^{1/(2^3)}) + 1  + 1 + 1 \]
</p>

<p>
Expanding <b>k</b> times,
\[ T(n) =  T(n^{1/(2^k)}) + 1  + 1 ... \text{k times } + 1 \]
\[ T(n) =  T(n^{1/(2^k)}) + k \]
</p>

<p>
Let's consider \(T(2)=C\) where C is constant.
<br />
Putting \(n^{1/(2^k)} = 2\)
\[ \frac{1}{2^k} log(n) = log(2) \]
\[ \frac{1}{2^k} = \frac{log(2)}{log(n)} \]
\[ 2^k = \frac{log(n)}{log(2)} \]
\[ 2^k = log_2n \]
\[ k = log(log(n)) \]
</p>

<p>
So putting <b>k</b> in time complexity equation,
\[ T(n) = T(2) + log(log(n)) \]
\[ T(n) = C + log(log(n)) \]
Time complexity is,
\[ T(n) = \theta (log(log(n))) \]
</p>
</div>
</div>

<div id="outline-container-orge522419" class="outline-3">
<h3 id="orge522419"><span class="section-number-3">10.2.</span> Master Theorem for square root recurrence relations</h3>
<div class="outline-text-3" id="text-10-2">
<p>
For recurrence relations with square root, we need to first convert the recurrance relation to the form with which we use master theorem. Example,
\[ T(n) = T( \sqrt{n} ) + 1 \]
Here, we need to convert \(T( \sqrt{n} )\) , we can do that by <b>substituting</b> 
\[ \text{Substitute } n = 2^m \]
\[ T(2^m) = T ( \sqrt{2^m} ) + 1 \]
\[ T(2^m) = T ( 2^{m/2} ) + 1 \]
</p>

<p>
Now, we need to consider a new function such that,
\[ \text{Let, } S(m) = T(2^m) \]
Thus our time recurrance relation will become,
\[ S(m) = S(m/2) + 1 \]
Now, we can apply the master's theorem.
<br />
Here, f(m) = 1
<br />
Also, a = 1, and b = 2 and k = 0
<br />
Calculating m<sup>log<sub>ba</sub></sup> = m<sup>log<sub>21</sub></sup> = m<sup>0</sup> = 1
<br />
Therefore, &theta; (f(m)) = &theta; ( m<sup>log<sub>ba</sub></sup> )
<br />
So by master's theorem,
\[ S(m) = \theta (1. (log(m))^{0+1} ) \]
\[ S(m) = \theta (log(m) ) \]
Now, putting back \(m = log(n)\)
\[ T(n) = \theta (log(log(n))) \]
Another example,
\[ T(n) = 2.T(\sqrt{n})+log(n) \]
Substituting \(n = 2^m\)
\[ T(2^m) = 2.T(\sqrt{2^m}) + log(2^m) \]
\[ T(2^m) = 2.T(2^{m/2}) + m \]
Consider a function \(S(m) = T(2^m)\)
\[ S(m) = 2.S(m/2) + m \]
Here, f(m) = m
<br />
Also, a = 2, b = 2 and k = 0
<br />
Calculating m<sup>log<sub>ba</sub></sup> = m<sup>log<sub>22</sub></sup> = 1
<br />
Therefore, &theta; (f(m)) &gt; &theta; (m<sup>log<sub>ba</sub></sup>)
<br />
Using master's theorem,
\[ S(m) = \theta (m.(log(m))^0 ) \]
\[ S(m) = \theta (m.1) \]
Putting value of m,
\[ T(n) = \theta (log(n)) \]
</p>
</div>
</div>
</div>

<div id="outline-container-org43cee32" class="outline-2">
<h2 id="org43cee32"><span class="section-number-2">11.</span> Extended Master's theorem for time complexity of recursive algorithms</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org0d5b6b5" class="outline-3">
<h3 id="org0d5b6b5"><span class="section-number-3">11.1.</span> For (k = -1)</h3>
<div class="outline-text-3" id="text-11-1">
<p>
\[ T(n) = aT(n/b) + f(n).(log(n))^{-1} \]
\[ \text{Here, } f(n) \text{ is a polynomial function} \]
\[ a > 0\ and\ b > 1 \]
</p>

<ul class="org-ul">
<li>If &theta; (f(n)) &lt; &theta; ( n<sup>log<sub>b</sub> a</sup> ) then, T(n) = &theta; (n<sup>log<sub>b</sub> a</sup>)</li>
<li>If &theta; (f(n)) &gt; &theta; ( n<sup>log<sub>b</sub> a</sup> ) then, T(n) = &theta; (f(n))</li>
<li>If &theta; (f(n)) &lt; &theta; ( n<sup>log<sub>b</sub> a</sup> ) then, T(n) = &theta; (f(n).log(log(n)))</li>
</ul>
</div>
</div>

<div id="outline-container-org8efb0ed" class="outline-3">
<h3 id="org8efb0ed"><span class="section-number-3">11.2.</span> For (k &lt; -1)</h3>
<div class="outline-text-3" id="text-11-2">
<p>
\[ T(n) = aT(n/b) + f(n).(log(n))^{k} \]
\[ \text{Here, } f(n) \text{ is a polynomial function} \]
\[ a > 0\ and\ b > 1\ and\ k < -1 \]
</p>

<ul class="org-ul">
<li>If &theta; (f(n)) &lt; &theta; ( n<sup>log<sub>b</sub> a</sup> ) then, T(n) = &theta; (n<sup>log<sub>b</sub> a</sup>)</li>
<li>If &theta; (f(n)) &gt; &theta; ( n<sup>log<sub>b</sub> a</sup> ) then, T(n) = &theta; (f(n))</li>
<li>If &theta; (f(n)) &lt; &theta; ( n<sup>log<sub>b</sub> a</sup> ) then, T(n) = &theta; (n<sup>log<sub>b</sub> a</sup>)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga563c9c" class="outline-2">
<h2 id="orga563c9c"><span class="section-number-2">12.</span> Tree method for time complexity of recursive algorithms</h2>
<div class="outline-text-2" id="text-12">
<p>
Tree method is used when there are multiple recursive calls in our recurrance relation. Example,
\[ T(n) = T(n/5) + T(4n/5) + f(n) \]
Here, one call is T(n/5) and another is T(4n/5). So we can't apply master's theorem. So we create a tree of recursive calls which is used to calculate time complexity.
The first node, i.e the root node is T(n) and the tree is formed by the child nodes being the calls made by the parent nodes. Example, let's consider the recurrance relation
\[ T(n) = T(n/5) + T(4n/5) + f(n) \]
</p>

<pre class="example">
      +-----T(n/5)
T(n)--+
      +-----T(4n/5)
</pre>

<p>
Since T(n) calls T(n/5) and  T(4n/5), the graph for that is shown as drawn above. Now using recurrance relation, we can say that T(n/5) will call T(n/5<sup>2</sup>) and T(4n/5<sup>2</sup>). Also, T(4n/5) will call T(4n/5<sup>2</sup>) and T(4<sup>2</sup> n/ 5<sup>2</sup>).
</p>

<pre class="example">
		    +--T(n/5^2)
      +-----T(n/5)--+
      +             +--T(4n/5^2)
T(n)--+
      +             +--T(4n/5^2)
      +-----T(4n/5)-+
		    +--T(4^2 n/5^2)
</pre>

<p>
Suppose we draw this graph for an unknown number of levels.
</p>

<pre class="example">
		    +--T(n/5^2)- - - - - - -  etc.
      +-----T(n/5)--+
      +             +--T(4n/5^2) - - - - - - - - - etc.
T(n)--+
      +             +--T(4n/5^2) - - - - - -  - - - etc.
      +-----T(4n/5)-+
		    +--T(4^2 n/5^2)- - - - - - etc.
</pre>

<p>
We will now replace T()'s  with the <b>cost of the call</b>. The cost of the call is <b>f(n)</b>, i.e, the time taken other than that caused by the recursive calls.
</p>

<pre class="example">
		    +--f(n/5^2)- - - - - - -  etc.
      +-----f(n/5)--+
      +             +--f(4n/5^2) - - - - - - - - - etc.
f(n)--+
      +             +--f(4n/5^2) - - - - - -  - - - etc.
      +-----f(4n/5)-+
		    +--f(4^2 n/5^2)- - - - - - etc.
</pre>

<p>
In our example, <b>let's assume f(n) = n</b>, therfore,
</p>

<pre class="example">
		  +--  n/5^2 - - - - - - -  etc.
    +-----  n/5 --+
    +             +-- 4n/5^2  - - - - - - - - - etc.
n --+
    +             +--  4n/5^2  - - - - - -  - - -etc.
    +-----  4n/5 -+
		  +--  4^2 n/5^2 - - - - - -  etc.
</pre>

<p>
Now we can get cost of each level.
</p>

<pre class="example">
			   +--  n/5^2 - - - - - - -  etc.
	     +-----  n/5 --+
	     +             +-- 4n/5^2  - - - - - - - - - etc.
	 n --+
	     +             +--  4n/5^2  - - - - - -  - - -etc.
	     +----- 4n/5 --+
			   +--  4^2 n/5^2 - - - - - -  etc.


Sum :    n         n/5         n/25                      
		  +4n/5       +4n/25
			      +4n/25
			      +16n/25
       .....      .....       ......
	 n          n           n
</pre>

<p>
Since sum on all levels is n, we can say that Total time taken is
\[ T(n) = \Sigma \ (cost\ of\ level_i) \]
</p>

<p>
Now we need to find the longest branch in the tree. If we follow the pattern of expanding tree in a sequence as shown, then the longest branch is <b>always on one of the extreme ends of the tree</b>. So for our example, if tree has <b>(k+1)</b> levels, then our branch is either (n/5<sup>k</sup>) of (4<sup>k</sup> n/5<sup>k</sup>). Consider the terminating condition is, \(T(a) = C\). Then we will calculate value of k by equating the longest branch as, 
\[ \frac{n}{5^k} = a \]
\[ k = log_5 (n/a) \]
Also,
\[ \frac{4^k n}{5^k} = a \]
\[ k = log_{5/4} n/a \]
</p>

<p>
So, we have two possible values of k, 
\[ k = log_{5/4}(n/a),\ log_5 (n/a) \]
</p>

<p>
Now, we can say that, 
\[ T(n) = \sum_{i=1}^{k+1} \ (cost\ of\ level_i) \]
Since in our example, cost of every level is <b>n</b>.
\[ T(n) = n.(k+1) \]
Putting values of k,
\[ T(n) = n.(log_{5/4}(n/a) + 1) \]
or
\[ T(n) = n.(log_{5}(n/a) + 1) \]
</p>

<p>
Of the two possible time complexities, we consider the one with higher growth rate in the big-oh notation.
</p>
</div>

<div id="outline-container-org032d30c" class="outline-3">
<h3 id="org032d30c"><span class="section-number-3">12.1.</span> Avoiding tree method</h3>
<div class="outline-text-3" id="text-12-1">
<p>
The tree method as mentioned is mainly used when we have multiple recursive calls with different factors. But when using the big-oh notation (O). We can avoid tree method in favour of the master's theorem by converting recursive call with smaller factor to larger. This works since big-oh calculates worst case. Let's take our previous example
\[ T(n) = T(n/5) + T(4n/5) + f(n) \]
Since T(n) is an increasing function. We can say that
\[ T(n/5) < T(4n/5)  \]
So we can replace smaller one and approximate our equation to,
\[ T(n) = T(4n/5) + T(4n/5) + f(n) \]
\[ T(n) = 2.T(4n/5) + f(n) \]
</p>

<p>
Now, our recurrance relation is in a form where we can apply the mater's theorem.
</p>
</div>
</div>
</div>

<div id="outline-container-org8e2aeab" class="outline-2">
<h2 id="org8e2aeab"><span class="section-number-2">13.</span> Space complexity</h2>
<div class="outline-text-2" id="text-13">
<p>
The amount of memory used by the algorithm to execute and produce the result for a given input size is space complexity. Similar to time complexity, when comparing two algorithms space complexity is usually represented as the growth rate of memory used with respect to input size. The space complexity includes
</p>
<ul class="org-ul">
<li><b>Input space</b> : The amount of memory used by the inputs to the algorithm.</li>
<li><b>Auxiliary space</b> : The amount of memory used during the execution of the algorithm, excluding the input space.</li>
</ul>

<p>
<b>NOTE</b> : <i>Space complexity by definition includes both input space and auxiliary space, but when comparing algorithms the input space is often ignored. This is because two algorithms that solve the same problem will have same input space based on input size (Example, when comparing two sorting algorithms, the input space will be same because both get a list as an input). So from this point on, refering to space complexity, we are actually talking about <b>Auxiliary Space Complexity</b>, which is space complexity but only considering the auxiliary space</i>.
</p>
</div>

<div id="outline-container-orga190f97" class="outline-3">
<h3 id="orga190f97"><span class="section-number-3">13.1.</span> Auxiliary space complexity</h3>
<div class="outline-text-3" id="text-13-1">
<p>
The space complexity when we disregard the input space is the auxiliary space complexity, so we basically treat algorithm as if it's input space is zero. Auxiliary space complexity is more useful when comparing algorithms because the algorithms which are working towards same result will have the same input space, Example, the sorting algorithms will all have the input space of the list, so it is not a metric we can use to compare algorithms. So from here, when we calculate space complexity, we are trying to calculate auxiliary space complexity and sometimes just refer to it as space complexity.
</p>
</div>
</div>
</div>

<div id="outline-container-org4023f51" class="outline-2">
<h2 id="org4023f51"><span class="section-number-2">14.</span> Calculating auxiliary space complexity</h2>
<div class="outline-text-2" id="text-14">
<p>
There are two parameters that affect space complexity,
</p>
<ul class="org-ul">
<li><b>Data space</b> : The memory taken by the variables in the algorithm. So allocating new memory during runtime of the algorithm is what forms the data space. The space which was allocated for the input space is not considered a part of the data space.</li>
<li><b>Code Execution Space</b> : The memory taken by the instructions themselves is called code execution space. Unless we have recursion, the code execution space remains constant since the instructions don't change during runtime of the algorithm. When using recursion, the instructions are loaded again and again in memory, thus increasing code execution space.</li>
</ul>
</div>

<div id="outline-container-org0da95ae" class="outline-3">
<h3 id="org0da95ae"><span class="section-number-3">14.1.</span> Data Space used</h3>
<div class="outline-text-3" id="text-14-1">
<p>
The data space used by the algorithm depends on what data structures it uses to solve the problem. Example,
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Input size of n</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">algorithms</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Creating an array of whose size depends on input size</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">data</span>[n];

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; n; i++){
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span> = data[i];
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Work on data</span>
  }
}
</pre>
</div>

<p>
Here, we create an array of size <b>n</b>, so the increase in allocated space increases with the input size. So the space complexity is, <b>\(\theta (n)\)</b>.
<br />
</p>
<ul class="org-ul">
<li>Another example,</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Input size of n</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">algorithms</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Creating a matrix sized n*n of whose size depends on input size</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">data</span>[n][n];

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; n; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; n; j++){
      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span> = data[i][j];
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Work on data</span>
    }
  }
}
</pre>
</div>

<p>
Here, we create a matrix of size <b>n*n</b>, so the increase in allocated space increases with the input size by \(n^2\). So the space complexity is, <b>\(\theta (n^2)\)</b>.
</p>

<ul class="org-ul">
<li>If we use a node based data structure like linked list or trees, then we can show space complexity as the number of nodes used by algorithm based on input size, (if all nodes are of equal size).</li>
<li>Space complexity of the hash map is considered <b>O(n)</b> where <b>n</b> is the number of entries in the hash map.</li>
</ul>
</div>
</div>

<div id="outline-container-org00753db" class="outline-3">
<h3 id="org00753db"><span class="section-number-3">14.2.</span> Code Execution space in recursive algorithm</h3>
<div class="outline-text-3" id="text-14-2">
<p>
When we use recursion, the function calls are stored in the stack. This means that code execution space will increase. A single function call has fixed (constant) space it takes in the memory. So to get space complexity, <b>we need to know how many function calls occur in the longest branch of the function call tree</b>.
</p>

<ul class="org-ul">
<li><b>NOTE</b> : Space complexity <b>only depends on the longest branch</b> of the function calls tree.</li>
<li><i><b>The tree is made the same way we make it in the tree method for calculating time complexity of recursive algorithms</b></i></li>
</ul>

<p>
This is because at any given time, the stack will store only a single branch.
</p>

<ul class="org-ul">
<li>Example,</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">func</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a626a4;">if</span>(n == 1 || n == 0)
    <span style="color: #a626a4;">return</span> 1;
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> n * func(n - 1);
}
</pre>
</div>

<p>
To calculate space complexity we can use the tree method. But rather than when calculating time complexity, we will count the number of function calls using the tree.
We will do this by drawing tree of what function calls will look like for given input size <b>n</b>.
<br />
The tree for <b>k+1</b> levels is,
</p>

<pre class="example">
func(n)--func(n-1)--func(n-2)--.....--func(n-k)
</pre>

<p>
This tree only has a single branch. To get the number of levels for a branch, we put the terminating condition at the extreme branches of the tree. Here, the terminating condition is func(1), therefore, we will put \(func(1) = func(n-k)\), i.e,
\[ 1 = n - k \]
\[ k + 1 = n \]
</p>

<p>
So the number of levels is \(n\). Therefore, space complexity is <b>\(\theta (n)\)</b>
</p>

<ul class="org-ul">
<li>Another example,</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">func</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a626a4;">if</span>(n/2 &lt;= 1)
    <span style="color: #a626a4;">return</span> n;
  func(n/2);
  func(n/2);
}
</pre>
</div>

<p>
Drawing the tree for <b>k+1</b> levels.
</p>
<pre class="example">
			  +--func(n/2^2)- - - - - - -  func(n/2^k)
	 +-----func(n/2)--+
	 +                +--func(n/2^2) - - - - - - - - - func(n/2^k)
func(n)--+
	 +               +--func(n/2^2) - - - - - -  - - - func(n/2^k)
	 +-----func(n/2)-+
			 +--func(n/2^2)- - - - - - func(n/2^k)
</pre>

<ul class="org-ul">
<li><i><b>As we know from the tree method, the two extreme branches of the tree will always be the longest ones.</b></i></li>
</ul>

<p>
Both the extreme branches have the same call which here is func(n/2<sup>k</sup>). To get the number of levels for a branch, we put the terminating condition at the extreme branches of the tree. Here, the terminating condition is func(2), therefore, we will put \(func(2) = func(n/2^k)\), i.e,
\[ 2 = \frac{n}{2^k} \]
\[ k + 1 = log_2n \]
Number of levels is \(log_2n\). Therefore, space complexity is <b>\(\theta (log_2n)\).</b>
</p>
</div>
</div>
</div>
<div id="outline-container-org341a509" class="outline-2">
<h2 id="org341a509"><span class="section-number-2">15.</span> Divide and Conquer algorithms</h2>
<div class="outline-text-2" id="text-15">
<p>
Divide and conquer is a problem solving strategy. In divide and conquer algorithms, we solve problem recursively applying three steps :
</p>
<ul class="org-ul">
<li><b>Divide</b> : Problem is divided into smaller problems that are instances of same problem.</li>
<li><b>Conquer</b> : If subproblems are large, divide and solve them recursivly. If subproblem is small enough then solve it in a straightforward method</li>
<li><b>Combine</b> : combine the solutions of subproblems into the solution for the original problem.</li>
</ul>

<p>
<b>Example</b>,
</p>
<ol class="org-ol">
<li>Binary search</li>
<li>Quick sort</li>
<li>Merge sort</li>
<li>Strassen's matrix multiplication</li>
</ol>
</div>
</div>

<div id="outline-container-org5967669" class="outline-2">
<h2 id="org5967669"><span class="section-number-2">16.</span> Searching for element in array</h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-org5d68a01" class="outline-3">
<h3 id="org5d68a01"><span class="section-number-3">16.1.</span> Straight forward approach for searching (<b>Linear Search</b>)</h3>
<div class="outline-text-3" id="text-16-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">linear_search</span>(<span style="color: #c18401;">int</span> *<span style="color: #8b4513;">array</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span>){
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; n; i++){
    <span style="color: #a626a4;">if</span>(array[i] == x){
      printf(<span style="color: #50a14f;">"Found at index : %d"</span>, i);
      <span style="color: #a626a4;">return</span> i;
    }
  }
  <span style="color: #a626a4;">return</span> -1;
}
</pre>
</div>

<p>
Recursive approach
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">call this function with index = 0</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">linear_search</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">item</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">index</span>){
  <span style="color: #a626a4;">if</span>( index &gt;= len(array) )
    <span style="color: #a626a4;">return</span> -1;
  <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (array[index] == item)
    <span style="color: #a626a4;">return</span> index;
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> linear_search(array, item, index + 1);
}
</pre>
</div>

<p>
<b>Recursive time complexity</b> : \(T(n) = T(n-1) + 1\)
</p>

<ul class="org-ul">
<li><b>Best Case</b> : The element to search is the first element of the array. So we need to do a single comparision. Therefore, time complexity will be constant <b>O(1)</b>.</li>
</ul>
<p>
<br />
</p>
<ul class="org-ul">
<li><b>Worst Case</b> : The element to search is the last element of the array. So we need to do <b>n</b> comparisions for the array of size n. Therefore, time complexity is <b>O(n)</b>.</li>
</ul>
<p>
<br />
</p>
<ul class="org-ul">
<li><b>Average Case</b> : For calculating the average case, we need to consider the average number of comparisions done over all possible cases.</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Position of element to search (x)</th>
<th scope="col" class="org-left">Number of comparisions done</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">0</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">2</td>
</tr>

<tr>
<td class="org-left">2</td>
<td class="org-left">3</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">.</td>
<td class="org-left">.</td>
</tr>

<tr>
<td class="org-left">n-1</td>
<td class="org-left">n</td>
</tr>

<tr>
<td class="org-left">&#x2026;&#x2026;&#x2026;&#x2026;&#x2026;&#x2026;..</td>
<td class="org-left">&#x2026;&#x2026;&#x2026;&#x2026;&#x2026;&#x2026;..</td>
</tr>

<tr>
<td class="org-left">Sum</td>
<td class="org-left">\(\frac{n(n+1)}{2}\)</td>
</tr>
</tbody>
</table>

<p>
\[ \text{Average number of comparisions} = \frac{ \text{Sum of number of comparisions of all cases} }{ \text{Total number of cases.} } \]
\[ \text{Average number of comparisions} = \frac{n(n+1)}{2} \div n \]
\[ \text{Average number of comparisions} = \frac{n+1}{2} \]
\[ \text{Time complexity in average case} = O(n) \]
</p>
</div>
</div>

<div id="outline-container-orgd8aa317" class="outline-3">
<h3 id="orgd8aa317"><span class="section-number-3">16.2.</span> Divide and conquer approach (<b>Binary search</b>)</h3>
<div class="outline-text-3" id="text-16-2">
<p>
The binary search algorithm works on an array which is sorted. In this algorithm we:
</p>
<ol class="org-ol">
<li>Check the middle element of the array, return the index if element found.</li>
<li>If element &gt; array[mid], then our element is in the right part of the array, else it is in the left part of the array.</li>
<li>Get the mid element of the left/right sub-array</li>
<li>Repeat this process of division to subarray's and comparing the middle element till our required element is found.</li>
</ol>

<p>
The divide and conquer algorithm works as,
<br />
Suppose binarySearch(array, left, right, key), left and right are indicies of left and right of subarray. key is the element we have to search.
</p>
<ul class="org-ul">
<li><b>Divide part</b> : calculate mid index as mid = left + (right - left) /2 or (left + right) / 2. If array[mid] == key, return the value of mid.</li>
<li><b>Conquer part</b> : if array[mid] &gt; key, then key must not be in right half. So we search for key in left half, so we will recursively call binarySearch(array, left, mid - 1, key). Similarly, if array[mid] &lt; key, then key must not be in left half. So we search for key in right half, so recursively call binarySearch(array, mid + 1, right, key).</li>
<li><b>Combine part</b> : Since the binarySearch function will either return -1 or the index of the key, there is no need to combine the solutions of the subproblems.</li>
</ul>


<div id="org8fa7250" class="figure">
<p><img src="lectures/imgs/binary-search.jpg" alt="binary-search.jpg" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">binary_search</span>(<span style="color: #c18401;">int</span> *<span style="color: #8b4513;">array</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">low</span> = 0;
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">high</span> = n;

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">mid</span> = (low + high) / 2;

  <span style="color: #a626a4;">while</span>(low &lt;= high){
    mid = (low + high) / 2;
    <span style="color: #a626a4;">if</span> (x == array[mid]){
      <span style="color: #a626a4;">return</span> mid;
    }<span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (x &lt; array[mid]){
      low = low;
      high = mid - 1;
    }<span style="color: #a626a4;">else</span>{
      low = mid + 1;
      high = high;
    }
  }

  <span style="color: #a626a4;">return</span> -1;
}
</pre>
</div>

<p>
Recursive approach:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">binary_search</span>(<span style="color: #c18401;">int</span> *<span style="color: #8b4513;">array</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">right</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span>){
  <span style="color: #a626a4;">if</span>(left &gt; right)
    <span style="color: #a626a4;">return</span> -1;

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">mid</span> = (left + right) / 2;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">or we can use mid = left + (right - left) / 2, this will avoid int overflow when array has more elements.</span>

  <span style="color: #a626a4;">if</span> (x == array[mid])
    <span style="color: #a626a4;">return</span> mid;
  <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (x &lt; array[mid])
    <span style="color: #a626a4;">return</span> binary_search(array, left, mid - 1, x);
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> binary_search(array, mid + 1, right, x);
}
</pre>
</div>

<p>
<b>Recursive time complexity</b> : \(T(n) = T(n/2) + 1\)
</p>

<ul class="org-ul">
<li><b>Best Case</b> : Time complexity = O(1)</li>
<li><b>Average Case</b> : Time complexity = O(log n)</li>
<li><b>Worst Case</b> : Time complexity = O(log n)</li>
</ul>

<p>
<i>Binary search is better for sorted arrays and linear search is better for sorted arrays.</i>
<br />
<i>Another way to visualize binary search is using the binary tree.</i>
</p>
</div>
</div>
</div>

<div id="outline-container-org803348c" class="outline-2">
<h2 id="org803348c"><span class="section-number-2">17.</span> Max and Min element from array</h2>
<div class="outline-text-2" id="text-17">
</div>
<div id="outline-container-orga770d72" class="outline-3">
<h3 id="orga770d72"><span class="section-number-3">17.1.</span> Straightforward approach</h3>
<div class="outline-text-3" id="text-17-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">struc</span> <span style="color: #8b4513;">min_max</span> {<span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span>; <span style="color: #c18401;">int</span> <span style="color: #8b4513;">max</span>;}
<span style="color: #0184bc;">min_max</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[]){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">max</span> = array[0];
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span> = array[0];

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; len(array); i++){
    <span style="color: #a626a4;">if</span>(array[i] &gt; max)
      max = array[i];
    <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span>(array[i] &lt; min)
      min = array[i];
  }

  <span style="color: #a626a4;">return</span> (<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">min_max</span>) {min, max};
}
</pre>
</div>

<ul class="org-ul">
<li><b>Best case</b> : array is sorted in ascending order. Number of comparisions is \(n-1\). Time complexity is \(O(n)\).</li>
<li><b>Worst case</b> : array is sorted in descending order. Number of comparisions is \(2.(n-1)\). Time complexity is \(O(n)\).</li>
<li><b>Average case</b> : array can we arranged in n! ways, this makes calculating number of comparisions in the average case hard and it is somewhat unnecessary, so it is skiped. Time complexity is \(O(n)\)</li>
</ul>
</div>
</div>

<div id="outline-container-orgf75278d" class="outline-3">
<h3 id="orgf75278d"><span class="section-number-3">17.2.</span> Divide and conquer approach</h3>
<div class="outline-text-3" id="text-17-2">
<p>
Suppose the function is MinMax(array, left, right) which will return a tuple (min, max). We will divide the array in the middle, mid = (left + right) / 2. The left array will be array[left:mid] and right aray will be array[mid+1:right]
</p>
<ul class="org-ul">
<li><b>Divide part</b> : Divide the array into left array and right array. If array has only single element then both min and max are that single element, if array has two elements then compare the two and the bigger element is max and other is min.</li>
<li><b>Conquer part</b> : Recursively get the min and max of left and right array, leftMinMax = MinMax(array, left, mid)  and rightMinMax = MinMax(array, mid + 1, right).</li>
<li><b>Combine part</b> : If leftMinMax[0] &gt; rightMinmax[0], then min = righMinMax[0], else min = leftMinMax[0]. Similarly, if leftMinMax[1] &gt; rightMinMax[1], then max = leftMinMax[1], else max = rightMinMax[1].</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">Will return (min, max)</span>
<span style="color: #a626a4;">def</span> <span style="color: #0184bc;">minmax</span>(array, left, right):
    <span style="color: #a626a4;">if</span> left == right:       <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">Single element in array</span>
        <span style="color: #a626a4;">return</span> (array[left], array[left])
    <span style="color: #a626a4;">elif</span> left + 1 == right: <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">Two elements in array</span>
        <span style="color: #a626a4;">if</span> array[left] &gt; array[right]:
            <span style="color: #a626a4;">return</span> (array[right], array[left])
        <span style="color: #a626a4;">else</span>:
            <span style="color: #a626a4;">return</span> (array[left], array[right])
    <span style="color: #a626a4;">else</span>:                  <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">More than two elements</span>
        mid = (left + right) / 2
        <span style="color: #8b4513;">minimum</span>, <span style="color: #8b4513;">maximum</span> = 0, 0
        leftMinMax = minmax(array, left, mid)
        rightMinMax = minmax(array, mid + 1, right)

        <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">Combining result of the minimum from left and right subarray's</span>
        <span style="color: #a626a4;">if</span> leftMinMax[0] &gt; rightMinMax[0]:
            minimum = rightMinMax[0]
        <span style="color: #a626a4;">else</span>:
            minimum = leftMinMax[0]

        <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">Combining result of the maximum from left and right subarray's</span>
        <span style="color: #a626a4;">if</span> leftMinMax[1] &gt; rightMinMax[1]:
            maximum = leftMinMax[1]
        <span style="color: #a626a4;">else</span>:
            maximum = rightMinMax[1]

        <span style="color: #a626a4;">return</span> (minimum, maximum)

</pre>
</div>

<ul class="org-ul">
<li>Time complexity</li>
</ul>
<p>
We are dividing the problem into two parts of approximately, and it takes two comparisions on each part. Let's consider a comparision takes unit time. Then time complexity is
\[ T(n) = T(n/2) + T(n/2) + 2 \]
\[ T(n) = 2.T(n/2) + 2 \]
The recurrance terminated if single element in array with zero comparisions, i.e, \(T(1) = 0\), or when two elements with single comparision \(T(2) = 1\).
<br />
<i>Now we can use the <b>master's theorem</b> or <b>tree method</b> to solve for time complexity.</i>
\[ T(n) = \theta (n) \]
</p>

<ul class="org-ul">
<li>Space complexity</li>
</ul>
<p>
For space complexity, we need to find the longest branch of the recursion tree. Since both recursive calls are same sized, and the factor is (1/2), for <b>k+1</b> levels, function call will be func(n/2<sup>k</sup>), and terminating condition is func(2)
\[ func(2) = func(n/2^k) \]
\[ 2 = \frac{n}{2^k} \]
\[ k + 1 = log_2n \]
Since longest branch has \(log_2n\) nodes, the space complexity is \(O(log_2n)\).
</p>

<ul class="org-ul">
<li>Number of comparisions</li>
</ul>
<p>
In every case i.e, average, best and worst cases, <b>the number of comparisions in this algorithm is same</b>.
\[ \text{Total number of comparisions} = \frac{3n}{2} - 2 \]
If n is not a power of 2, we will round the number of comparision up.
</p>
</div>
</div>

<div id="outline-container-org4bc7b9b" class="outline-3">
<h3 id="org4bc7b9b"><span class="section-number-3">17.3.</span> Efficient single loop approach (Increment by 2)</h3>
<div class="outline-text-3" id="text-17-3">
<p>
In this algorithm we will compare pairs of numbers from the array. It works on the idea that the larger number of the two in pair can be the maximum number and smaller one can be the minimum one. So after comparing the pair, we can simply test from maximum from the bigger of two an minimum from smaller of two. This brings number of comparisions to check two numbers in array from 4 (when we increment by 1) to 3 (when we increment by 2).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a626a4;">def</span> <span style="color: #0184bc;">min_max</span>(array):
    (<span style="color: #8b4513;">minimum</span>, <span style="color: #8b4513;">maximum</span>) = (array[0], array[0])
    <span style="color: #8b4513;">i</span> = 1
    <span style="color: #a626a4;">while</span> i &lt; <span style="color: #e44649;">len</span>(array):
        <span style="color: #a626a4;">if</span> i + 1 == <span style="color: #e44649;">len</span>(array):  <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">don't check i+1, it's out of bounds, break the loop after checking a[i]</span>
            <span style="color: #a626a4;">if</span> array[i] &gt; <span style="color: #8b4513;">maximum</span>:
                maximum = array[i]
            <span style="color: #a626a4;">elif</span> array[i] &lt; <span style="color: #8b4513;">minimum</span>:
                minimum = array[i]
            <span style="color: #a626a4;">break</span>

        <span style="color: #a626a4;">if</span> array[i] &gt; array[i + 1]:
            <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">check possibility that array[i] is maximum and array[i+1] is minimum</span>
            <span style="color: #a626a4;">if</span> array[i] &gt; <span style="color: #8b4513;">maximum</span>:
                maximum = array[i]
            <span style="color: #a626a4;">if</span> array[i + 1] &lt; <span style="color: #8b4513;">minimum</span>:
                minimum = array[i + 1]
        <span style="color: #a626a4;">else</span>:
            <span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">check possibility that array[i+1] is maximum and array[i] is minimum</span>
            <span style="color: #a626a4;">if</span> array[i + 1] &gt; <span style="color: #8b4513;">maximum</span>:
                maximum = array[i + 1]
            <span style="color: #a626a4;">if</span> array[i] &lt; <span style="color: #8b4513;">minimum</span>:
                minimum = array[i]

        <span style="color: #8b4513;">i</span> += 2
    <span style="color: #a626a4;">return</span> (minimum, maximum)
</pre>
</div>

<ul class="org-ul">
<li>Time complexity = O(n)</li>
<li>Space complexity = O(1)</li>
<li>Total number of comparisions =
\[ \text{If n is odd},  \frac{3(n-1)}{2} \]
\[ \text{If n is even}, \frac{3n}{2} - 2 \]</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfb9c049" class="outline-2">
<h2 id="orgfb9c049"><span class="section-number-2">18.</span> Square matrix multiplication</h2>
<div class="outline-text-2" id="text-18">
<p>
Matrix multiplication algorithms taken from here: 
<a href="https://www.cs.mcgill.ca/~pnguyen/251F09/matrix-mult.pdf">https://www.cs.mcgill.ca/~pnguyen/251F09/matrix-mult.pdf</a>
</p>
</div>

<div id="outline-container-org79f7ead" class="outline-3">
<h3 id="org79f7ead"><span class="section-number-3">18.1.</span> Straight forward method</h3>
<div class="outline-text-3" id="text-18-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">This will calculate A X B and store it in C.</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">N</span> 3

<span style="color: #c18401;">int</span> <span style="color: #0184bc;">main</span>(){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">A</span>[N][N] = {
    {1,2,3},
    {4,5,6},
    {7,8,9} };

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">B</span>[N][N] = {
    {10,20,30},
    {40,50,60},
    {70,80,90} };

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">C</span>[N][N];

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; N; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; N; j++){
      C[i][j] = 0;
      <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span> = 0; k &lt; N; k++){
        C[i][j] += A[i][k] * B[k][j];
      }
    }
  }

  <span style="color: #a626a4;">return</span> 0;
}
</pre>
</div>

<p>
Time complexity is \(O(n^3)\)
</p>
</div>
</div>

<div id="outline-container-org6298e2e" class="outline-3">
<h3 id="org6298e2e"><span class="section-number-3">18.2.</span> Divide and conquer approach</h3>
<div class="outline-text-3" id="text-18-2">
<p>
The divide and conquer algorithm only works for a square matrix whose size is n X n, where n is a power of 2. The algorithm works as follows.
</p>

<pre class="example">
MatrixMul(A, B, n):
  If n == 2 {
    return A X B
  }else{
    Break A into four parts A_11, A_12, A_21, A_22, where A = [[ A_11, A_12],
							       [ A_21, A_22]]

    Break B into four parts B_11, B_12, B_21, B_22, where B = [[ B_11, B_12],
							       [ B_21, B_22]]

    C_11 = MatrixMul(A_11, B_11, n/2) + MatrixMul(A_12, B_21, n/2)
    C_12 = MatrixMul(A_11, B_12, n/2) + MatrixMul(A_12, B_22, n/2)
    C_21 = MatrixMul(A_21, B_11, n/2) + MatrixMul(A_22, B_21, n/2)
    C_22 = MatrixMul(A_21, B_12, n/2) + MatrixMul(A_22, B_22, n/2)

    C = [[ C_11, C_12],
	 [ C_21, C_22]]

    return C
  }
</pre>

<p>
The addition of matricies of size (n X n) takes time \(\theta (n^2)\), therefore, for computation of C<sub>11</sub> will take time of \(\theta \left( \left( \frac{n}{2} \right)^2 \right)\), which is equals to \(\theta \left( \frac{n^2}{4} \right)\). Therefore, computation time of C<sub>11</sub>, C<sub>12</sub>, C<sub>21</sub> and C<sub>22</sub> combined will be \(\theta \left( 4 \frac{n^2}{4} \right)\), which is equals to \(\theta (n^2)\).
<br />
There are 8 recursive calls in this function with MatrixMul(n/2), therefore, time complexity will be
\[ T(n) = 8T(n/2) + \theta (n^2) \]
Using the <b>master's theorem</b>
\[ T(n) = \theta (n^{log_28}) \]
\[ T(n) = \theta (n^3) \]
</p>
</div>
</div>

<div id="outline-container-orga332175" class="outline-3">
<h3 id="orga332175"><span class="section-number-3">18.3.</span> Strassen's algorithm</h3>
<div class="outline-text-3" id="text-18-3">
<p>
Another, more efficient divide and conquer algorithm for matrix multiplication. This algorithm also only works on square matrices with n being a power of 2. This algorithm is based on the observation that, for \(A \times B = C\). We can calculate \(C_{11}, C_{12}, C_{21} \text{ and } C_{22}\) as,
</p>

<p>
\[ C_{11} = P_5 + P_4 - P_2 + P_6 \]
\[ C_{12} = P_1 + P_2 \]
\[ C_{21} = P_3 + P_4 \]
\[ C_{22} = P_1 + P _5 - P_3 - P_7 \]
Where,
\[ P_1 = A_{11} \times (B_{12} - B_{22}) \]
\[ P_2 = (A_{11} + A_{12}) \times B_{22} \]
\[ P_3 = (A_{21} + A_{22}) \times B_{11} \]
\[ P_4 = A_{22} X (B_{21} - B_{11}) \]
\[ P_5 = (A_{11} + A_{22}) \times (B_{11} + B_{22}) \]
\[ P_6 = (A_{12} - A_{22}) \times (B_{21} + B_{22}) \]
\[ P_7 = (A_{11} - A_{21}) \times (B_{11} + B_{12}) \]
This reduces number of recursion calls from 8 to 7.
</p>

<pre class="example">
Strassen(A, B, n):
  If n == 2 {
    return A X B
  }
  Else{
    Break A into four parts A_11, A_12, A_21, A_22, where A = [[ A_11, A_12],
							       [ A_21, A_22]]

    Break B into four parts B_11, B_12, B_21, B_22, where B = [[ B_11, B_12],
							       [ B_21, B_22]]
    P_1 = Strassen(A_11, B_12 - B_22, n/2)
    P_2 = Strassen(A_11 + A_12, B_22, n/2)
    P_3 = Strassen(A_21 + A_22, B_11, n/2)
    P_4 = Strassen(A_22, B_21 - B_11, n/2)
    P_5 = Strassen(A_11 + A_22, B_11 + B_22, n/2)
    P_6 = Strassen(A_12 - A_22, B_21 + B_22, n/2)
    P_7 = Strassen(A_11 - A_21, B_11 + B_12, n/2)
    C_11 = P_5 + P_4 - P_2 + P_6
    C_12 = P_1 + P_2
    C_21 = P_3 + P_4
    C_22 = P_1 + P_5 - P_3 - P_7
    C = [[ C_11, C_12],
	 [ C_21, C_22]]
    return C
  }
</pre>

<p>
This algorithm uses 18 matrix addition operations. So our computation time for that is \(\theta \left(18\left( \frac{n}{2} \right)^2 \right)\) which is equal to \(\theta (4.5 n^2)\) which is equal to \(\theta (n^2)\).
<br />
There are 7 recursive calls in this function which are Strassen(n/2), therefore, time complexity is
\[ T(n) = 7T(n/2) + \theta (n^2) \]
Using the master's theorem
\[ T(n) = \theta (n^{log_27}) \]
\[ T(n) = \theta (n^{2.807}) \]
</p>


<ul class="org-ul">
<li><i><b>NOTE</b> : The divide and conquer approach and strassen's algorithm typically use n == 1 as their terminating condition since for multipliying 1 X 1 matrices, we only need to calculate product of the single element they contain, that product is thus the single element of our resultant 1 X 1 matrix.</i></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org13d9d6a" class="outline-2">
<h2 id="org13d9d6a"><span class="section-number-2">19.</span> Sorting algorithms</h2>
<div class="outline-text-2" id="text-19">
</div>
<div id="outline-container-org5886e84" class="outline-3">
<h3 id="org5886e84"><span class="section-number-3">19.1.</span> In place vs out place sorting algorithm</h3>
<div class="outline-text-3" id="text-19-1">
<p>
If the space complexity of a sorting algorithm is \(\theta (1)\), then the algorithm is called in place sorting, else the algorithm is called out place sorting.
</p>
</div>
</div>
</div>

<div id="outline-container-org52596bc" class="outline-2">
<h2 id="org52596bc"><span class="section-number-2">20.</span> Bubble sort</h2>
<div class="outline-text-2" id="text-20">
<p>
Simplest sorting algorithm, easy to implement so it is useful when number of elements to sort is small. It is an in place sorting algorithm. We will compare pairs of elements from array and swap them to be in correct order. Suppose input has n elements.
</p>
<ul class="org-ul">
<li>For first pass of the array, we will do <b>n-1</b> comparisions between pairs, so 1st and 2nd element; then 2nd and 3rd element; then 3rd and 4th element; till comparision between (n-1)th and nth element, swapping positions according to the size. <i>A single pass will put a single element at the end of the list at it's correct position.</i></li>
<li>For second pass of the array, we will do <b>n-2</b> comparisions because  the last element is already in it's place after the first pass.</li>
<li>Similarly, we will continue till we only do a single comparision.</li>
<li>The total number of comparisions will be
\[ \text{Total comparisions} = (n - 1) + (n - 2) + (n - 3) + ..... + 2 + 1 \]
\[ \text{Total comparisions} = \frac{n(n-1)}{2} \]
Therefore, <b>time complexity is \(\theta (n^2)\)</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">binary_search</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[]){
  <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">i is the number of comparisions in the pass</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = len(array) - 1; i &gt;= 1; i--){
    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">j is used to traverse the list</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; i; j++){
      <span style="color: #a626a4;">if</span>(array[j] &gt; array[j+1])
        array[j], array[j+1] = array[j+1], array[j];
    }
  }
}
</pre>
</div>

<p>
<b><i>Minimum number of swaps can be calculated by checking how many swap operations are needed to get each element in it's correct position.</i></b> This can be done by checking the number of smaller elements towards the left. For descending, check the number of larger elements towards the left of the given element. Example for ascending sort,
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Array</td>
<td class="org-right">21</td>
<td class="org-right">16</td>
<td class="org-right">17</td>
<td class="org-right">8</td>
<td class="org-right">31</td>
</tr>

<tr>
<td class="org-left">Minimum number of swaps to get in correct position</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
<p>
Therefore, minimum number of swaps is ( 3 + 1 + 0 + 0 + 0) , which is equal to 4 swaps.
</p>

<ul class="org-ul">
<li><b><i>Reducing number of comparisions in implementation</i></b> : at the end of every pass, check the number of swaps. <b>If number of swaps in a pass is zero, then the array is sorted.</b> This implementation does not give minimum number of comparisions, but reduces number of comparisions from default implementation. It reduces the time complexity to \(\theta (n)\) for best case scenario, since we only need to pass through array once.</li>
</ul>
<p>
Recursive time complexity : \(T(n)  = T(n-1) + n - 1\)
</p>
</div>
</div>
<div id="outline-container-org330cbf9" class="outline-2">
<h2 id="org330cbf9"><span class="section-number-2">21.</span> Selection sort</h2>
<div class="outline-text-2" id="text-21">
<p>
It is an inplace sorting technique. In this algorithm, we will get the minimum element from the array, then we swap it to the first position. Now we will get the minimum from array[1:] and place it in index 1. Similarly, we get minimum from array[2:] and then place it on index 2. We do till we get minimum from array[len(array) - 2:] and place minimum on index [len(array) - 2].
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">selection_sort</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[]){
  <span style="color: #a626a4;">for</span>( <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; len(array)-2 ; i++ ) {
    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Get the minimum index from the sub-array [i:]</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min_index</span> = i;
    <span style="color: #a626a4;">for</span>( <span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = i+1; j &lt; len(array) - 1; j++ )
      <span style="color: #a626a4;">if</span> (array[j] &lt; array[min_index]) { min_index = j; }

    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Swap the min_index with it's position at start of sub-array</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
    array[i], array[min_index] = array[min_index], array[i];
  }
}
</pre>
</div>
</div>

<div id="outline-container-orgb3c4020" class="outline-3">
<h3 id="orgb3c4020"><span class="section-number-3">21.1.</span> Time complexity</h3>
<div class="outline-text-3" id="text-21-1">
<p>
The total number of comparisions is,
\[ \text{Total number of comparisions} = (n -1) + (n-2) + (n-3) + ... + (1) \]
\[ \text{Total number of comparisions} = \frac{n(n-1)}{2} \]
For this algorithm, number of comparisions are same in best, average and worst case.
Therefore the time complexity in all cases is, \[ \text{Time complexity} = \theta (n) \]
</p>

<ul class="org-ul">
<li>Recurrance time complexity : \(T(n) = T(n-1) + n - 1\)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc7bf85b" class="outline-2">
<h2 id="orgc7bf85b"><span class="section-number-2">22.</span> Insertion sort</h2>
<div class="outline-text-2" id="text-22">
<p>
It is an inplace sorting algorithm.
</p>
<ul class="org-ul">
<li>In this algorithm, we first divide array into two sections. Initially, the left section has a single element and right section has all the other elements. Therefore, the left part is sorted and right part is unsorted.</li>
<li>We call the leftmost element of the right section the key.</li>
<li>Now, we insert the key in it's correct position, in left section.</li>
<li>As commanly known, for insertion operation we need to shift elements. So we shift elements in the left section.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">insertion_sort</span> ( <span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[] ) {
  <span style="color: #a626a4;">for</span>( <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt; len(array); i++ ) {
    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Key is the first element of the right section of array</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">key</span> = array[j];
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = i - 1;

    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Shift till we find the correct position of the key in the left section</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
    <span style="color: #a626a4;">while</span> ( j &gt; 0 &amp;&amp; array[j] &gt; key ) {
      array[j + 1] = array[j];
      j -= 1;
    }
    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Insert key in it's correct position</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
    array[j+1] = key;
  }
}
</pre>
</div>
</div>

<div id="outline-container-org83561b7" class="outline-3">
<h3 id="org83561b7"><span class="section-number-3">22.1.</span> Time complexity</h3>
<div class="outline-text-3" id="text-22-1">
<p>
<b>Best Case</b> : The best case is when input array is already sorted. In this case, we do <b>(n-1)</b> comparisions and no swaps. The time complexity will be \(\theta (n)\)
<br />
<b>Worst Case</b> : The worst case is when input array is is descending order when we need to sort in ascending order and vice versa (basically reverse of sorted). The number of comparisions is
<br />
\[ [1 + 2 + 3 + .. + (n-1)] = \frac{n(n-1)}{2} \]
<br />
The number of element shift operations is
<br />
\[ [1 + 2 + 3 + .. + (n-1)] =  \frac{n(n-1)}{2} \]
<br />
Total time complexity becomes \(\theta \left( 2 \frac{n(n-1)}{2} \right)\), which is simplified to \(\theta (n^2)\).
</p>

<ul class="org-ul">
<li><b>NOTE</b> : Rather than using <b>linear search</b> to find the position of key in the left (sorted) section, we can use <b>binary search</b> to reduce number of comparisions.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5f36642" class="outline-2">
<h2 id="org5f36642"><span class="section-number-2">23.</span> Inversion in array</h2>
<div class="outline-text-2" id="text-23">
<p>
The inversion of array is the measure of how close array is from being sorted.
<br />
For an ascending sort, it is the amount of element pairs such that array[i] &gt; array[j] and i &lt; j OR IN OTHER WORDS array[i] &lt; array[j]  and i &gt; j.
</p>
<ul class="org-ul">
<li>For <b>ascending sort</b>, we can simply look at the number of elements to left of the given element that are smaller.</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Array</td>
<td class="org-right">10</td>
<td class="org-right">6</td>
<td class="org-right">12</td>
<td class="org-right">8</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Inversions</td>
<td class="org-right">4</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Total number of inversions = (4+2+3+2+1+0) = 12
</p>

<ul class="org-ul">
<li>For <b>descending sort</b>, we can simply look at the number of elements to the left of the given element that are larger.</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Array</td>
<td class="org-right">10</td>
<td class="org-right">6</td>
<td class="org-right">12</td>
<td class="org-right">8</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Inversions</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Total number of inversions = 1 + 2 = 3
</p>

<ul class="org-ul">
<li>For an array of size <b>n</b></li>
</ul>
<p>
\[ \text{Maximum possible number of inversions} = \frac{n(n-1)}{2} \]
\[ \text{Minimum possible number of inversions} = 0 \]
</p>
</div>

<div id="outline-container-orgd81ee8c" class="outline-3">
<h3 id="orgd81ee8c"><span class="section-number-3">23.1.</span> Relation between time complexity of insertion sort and inversion</h3>
<div class="outline-text-3" id="text-23-1">
<p>
If the inversion of an array is f(n), then the time complexity of the insertion sort will be \(\theta (n + f(n))\).
</p>
</div>
</div>
</div>

<div id="outline-container-org6311a99" class="outline-2">
<h2 id="org6311a99"><span class="section-number-2">24.</span> Quick sort</h2>
<div class="outline-text-2" id="text-24">
<p>
It is a divide and conquer technique. It uses a partition algorithm which will choose an element from array, then place all smaller elements to it's left and larger to it's right. Then we can take these two parts of the array and recursively place all elements in correct position. For ease, the element chosen by the partition algorithm is either leftmost or rightmost element.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">quick_sort</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">low</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">high</span>){
  <span style="color: #a626a4;">if</span>(low &lt; high){
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span> = partition(array, low, high);
    quick_sort(array, low, x-1);
    quick_sort(array, x+1, high);
  }
}
</pre>
</div>

<p>
As we can see, the main component of this algorithm is the partition algorithm.
</p>
</div>

<div id="outline-container-org26e288f" class="outline-3">
<h3 id="org26e288f"><span class="section-number-3">24.1.</span> Lomuto partition</h3>
<div class="outline-text-3" id="text-24-1">
<p>
The partition algorithm will work as follows:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">Will return the index where the array is partitioned</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">partition</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">low</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">high</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">pivot</span> = array[high];
  <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">This will point to the element greater than pivot</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = low;

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = low; j &lt; high; j++){
    <span style="color: #a626a4;">if</span>(array[j] &lt;= pivot){
      array[i], array[j] = array[j], array[i];
      i += 1;
    }
  }

  array[i+1], array[high] = array[high], array[i+1];
  <span style="color: #a626a4;">return</span> (i + 1);
}
</pre>
</div>

<ul class="org-ul">
<li>Time complexity</li>
</ul>
<p>
For an array of size <b>n</b>, the number ofcomparisions done by this algorithm is always <b>n - 1</b>. Therefore, the time complexity of this partition algorithm is,
\[ T(n) = \theta (n) \]
</p>
</div>
</div>

<div id="outline-container-org9642c8c" class="outline-3">
<h3 id="org9642c8c"><span class="section-number-3">24.2.</span> Time complexity of quicksort</h3>
<div class="outline-text-3" id="text-24-2">
<p>
In quick sort, we don't have a fixed recursive relation. The recursive relations differ for different cases.
</p>
<ul class="org-ul">
<li><b>Best Case</b> : The partition algorithm always divides the array to two equal parts. In this case, the recursive relation becomes
\[ T(n) = 2T(n/2) + \theta (n) \]
Where, \(\theta (n)\) is the time complexity for creating partition.
<br />
Using the master's theorem.
\[ T(n) = \theta( n.log(n) ) \]</li>

<li><b>Worst Case</b> : The partition algorithm always creates the partition at one of the extreme positions of the array. This creates a single partition with <b>n-1</b> elements. Therefore, the quicksort algorithm has to be called on the remaining <b>n-1</b> elements of the array.
\[ T(n) = T(n-1) + \theta (n) \]
Again, \(\theta (n)\) is the time complexity for creating partition.
<br />
Using master's theorem
\[ T(n) = \theta (n^2) \]</li>

<li><b>Average Case</b> : The average case is closer to the best case in quick sort rather than to the worst case.</li>
</ul>
<p>
<br />
To get the average case, we will <b>consider a recursive function for number of comparisions</b> \(C(n)\).
<br />
For the function \(C(n)\), there are \(n-1\) comparisions for the partition algorithm.
<br />
Now, suppose that the index of partition is <b>i</b>.
<br />
This will create two recursive comparisions \(C(i)\) and \(C(n-i-1)\).
<br />
<b>i</b> can be any number between <b>0</b> and <b>n-1</b>, with each case being equally probable. So the average number of comparisions for \(C(n)\) will be
\[ \frac{1}{n} \sum_{i=0}^{n-1} \left( C(i) + C(n-i-1) \right) \]
Therefore, total number of comparisions for input size <b>n</b> will be,
\[ C(n) = \left(  n-1  \right) + \frac{1}{n} \sum_{i=0}^{n-1} \left( C(i) + C(n-i-1) \right) \]
Solving the above recurrance relation will give us,
\[ C(n) \approx 2\ n\ ln(n) \]
\[ C(n) \approx 1.39\ n\ log_2(n) \]
Therefore, the time complexity in average case becomes,
\[ T(n) = \theta (n\ log_2(n)) \]
</p>
</div>
</div>

<div id="outline-container-orgc63f850" class="outline-3">
<h3 id="orgc63f850"><span class="section-number-3">24.3.</span> Number of comparisions</h3>
<div class="outline-text-3" id="text-24-3">
<p>
The number of comparisions in quick sort for,
</p>
<ul class="org-ul">
<li>Worst Case : \[ \text{Number of comparisions} = \frac{n(n-1)}{2} \]</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd776ee7" class="outline-2">
<h2 id="orgd776ee7"><span class="section-number-2">25.</span> Merging two sorted arrays (2-Way Merge)</h2>
<div class="outline-text-2" id="text-25">
<p>
Suppose we have two arrays that are already sorted. The first array has <b>n</b> elements and the second array has <b>m</b> elements.
<br />
The way to merge them is to compare the elements in a sequence between the two arrays. We first add a pointer to start of both arrays. The element pointed by the pointers are compared and the smaller one is added to our new array. Then we move pointer on that array forward. These comparisions are repeated until we reach the end of one of the array. At this point, we can simply append all the elements of the remaining array.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">int</span> *<span style="color: #0184bc;">merge</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">a</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">b</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>){
  <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">c</span> = malloc((m+n) * <span style="color: #a626a4;">sizeof</span>(<span style="color: #c18401;">int</span>));
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; <span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0;
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span> = 0;

  <span style="color: #a626a4;">while</span> (i !=  n &amp;&amp; j != m) {
    <span style="color: #a626a4;">if</span> ( a[i] &gt; b[j] ) { c[k++] = b[j++]; } <span style="color: #a626a4;">else</span> { c[k++] = a[i++]; };
  }

  <span style="color: #a626a4;">while</span> (i != n) {
    c[k++] = a[i++];
  }

  <span style="color: #a626a4;">while</span> (j != m) {
    c[k++] = b[j++];
  }

  <span style="color: #a626a4;">return</span> c;
}
</pre>
</div>

<ul class="org-ul">
<li>The maximum number of comparisions to merge the arrays is (m + n - 1).</li>
<li>The minimum number of comparisions to merge the arrays is either <b>m</b> or <b>n</b>. Depending of which one is smaller.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd053503" class="outline-2">
<h2 id="orgd053503"><span class="section-number-2">26.</span> Merging k sorted arrays (k-way merge)</h2>
<div class="outline-text-2" id="text-26">
<p>
k-way merge algorithms take k different sorted arrays and merge them into a single single array. The algorithm is same as that in two way merge except we need to get the smallest element from the pointer on k array's and then move it's corresponding pointer.
</p>
</div>
</div>

<div id="outline-container-org7ea9774" class="outline-2">
<h2 id="org7ea9774"><span class="section-number-2">27.</span> Merge sort</h2>
<div class="outline-text-2" id="text-27">
<p>
Merge sort is a pure divide and conquer algorithm. In this sorting algorithm, we merge the sorted sub-arrays till we get a final sorted array.<br />
The algorithm will work as follows :
</p>
<ol class="org-ol">
<li>Divide the array of n elements into <b>n</b> subarrays, each having one element.</li>
<li>Repeatdly merge the subarrays to form merged subarrays of larger sizes until there is one list remaining.</li>
</ol>

<p>
For divide and conquer steps: 
</p>
<ul class="org-ul">
<li><b>Divide</b> : Divide the array from the middle into two equal sizes.</li>
<li><b>Conquer</b> : Call merge sort recursively on the two subarrays</li>
<li><b>Combine</b> : Merge the sorted array</li>
</ul>

<p>
The algorithm works as follows (this isn't real c code)
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">A function that will merge two sorted arrays</span>
<span style="color: #c18401;">int</span>[] merge(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">first</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">second</span>[]);

<span style="color: #c18401;">int</span>[] merge_sort(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">right</span>){
  <span style="color: #a626a4;">if</span>(left &lt; right){
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">mid</span> = (left + right) / 2;
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sorted_first</span>[] = merge_sort(array[], left, mid);
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sorted_second</span>[] = merge_sort(array[], mid + 1, right);

    <span style="color: #a626a4;">return</span> merge(sorted_first, sorted_second);
  }
}
</pre>
</div>

<p>
This algorithm is often used in languages which have great support for linked lists, for example lisp and haskell. For more traditional c-like languages, often quicksort is easier to implement.
<br />
An implementation in C language is as follows.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">buffer is memory of size equal to or bigger than size of array</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">buffer is used when merging the arrays</span>
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">merge_sort</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">right</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">buffer</span>[]){
  <span style="color: #a626a4;">if</span>(left &lt; right){
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Divide part</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">mid</span> = ( left + right ) / 2;

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Conquer part</span>
    merge_sort(array,left, mid, buffer);
    merge_sort(array, mid + 1, right, buffer);

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Combine part : Merges the two sorted parts</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = left; <span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = mid + 1; <span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span> = 0;
    <span style="color: #a626a4;">while</span>( i != (mid+1) &amp;&amp; j != (right+1) ){
      <span style="color: #a626a4;">if</span>(array[i] &lt; array[j]) { buffer[k++] = array[i++];  } <span style="color: #a626a4;">else</span> { buffer[k++] = array[j++]; }
    }

    <span style="color: #a626a4;">while</span>(i != (mid+1))
      buffer[k++] = array[i++];

    <span style="color: #a626a4;">while</span>(j != (right+1))
      buffer[k++] = array[j++];

    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">x</span> = left; x &lt;= right; x++)
      array[x] = buffer[x - left];
  }
}
</pre>
</div>
</div>

<div id="outline-container-orgfdf7002" class="outline-3">
<h3 id="orgfdf7002"><span class="section-number-3">27.1.</span> Time complexity</h3>
<div class="outline-text-3" id="text-27-1">
<p>
Unlike quick sort, <b>the recurrance relation is same for merge sort in all cases.</b>
<br />
Since divide part divides array into two equal sizes, the input size is halfed (i.e, <b>T(n/2)</b> ).
<br />
In conquer part, there are two calls so <b>2.T(n/2)</b> is added to time complexity.
<br />
The cost for merging two arrays of size n/2 each is either <b>n-1</b> of <b>n/2</b>. That is to say that time complexity to merge two arrays of size n/2 each is always \(\theta (n)\). Thus, the final recurrance relation is
\[ T(n) = 2.T(n/2) + \theta (n) \]
Using the master's theorem.
\[ T(n) = \theta (n.log_2n) \]
</p>
</div>
</div>

<div id="outline-container-orgf1bbcf5" class="outline-3">
<h3 id="orgf1bbcf5"><span class="section-number-3">27.2.</span> Space complexity</h3>
<div class="outline-text-3" id="text-27-2">
<p>
As we can see in the C code, the space complexity is \(\theta (n)\)
</p>
</div>
</div>
</div>

<div id="outline-container-org8b1d6aa" class="outline-2">
<h2 id="org8b1d6aa"><span class="section-number-2">28.</span> Stable and unstable sorting algorithms</h2>
<div class="outline-text-2" id="text-28">
<p>
We call sorting algorithms unstable or stable on the basis of whether they change order of equal values.
</p>
<ul class="org-ul">
<li><b>Stable sorting algorithm</b> : a sorting algorithm that preserves the order of the elements with equal values.</li>
<li><b>Unstable sorting algorithm</b> : a sorting algorithm that does not preserve the order of the elements with equal values.
<br /></li>
</ul>
<p>
This is of importance when we store data in pairs of keys and values and then sort data using the keys. So we may want to preserve the order in which the entries where added.
<br />
Example, suppose we add (key, value) pairs as:
</p>
<pre class="example">
(2, v1), (1, v2), (3, v3), (1, v1), (2, v4), (3, v2)
</pre>

<p>
Now, if we sort using the keys a sorting algorithm which is stabe will preserve the order of elements with equal keys. So output is always
</p>
<pre class="example">
(1, v2), (1, v1), (2,v1), (2, v4), (3, v3), (3, v2)
</pre>
<p>
i.e, the <b>order of keys with same values is preserved</b>.
<br />
Whereas an unstable sorting algorithm will sort without preserving the order of key values.
</p>
</div>
</div>

<div id="outline-container-orgd73bfa5" class="outline-2">
<h2 id="orgd73bfa5"><span class="section-number-2">29.</span> Non-comparitive sorting algorithms</h2>
<div class="outline-text-2" id="text-29">
<p>
Sorting algorithms which do not use comparisions to sort elements are called non-comparitive sorting algorithms. These tend to be faster than comparitive sorting algorithms.
</p>
</div>

<div id="outline-container-org5319cd3" class="outline-3">
<h3 id="org5319cd3"><span class="section-number-3">29.1.</span> Counting sort</h3>
<div class="outline-text-3" id="text-29-1">
<ul class="org-ul">
<li>Counting sort <b>only works on integer arrays</b></li>
<li>Couting sort only works if <b>all elements of array are non-negative</b>, i.e, elements are only allowed to be in range [0,k] .</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">* The input array is sorted and result is stored in output array *//</span>
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">* max is the largest element of the array *//</span>
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">counting_sort</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">input</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">max</span> ,<span style="color: #c18401;">int</span> <span style="color: #8b4513;">output</span>[]){
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">count array should have a size greater than or equal to (max + 1)</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">count</span>[max + 1];
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">initialize count array to zero, can also use memset</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; max+1; i++) count[i] = 0;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i from 0 to len(array) - 1</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this loop stores number of elements equal to i in count array</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; len(input); i++)
    count[input[i]] = count[input[i]] + 1;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i from 1 to max</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this loop stores number of elements less that or equal to i in count array</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i.e, it calculates cumulative frequency</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= max; i++)
    count[i] = count[i] + count[i - 1];

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i from len(array) - 1 to 0</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = len(array) - 1; i &gt;= 0; i--){
    count[input[i]] = count[input[i]] - 1;
    output[count[input[i]]] = input[i];
  }
}
</pre>
</div>

<ul class="org-ul">
<li><p>
<b>Time complexity</b> : Since there are only simple loops and arithmetic operations, we can get time complexity by considering the number of times loops are executed.
</p>

<p>
\[ \text{Number of times loops are executed} = n + (max - 1) + n \]
\[ \text{Where, } n = len(array) \text{ i.e, the input size} \]
</p>

<p>
Therefore,
\[ \text{Number of times loops are executed} = 2n + max - 1 \]
\[ \text{Time complexity} = \theta (n + max) \]
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org062dedd" class="outline-3">
<h3 id="org062dedd"><span class="section-number-3">29.2.</span> Radix sort</h3>
<div class="outline-text-3" id="text-29-2">
<p>
In radix sort, we sort using the digits, from least significant digit (lsd) to most significant digit (msd). In other words, we sort digits from right to left. The algorithm used to sort digits <b>should be a stable sorting algorithm</b>.
</p>


<div id="orgdeeaa7c" class="figure">
<p><img src="lectures/imgs/radix-sort.png" alt="radix-sort.png" />
</p>
</div>

<p>
For the following example, we will use the bubble sort since it is the easiest to implement. But, for best performance, <b>radix sort is paired with counting sort</b>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">d = 0, will return digit at unit's place</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">d = 1, will return digit at ten's place</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">and so on.</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">get_digit</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">d</span>){
  assert(d &gt;= 0);
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">place</span> = (<span style="color: #c18401;">int</span>) pow(10, d);
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">digit</span> = (n / place) % 10;
  <span style="color: #a626a4;">return</span> digit;
}

<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">bubble sort the array for only digits of the given place</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">d = 0, unit's place</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">d = 1, ten's place</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">and so on.</span>
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">bubble_sort_digit</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">d</span>){
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = len(array); i &gt;= 1; i--){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; i; j++){
      <span style="color: #a626a4;">if</span>(get_digit(array[j], d) &gt; get_digit(array[j + 1], d))
        array[j], array[j + 1] = array[j + 1], array[j];
    }
  }
}

<span style="color: #c18401;">void</span> <span style="color: #0184bc;">radix_sort</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">no_of_digits</span>){
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; no_of_digits ; i++){
    bubble_sort_digit(array, i );
  }
}
</pre>
</div>

<ul class="org-ul">
<li><b>Time complexity</b> : \[ \text{Time Complexity} = \theta (d.(n + max)) \]
Where, <b>d = number of digits in max elemet</b>, and
<br />
radix sort is paired with counting sort.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfd9873e" class="outline-3">
<h3 id="orgfd9873e"><span class="section-number-3">29.3.</span> Bucket sort</h3>
<div class="outline-text-3" id="text-29-3">
<p>
Counting sort only works for non-negative integers. Bucket sort is a generalization of counting sort. If we know the range of the elements in the array, we can sort them using bucket sort. In bucket sort, we distribute the elements into buckets (collections of elements). Each bucket will hold elements of different ranges. Then, we can either sort elements in the buckets using some other sorting algorithm or by using bucket sort algorithm recursively.
<br />
Bucket sort works as follows:
</p>
<ol class="org-ol">
<li>Set up empty buckets</li>
<li><b>Scatter</b> the elements into buckets based on different ranges.</li>
<li><b>Sort</b> elements in non-empty buckets.</li>
<li><b>Gather</b> the elements from buckets and place in orignal array.</li>
</ol>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="lectures/imgs/Bucket_sort_1.svg  " alt="Bucket_sort_1.svg  " /></td>
<td class="org-left"><b>Elements are distributed among bins</b></td>
</tr>

<tr>
<td class="org-left"><img src="lectures/imgs/Bucket_sort_2.svg" alt="Bucket_sort_2.svg" class="org-svg" /></td>
<td class="org-left"><b>Then, elements are sorted within each bin and then result is concatenated</b></td>
</tr>
</tbody>
</table>

<p>
To get the ranges of the buckets, we can use the smallest (min) and biggest (max) element of the array.
<br />
The number of elements in each bucket will be,
</p>

<p>
\[ \text{Range of each bucket} (r) = \frac{(\text{max} - \text{min} + 1)}{ \text{number of buckets}} \]
</p>

<p>
Then, the ranges of buckets will be,
</p>
<ul class="org-ul">
<li>(min + 0.r) &lt;==&gt; (min + 1.r - 1)</li>
<li>(min + 1.r) &lt;==&gt; (min + 2.r - 1)</li>
<li>(min + 2.r) &lt;==&gt; (min + 3.r - 1)</li>
<li>(min + 3.r) &lt;==&gt; (min + 4.r - 1)</li>
<li><b>etc.</b></li>
</ul>

<p>
Then, we can get the bucket number to which we add any array[i] as,
\[ \text{bucket index} =  \frac{ \text{array[i]} - \text{min} }{ r } \]
Where,
\[ r = \frac{(\text{max} - \text{min} + 1)}{ \text{number of buckets}} \]
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">bucket_sort</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">array</span>[], <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">max</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">number_of_buckets</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">output</span>[]){
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">a bucket will have capacity of [ (max - min + 1) / number_of_buckets ] elements</span>
  Vector&lt;<span style="color: #c18401;">int</span>&gt; buckets[number_of_buckets];
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span> = (max - min + 1) / number_of_buckets;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if (max - min + 1) &lt; number_of_buckets, then r could be 0.</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">in this case, just set r to 1</span>
  <span style="color: #a626a4;">if</span>(r &lt;= 0) r = 1;

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; n; i++){
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">put array[i] in bucket number (array[i] - min) / r</span>
    buckets[ (array[i] - min) / r].put(array[i]);
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">sort elements of buckets and append to final output array</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; number_of_buckets; i++){
    buckets[i].sort();
    output.append(bucket[i]);
  }
}
</pre>
</div>
</div>

<div id="outline-container-org721cbac" class="outline-4">
<h4 id="org721cbac"><span class="section-number-4">29.3.1.</span> Time complexity</h4>
<div class="outline-text-4" id="text-29-3-1">
<p>
The time complexity in bucket sort is affected by what sorting algorithm will be used to sort elements in a bucket.
<br />
We also have to add the time complexities for initializing the buckets. Suppose there are k buckets, then the time to initialize then is \(\theta (k)\).
<br />
Also the scattering of elements in buckets will take \(\theta (n)\) time.
</p>

<ul class="org-ul">
<li><b>Worst Case</b> : Worst case for bucket sort is if all the <b>elements are in the same bucket</b>. In this case, the <b>time complexity is the same as the time complexity of the sorting algorithm used</b> plus the time to scatter elements and initialize buckets. Therfore,
\[ \text{Time complexity} = \theta (n + k + f(n) ) \]
Where, \(f(n)\) is the time complexity of the sorting algorithm and <b>k</b> is the number of buckets.
<br />
<br />
<br /></li>
<li><p>
<b>Best Case &amp; Average Case</b> : Best case for bucket sort is if elements are equally distributed. Then, all buckets will have \(n/k\) elements. The time taken to sort single bucket will become f(n/k) and the time taken to sort k buckets will be,
\[ \text{time to sort all buckets} = k \times f \left( \frac{n}{k} \right) \]
Suppose we were using insertion sort, then
\[ \text{for insertion sort} : f(n) = n^2 \]
\[ f \left( \frac{n}{k} \right) = \frac{n^2}{k^2} \]
Therefore,
\[ \text{time to sort all buckets} = \frac{n^2}{k} \]
</p>

<p>
So, total time have time added to initialize buckets and also scatter elements.
</p>

<p>
\[ \text{Time complexity} = \theta ( n + k + \frac{n^2}{k} ) \]
</p>

<p>
This is considered the time complexity for average case.
For best case, we consider the number of buckets is approximately equal to number of elements.
\[ k \approx n \]
</p>

<p>
Therefore, in best case,
\[ \text{Time complexity} = \theta (n) \]
</p></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org1f7dc44" class="outline-2">
<h2 id="org1f7dc44"><span class="section-number-2">30.</span> Dynamic Programming</h2>
<div class="outline-text-2" id="text-30">
<p>
<b>Similar to divide and conquer</b>, dynamic programming also solves problems by combining solutions of smaller sub-problems.
</p>

<p>
"Programming" in context of dynamic programming means <b>tabular method</b>, not writing code.
</p>

<p>
In divide and conquer, the subproblems don't overlap and are solved independently. Whereas, in dynamic programming <b>subproblems overlap</b>, therefore subproblems also share subproblems.
</p>

<p>
In dynamic programming, each <b>subproblem is only solved once and then its solution is stored in a table.</b>
</p>
</div>

<div id="outline-container-org70d5ed0" class="outline-3">
<h3 id="org70d5ed0"><span class="section-number-3">30.1.</span> Use and steps of dynamic programming</h3>
<div class="outline-text-3" id="text-30-1">
<p>
Dynamic programming has four steps :
</p>
<ol class="org-ol">
<li>Characterize the structure of optimal solution.</li>
<li>Recursively define the value of optimal solution.</li>
<li>Compute the value of optimal solution, typically done in bottom-up method.</li>
<li>Construct the optimal solution from computed information.</li>
</ol>
</div>
</div>

<div id="outline-container-orgdf0c3a0" class="outline-3">
<h3 id="orgdf0c3a0"><span class="section-number-3">30.2.</span> Rod cutting (Simple example for dynamic programming)</h3>
<div class="outline-text-3" id="text-30-2">
<p>
Suppose a factory buys long steel rods and cuts them into smaller steel rods, which it then sells. The cutting of rods costs no money.
</p>

<p>
The price at which the rod is sold for based on length is given in table
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">length (inches)</th>
<th scope="col" class="org-right">price</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">17</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">17</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">24</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">30</td>
</tr>
</tbody>
</table>
<p>
We are given a rod of <b>n</b> inches. We want to cut it in a way to increase the total price.
</p>

<p>
Example, if we have a 4-inch rod, we can cut it to two 2-inch rods, making total price from
\[ \text{4-inch} = 9 \]
\[ \text{2-inch} + \text{2-inch} = 5 + 5 = 10 \]
Therefore, increasing price.
</p>
</div>

<div id="outline-container-org1f49263" class="outline-4">
<h4 id="org1f49263"><span class="section-number-4">30.2.1.</span> Analyzing problem</h4>
<div class="outline-text-4" id="text-30-2-1">
<p>
If we have a rod of length \(n\), it can be cut up in \(2^{n-1}\) different ways (when we can only cut in lengths that are natural numbers).
</p>

<p>
This is because for a rod of \(n\) inches, we can decide to either cut or not cut every inch from the left end of rod.
</p>

<p>
We will show cuts using +, example,
<br />
10 = 5 + 5
<br />
means that 10 inch rod is cut into two 5 inch rods.
</p>

<p>
Now let's computete maximum revenue's \((r_i)\)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">length (\(i\))</th>
<th scope="col" class="org-right">price (\(p_i\))</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">17</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">17</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">24</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">30</td>
</tr>
</tbody>
</table>
<p>
\[ r_1 = max(p_1) \]
\[ r_2 = max(p_2, p_1 + p_1) \]
\[ r_3 = max(p_3, p_1 + p_2, p_1 + p_1 + p_1) \]
\[ r_4 = max(p_4, p_1 + p_3, p_2 + p_2, p_1 + p_1 + p_2, p_1 + p_1 + p_1 + p_1) \]
\[ ......... \]
\[ ......... \]
But <b>we don't need to examine all the combination of different cuts</b>
</p>
<ul class="org-ul">
<li>For a rod of \(n\) inches, suppose the first cut is at the \(k\) inches, then the remaining rod is \(n - k\) inches</li>
<li>The maximum revenue when first cut is at \(k\) is \(p_k + r_{n - k}\)</li>
<li>\(k\) is between \(1\) and \(n\). Therefore, the maximum revenue can be calculated using
\[ r_n = max(p_n + r_0, p_{n-1} + r_1, p_{n-2} + r_2 , ...... , p_1 + r_{n - 1}) \]
\[ r_n = max(p_i + r_{n-i} : 1 \le i \le n) \]</li>
</ul>
</div>
</div>

<div id="outline-container-orgf824955" class="outline-4">
<h4 id="orgf824955"><span class="section-number-4">30.2.2.</span> Recursive solution</h4>
<div class="outline-text-4" id="text-30-2-2">
<p>
If we don't use dynamic programming for this problem, we can use the recursive solution as
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">p is the price table, n is length of rod to cut</span><span style="color: #a0a1a7; font-weight: bold;"> */</span> 
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">cut_rod</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a626a4;">if</span>(n == 0)
    <span style="color: #a626a4;">return</span> 0;

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">q</span> = -1;
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= n; i++){
    q = max(q, p[i] + cut_rod(p, n - i));
  }
  <span style="color: #a626a4;">return</span> q;
}
</pre>
</div>
</div>

<div id="outline-container-org31f5eb2" class="outline-5">
<h5 id="org31f5eb2"><span class="section-number-5">30.2.2.1.</span> Time complexity</h5>
<div class="outline-text-5" id="text-30-2-2-1">
<p>
The time complexity can be calculated using the recursive relation
\[ T(n) = 1 + \sum_{i=1}^n T(n - i) \]
The solution to this is
\[ T(n) = 2^n \]
i.e, exponential time complexity.
</p>

<p>
The reason for time complexity being so high is that the subproblems are solved multiple times.
<br />
This can be seen in an example recursion tree for \(n = 4\).
<img src="./imgs/dynamic_rod_recursion_tree.jpg" alt="dynamic_rod_recursion_tree.jpg" />
We can see that recursive method is working in \(2^n\) time, because it checks all \(2^{n-1}\) ways to cut a rod.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc6fbeb1" class="outline-4">
<h4 id="orgc6fbeb1"><span class="section-number-4">30.2.3.</span> Dynamic Programming Solutions</h4>
<div class="outline-text-4" id="text-30-2-3">
<p>
In dynamic programming, our goal is to solve every subproblem only once. There are two ways to do this,
</p>
<ul class="org-ul">
<li>Top Down: Memoize recursive algorithm</li>
<li>Bottom Up: Figure out optimum order to fill the solution array</li>
</ul>
<p>
In dynamic programming we store the solution to subproblems thus reducing time complexity. This increases the space complexity and hence is an example of <b>time memory trade-off</b>.
</p>
</div>
</div>
<div id="outline-container-orgcc9a5d5" class="outline-4">
<h4 id="orgcc9a5d5"><span class="section-number-4">30.2.4.</span> Top Down Memoized Solution</h4>
<div class="outline-text-4" id="text-30-2-4">
<p>
This solution will simply modify the recursive solution by adding an array or hash table to store the result of subproblems. Later it can simply check if subproblem was already solved and use the already computed result.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">wrapper function which user will call</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">cut_rod_memoized</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">initially, none of the subproblems are solved</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span>[n + 1];
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt;= n; i++){
    r[i] = -1;
  }

  <span style="color: #a626a4;">return</span> cut_rod(p, n, r);
}

<span style="color: #c18401;">int</span> <span style="color: #0184bc;">cut_rod</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span>[]){
  <span style="color: #a626a4;">if</span>(n == 0)
    <span style="color: #a626a4;">return</span> 0;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if r[n] was already computed, then return that</span>
  <span style="color: #a626a4;">if</span>(r[n] != -1)
    <span style="color: #a626a4;">return</span> r[n];

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">q</span> = -1;
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= n; i++){
    q = max(q, p[i] + cut_rod(p, n - i));
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">store r[n] for future reference</span>
  r[n] = q;
  <span style="color: #a626a4;">return</span> q;
}
</pre>
</div>
<p>
Rather than changing our function, <b>we simply memoize it to avoid solving subproblems again and again</b>.
</p>
</div>
</div>
<div id="outline-container-orgb5f340b" class="outline-4">
<h4 id="orgb5f340b"><span class="section-number-4">30.2.5.</span> Bottom Up Solution</h4>
<div class="outline-text-4" id="text-30-2-5">
<p>
In this method, we will start from the <b>smallest subproblem and work towards larger problem</b>. This is why this method is called bottom up method.
</p>

<p>
The idea is that when we are working on a larger problem, the prerequisite smaller subproblems are already solved.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">botton_up_cut_rod</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span>[n + 1];
  r[0] = 0;

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= n; j++){
    q = -1;
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= j; i++){
      q = max(q, p[i] + r[j - i]);
    }
    r[j] = q;
  }

  <span style="color: #a626a4;">return</span> r[n];
}
</pre>
</div>
<ul class="org-ul">
<li>In rod cutting, calculating any \(r_n\) requires only smaller \(r_j : j < n\) to be already solved.</li>
<li>We can work our way bottom up from \(j = 1\) to \(j = n\)</li>
</ul>
</div>
</div>
<div id="outline-container-org79db5e8" class="outline-4">
<h4 id="org79db5e8"><span class="section-number-4">30.2.6.</span> Running time of Top Down and Bottom Up Solutions</h4>
<div class="outline-text-4" id="text-30-2-6">
<p>
Both top down and botton up require \(\theta (n^2)\) time.
</p>
<ul class="org-ul">
<li>Bottom up : Nested loops, the inner most statement i.e, the max(q, p[i] + r[j - i]) runs \(\frac{n(n-1)}{2}\) times</li>
<li>Top Down : Each subproblem is solved only once, subproblem of size 1 takes 1 iteration to solve. Subproblem of size 2 takes 2 iterations to solve. Similarly, subproblem of size n takes n iterations to solve. This forms the summation,
\[ \text{total number of iterations} = 1 + 2 + 3 + ... + n \]
\[ \text{total number of iterations} = \frac{n(n+1)}{2} \]</li>
</ul>
<p>
The two methods of dynamic programming are actually <b>equivalent in time complexity</b> and either can be used.
</p>

<p>
The <b>top down method does run slower</b> on actual machines <b>due to recursive procedure calls</b>.
</p>
</div>
</div>
<div id="outline-container-orge6b222d" class="outline-4">
<h4 id="orge6b222d"><span class="section-number-4">30.2.7.</span> Reconstructing a solution</h4>
<div class="outline-text-4" id="text-30-2-7">
<p>
These solutions give us the maximum revenue, but they tell about the pieces in which rod is to be cut.
</p>

<p>
It is easy to get the solution by extending the bottom up solution
</p>
<div class="org-src-container">
<pre class="src src-c">(<span style="color: #c18401;">int</span>[], <span style="color: #c18401;">int</span>[]) <span style="color: #0184bc;">botton_up_cut_rod</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span>[n + 1];
  r[0] = 0;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">s[i] is the size of first</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">piece for maximum revenue</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">in a rod of i inches</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">s</span>[n+1];
  s[0] = 0;

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= n; j++){
    q = -1;
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= j; i++){
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this if statement does the same work as</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">the max function</span>
      <span style="color: #a626a4;">if</span> ((p[i] + r[j - 1]) &gt; q) {
        q = p[i] + r[j - i];
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of first piece for rod of</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">j inches will be i inches</span>
        s[j] = i;
      }
    }
    r[j] = q;
  }

  <span style="color: #a626a4;">return</span> (r, s);
}
</pre>
</div>
<p>
Since we can get the size of first piece, we can get the size of all pieces by repeatedly chopping first piece.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">print_cut_rod_solution</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">r</span>[], <span style="color: #8b4513;">s</span>[] = botton_up_cut_rod(p,n);
  <span style="color: #a626a4;">while</span>(n &gt; 0){
    printf(<span style="color: #50a14f;">"Chopped pice of size : %d \n"</span>, s[n]);
    n = n - s[n];
  }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org28378ca" class="outline-3">
<h3 id="org28378ca"><span class="section-number-3">30.3.</span> Subproblem graph</h3>
<div class="outline-text-3" id="text-30-3">
<p>
In order to get the dynamic programming solution, we need to think about how subproblems depend on each other. The subproblem graph for a problem contains this information.
</p>
<ul class="org-ul">
<li>The subproblem graph is a directed graph</li>
<li>The vertices are used to represent the subproblems</li>
<li>A directed edge from node \(i\) to \(j\) means, the subproblem \(i\) depends on result of subproblem \(j\)</li>
</ul>
<p>
Example, for the rod cutting problem, the subproblem graph for \(n = 4\) is,
<img src="./imgs/IMG_20230926_151128.jpg" alt="IMG_20230926_151128.jpg" />
</p>
<ul class="org-ul">
<li><b>We can think of subproblem graph as the "collapsed" version of recursion tree for the problem</b></li>
</ul>
<p>
The bottom-up dynamic problem method solves subproblem in the reverse topological sort of subproblem graph
</p>
</div>
</div>
<div id="outline-container-orgf2ac9fb" class="outline-3">
<h3 id="orgf2ac9fb"><span class="section-number-3">30.4.</span> Matrix-chain multiplication</h3>
<div class="outline-text-3" id="text-30-4">
<p>
The algorithm to multiply two matrices is
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #c18401;">Matrix</span> <span style="color: #0184bc;">matrix_multiply</span>(<span style="color: #c18401;">Matrix</span> <span style="color: #8b4513;">a</span>, <span style="color: #c18401;">Matrix</span> <span style="color: #8b4513;">b</span>) {
<span class="linenr"> 2: </span>  <span style="color: #a626a4;">if</span>(a.cols != b.rows)
<span class="linenr"> 3: </span>    error(<span style="color: #50a14f;">"Incompatible dimensions"</span>);
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  <span style="color: #c18401;">Matrix</span> <span style="color: #8b4513;">c</span> = <span style="color: #a626a4;">new</span> <span style="color: #c18401;">Matrix</span>(a.rows, b.cols);
<span class="linenr"> 6: </span>  c = {0};
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; a.rows; a++)
<span class="linenr"> 9: </span>    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; b.cols; j++)
<span class="linenr">10: </span>      <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span> = 0; k &lt; a.cols; k++)
<span class="linenr">11: </span>        c[i,j] = c[i,j] + (a[i,k] * b[k,j]);
<span class="linenr">12: </span>}
</pre>
</div>
<p>
In matrix-chain multiplication, we are given a chain of matrices \(\langle A_1, A_2, A_3, ... , A_n \rangle\) and we want to compute their product \(A_1A_2A_3...A_n\)
</p>

<p>
<b>The number of times the statement at line number 11 (which does scalar multiplication) runs is</b>
\[ a.rows \times a.cols \times b.cols \]
</p>

<p>
Therefore, choosing different parenthesis can effect the number of scalar multiplications done to get final product.
<br />
<b>Example</b>, if \(\langle A_1, A_2, A_3 \rangle\) is the matrix-chain, and dimensions are \(10 \times 100\), \(100 \times 5\), and \(5 \times 50\) respectively. <i>The number scalar multiplications for :</i>
</p>
<ul class="org-ul">
<li>\(((A_1A_2)A_3)\), \(10.100.5 = 5000\) times for \(A_1A2\), and then \(10.5.50 = 2500\) times for \((A_1A_2)A_3\), so a total of \(5000 + 2500 = 7,500\) times</li>
<li>\((A_1(A_2A_3))\), \(100.5.20 = 25000\) for \(A_2A_3\), and and then \(10.100.50 = 50000\) times for \(A_1(A_2A_3)\), so a total of \(50000 + 25000 = 75,000\) times</li>
</ul>
<p>
So computing \(((A_1A_2)A_3)\) is about 10 times faster than \((A_1(A_2A_3))\) in this case.
</p>

<p>
Therefore, the matrix-chain multiplication problem is : <b>given a chain \(\langle A_1, A_2, A_3, ... , A_n \rangle\) of matrices, fully paranthesize the product \(A_1A_2A_3...A_n\) to minimize number of scalar multiplications</b>
</p>
</div>
<div id="outline-container-orga0eb72b" class="outline-4">
<h4 id="orga0eb72b"><span class="section-number-4">30.4.1.</span> Counting number of paranthesis</h4>
<div class="outline-text-4" id="text-30-4-1">
<p>
For \(n\) matrices, the number of <b>possible paranthesizations is given by \((n-1)^{th}\) Catalan number.</b>
</p>

<p>
The \(n^{th}\) catalan number is
\[ c_n = \frac{1}{n + 1} {2n \choose n} \]
Asymptotically, the catalan numbers grow as
\[ c_n ~ \frac{4^n}{n^{3/2} \pi} \]
i.e, \(O(4^n / n^{3/2})\)
<i>The number of possible paranthesizations is thus exponential of \(n\), and brute-force method is not optimal</i>
</p>

<p>
For \(n\) matrices, the function for paranthesis is
\[ P(n)=  \begin{cases} 1 & \text{, if $n=1$} \\
\sum_{k=1}^{n-1}P(k)P(n-k) & \text{, if $n \ge 2$}  \end{cases} \]
</p>
</div>
</div>
<div id="outline-container-org116b36c" class="outline-4">
<h4 id="org116b36c"><span class="section-number-4">30.4.2.</span> Solution</h4>
<div class="outline-text-4" id="text-30-4-2">
<p>
The dynamic programming method will have 4 steps similar to rod-cutting problem
</p>
</div>
<div id="outline-container-orga6831eb" class="outline-5">
<h5 id="orga6831eb"><span class="section-number-5">30.4.2.1.</span> Step 1 : Analyzing problem</h5>
<div class="outline-text-5" id="text-30-4-2-1">
<p>
We will use the notation \(A_{ij...k}\) to show product \(A_iA_j...A_k\).
The substructures are as follows:
</p>
<ul class="org-ul">
<li>Suppose for optimal paranthesization of \(A_i...A_k\), we have to get product by dividing chain by some partition \(p\), and then multiply \(A_i...A_p\) and \(A_{p+1}...A_k\)</li>
<li>Similarly, optimal paranthesizations for \(A_i...A_p\) and \(A_{p+1}...A_k\) are calculated by breaking into smaller parititions</li>
<li>At each division step, we need to consider all possible values for \(p\), since any one of them can be optimal</li>
<li>We will repeat this till chain is broken into single matrices (divde part of divide-and-conquer)</li>
</ul>
<p>
Therefore, the minimum number of scalar multiplications is given by
\[ m(i,j) = \begin{cases} 0 & \text{if $i = j$} \\
{}^{\text{min}}_{i \le p < j} \Bigl( m(i,p) + m(p + 1, j) + A_{i}.rows \times A_{p}.cols \times A_{j}.rows \Bigr) & \text{if $i < j$} \end{cases} \]
</p>
</div>
</div>
<div id="outline-container-org0414795" class="outline-5">
<h5 id="org0414795"><span class="section-number-5">30.4.2.2.</span> Step 2 : Creating recursive solution</h5>
<div class="outline-text-5" id="text-30-4-2-2">
<p>
Now we will create the recursive divide and conquer solution for the problem.
</p>

<p>
The minimum number of scalar multiplications for \(A_i...A_j\) is given by \(m(i,j)\), which is given by
\[ m(i,j) = \begin{cases} 0 & \text{if $i = j$} \\
{}^{\text{min}}_{i \le p < j} \Bigl( m(i,p) + m(p + 1, j) + A_{i}.rows \times A_{p}.cols \times A_{j}.rows \Bigr) & \text{if $i < j$} \end{cases} \]
For a chain with \(n\) matrices, we need to find \(m(1,n)\)
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">min_scalar</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">right</span>) {
  <span style="color: #a626a4;">if</span>(left &gt;= right)
    <span style="color: #a626a4;">return</span> 0;

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span> = (<span style="color: #c18401;">int</span>) INFINITY;
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span> = left; p &lt; right; p++){
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check if current partition (p) is better than previous</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">new_min</span> = min_scalar(left, p) + min_scalar(p + 1, right) +
                  (A[left].rows * A[p].cols *A[right].cols);

    <span style="color: #a626a4;">if</span>(new_min &lt; min)
      min = new_min;
  }

  <span style="color: #a626a4;">return</span> min;
}
</pre>
</div>
<p>
This algorithm will run in exponential time. Now we can use memoization for top down dynamic programming.
</p>
</div>
</div>
<div id="outline-container-orgea77a4a" class="outline-5">
<h5 id="orgea77a4a"><span class="section-number-5">30.4.2.3.</span> Step 3 : Applying dynamic programming</h5>
<div class="outline-text-5" id="text-30-4-2-3">
<p>
The <b>top down dynamic programming</b> using memoization is as follows
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[n,n] = {(<span style="color: #c18401;">int</span>) INFINITY};

<span style="color: #c18401;">int</span> <span style="color: #0184bc;">top_down_min_scalar</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">right</span>) {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if result is already calculated then use that</span>
  <span style="color: #a626a4;">if</span>(m[left,right] != INFINITY)
    <span style="color: #a626a4;">return</span> m[left,right];

  <span style="color: #a626a4;">if</span>(left &gt;= right) {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">store result in m[,]</span>
    m[left,right] = 0;
    <span style="color: #a626a4;">return</span> 0;
  }

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span> = (<span style="color: #c18401;">int</span>) INFINITY;
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span> = left; p &lt; right; p++){
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check if current partition (p) is better than previous</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">new_min</span> = min_scalar(left, p) + min_scalar(p + 1, right) +
      (A[left].rows * A[p].cols *A[right].cols);

    <span style="color: #a626a4;">if</span>(new_min &lt; min)
      min = new_min;
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">store calculated result in m[,]</span>
  m[left,right] = min;
  <span style="color: #a626a4;">return</span> min;
}
</pre>
</div>
<p>
We can also have <b>bottom up dynamic programming</b>, but for that we need to understand the subproblems graph. We can start by looking at the recursion tree. For \(n = 4\), the recursion tree will be
<img src="./imgs/Untitled-2023-09-24-1812.svg" alt="Untitled-2023-09-24-1812.svg" class="org-svg" />
In this diagram [x,y] means values [left,right] and what it calls recursively
</p>

<p>
The easiest way to get the subproblem graph from this tree is to simply use the adjacency list representation, all direct childs are in the adjacency list of the node.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8b4513;">graph</span> = {
    <span style="color: #50a14f;">"0,0"</span> : [],
    <span style="color: #50a14f;">"0,1"</span> : [<span style="color: #50a14f;">"0,0"</span>,<span style="color: #50a14f;">"1,1"</span>],
    <span style="color: #50a14f;">"0,2"</span> : [<span style="color: #50a14f;">"0,0"</span>,<span style="color: #50a14f;">"0,1"</span>,<span style="color: #50a14f;">"1,2"</span>,<span style="color: #50a14f;">"2,2"</span>],
    <span style="color: #50a14f;">"0,3"</span> : [<span style="color: #50a14f;">"0,0"</span>,<span style="color: #50a14f;">"0,1"</span>,<span style="color: #50a14f;">"0,2"</span>,<span style="color: #50a14f;">"1,3"</span>,<span style="color: #50a14f;">"2,3"</span>,<span style="color: #50a14f;">"3,3"</span>],
    <span style="color: #50a14f;">"1,1"</span> : [],
    <span style="color: #50a14f;">"1,2"</span> : [<span style="color: #50a14f;">"1,1"</span>,<span style="color: #50a14f;">"2,2"</span>],
    <span style="color: #50a14f;">"1,3"</span> : [<span style="color: #50a14f;">"1,1"</span>,<span style="color: #50a14f;">"1,2"</span>,<span style="color: #50a14f;">"2,3"</span>,<span style="color: #50a14f;">"3,3"</span>],
    <span style="color: #50a14f;">"2,2"</span> : [],
    <span style="color: #50a14f;">"2,3"</span> : [<span style="color: #50a14f;">"2,2"</span>,<span style="color: #50a14f;">"3,3"</span>],
    <span style="color: #50a14f;">"3,3"</span> : [],
}
</pre>
</div>
<p>
After topological sort, we will get the order
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8b4513;">graph</span> = {
    <span style="color: #50a14f;">"0,0"</span> : [],
    <span style="color: #50a14f;">"1,1"</span> : [],
    <span style="color: #50a14f;">"2,2"</span> : [],
    <span style="color: #50a14f;">"3,3"</span> : [],
    <span style="color: #50a14f;">"0,1"</span> : [<span style="color: #50a14f;">"0,0"</span>,<span style="color: #50a14f;">"1,1"</span>],
    <span style="color: #50a14f;">"1,2"</span> : [<span style="color: #50a14f;">"1,1"</span>,<span style="color: #50a14f;">"2,2"</span>],
    <span style="color: #50a14f;">"2,3"</span> : [<span style="color: #50a14f;">"2,2"</span>,<span style="color: #50a14f;">"3,3"</span>],
    <span style="color: #50a14f;">"0,2"</span> : [<span style="color: #50a14f;">"0,0"</span>,<span style="color: #50a14f;">"0,1"</span>,<span style="color: #50a14f;">"1,2"</span>,<span style="color: #50a14f;">"2,2"</span>],
    <span style="color: #50a14f;">"1,3"</span> : [<span style="color: #50a14f;">"1,1"</span>,<span style="color: #50a14f;">"1,2"</span>,<span style="color: #50a14f;">"2,3"</span>,<span style="color: #50a14f;">"3,3"</span>],
    <span style="color: #50a14f;">"0,3"</span> : [<span style="color: #50a14f;">"0,0"</span>,<span style="color: #50a14f;">"0,1"</span>,<span style="color: #50a14f;">"0,2"</span>,<span style="color: #50a14f;">"1,3"</span>,<span style="color: #50a14f;">"2,3"</span>,<span style="color: #50a14f;">"3,3"</span>],
}
</pre>
</div>
<p>
We can see that the order for subproblems arrange them in a pyramid like pattern.
</p>


<div id="org3367ee6" class="figure">
<p><img src="./imgs/IMG_20230928_182449.jpg" alt="IMG_20230928_182449.jpg" />
</p>
</div>

<p>
We solve subproblems from bottom layer to top of the pyramid
</p>
<ul class="org-ul">
<li>Notice how on ↗ direction diagonals have same [left,] value, and all ↖ diagonals have same [,right] value</li>
<li>The lowest level has all [i,i] values</li>
<li>These two properties can help us to quickly get the whole pyramid</li>
</ul>
<p>
Knowing this pyramid is useful because many dynamic programming problems have a similar structure
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">bottom_up_min_scalar</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span>) {
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span>[n,n] = { INFINITY };

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = n; i &gt; 0; i--){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; i; j++){
      <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">left</span> = j;
      <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">right</span> = left + (n - i);

      <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span> = left; p &lt; right; p++){
        <span style="color: #c18401;">int</span> <span style="color: #8b4513;">new_min</span> = min[left,p] + min[p+1,right]
          + A[left].rows * A[p].cols * A[right].cols;
        <span style="color: #a626a4;">if</span>(new_min &lt; min[left,right])
          min[left,right] = new_min;
      }
    }
  }

  <span style="color: #a626a4;">return</span> min[left,right];
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc18f5b3" class="outline-5">
<h5 id="orgc18f5b3"><span class="section-number-5">30.4.2.4.</span> Step 4 : Constructing a solution</h5>
<div class="outline-text-5" id="text-30-4-2-4">
<p>
Similar to rod cutting problem, we can reconstruct a solution by storing the location of optimal partition of chain. In our case, we will store the location of optimal paritition in an array sol[,].
<br />
<i>The sol[,] needs to be updated everytime we update the dynamic programming table.</i> (in step 3, dynamic programming table is m[,] for top-down and min[,] for bottom-up)
</p>

<p>
Storing sol[,] for <b>top-down implementation</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[n,n] = {(<span style="color: #c18401;">int</span>) INFINITY};
<span style="color: #c18401;">int</span> <span style="color: #8b4513;">sol</span>[n,n] = {0};

<span style="color: #c18401;">int</span> <span style="color: #0184bc;">top_down_min_scalar</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">right</span>) {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if result is already calculated then use that</span>
  <span style="color: #a626a4;">if</span>(m[left,right] != INFINITY)
    <span style="color: #a626a4;">return</span> m[left,right];

  <span style="color: #a626a4;">if</span>(left &gt;= right) {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">store result in m[,] and update sol[,]</span>
    m[left,right] = 0;
    sol[left,right] = left;
    <span style="color: #a626a4;">return</span> 0;
  }

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span> = (<span style="color: #c18401;">int</span>) INFINITY;
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span> = left; p &lt; right; p++){
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check if current partition (p) is better than previous</span>
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">new_min</span> = min_scalar(left, p) + min_scalar(p + 1, right) +
      (A[left].rows * A[p].cols *A[right].cols);

    <span style="color: #a626a4;">if</span>(new_min &lt; min){
      min = new_min;
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">since min changed, update sol[,]</span>
      sol[left,right] = p;
    }
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">store calculated result in m[,]</span>
  m[left,right] = min;
  <span style="color: #a626a4;">return</span> min;
}
</pre>
</div>
<p>
Storing sol[,] for <b>bottom-up implementation</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">bottom_up_min_scalar</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span>) {
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span>[n,n] = { INFINITY };
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sol</span>[n,n] = {0};

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = n; i &gt; 0; i--){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; i; j++){
      <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">left</span> = j;
      <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">right</span> = left + (n - i);

      <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span> = left; p &lt; right; p++){
        <span style="color: #c18401;">int</span> <span style="color: #8b4513;">new_min</span> = min[left,p] + min[p+1,right]
          + A[left].rows * A[p].cols * A[right].cols;

        <span style="color: #a626a4;">if</span>(new_min &lt; min[left,right]){
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">store min[,] and update sol[,]</span>
          min[left,right] = new_min;
          sol[left,right] = p;
        }
      }
    }
  }

  <span style="color: #a626a4;">return</span> min[left,right];
}
</pre>
</div>
<p>
<b>After we have dynamic programming table and solutions table, we can reconstruct our solution.</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">print_solution</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">min</span>[,], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sol</span>[,],
                    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">left</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">right</span>) {
  <span style="color: #a626a4;">if</span>(left &lt;= right)
    <span style="color: #a626a4;">return</span>;

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">p</span> = sol[left,right];
  printf(<span style="color: #50a14f;">"%d \n"</span>, p);
  print_solution(min, sol, left, p);
  print_solution(min, sol, p+1, right);
}
</pre>
</div>
<p>
This will print the series of partition locations, which can be used to determine the matrix multiplication order
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfd5b008" class="outline-3">
<h3 id="orgfd5b008"><span class="section-number-3">30.5.</span> Longest common subsequence</h3>
<div class="outline-text-3" id="text-30-5">
<p>
In order to get the longest subsequence, we need to first see the difference between substring and subsequence.
</p>
</div>
<div id="outline-container-org01b490d" class="outline-4">
<h4 id="org01b490d"><span class="section-number-4">30.5.1.</span> Substring vs Subsequence</h4>
<div class="outline-text-4" id="text-30-5-1">
<p>
A subsequence is a broader generalization of substrings. In substring, the matching characters are in-order and consecutive. But <b>in a subsequence, the matching characters need to be in order but not in consecutive manner.</b>
</p>

<p>
Therefore, every substring is a subsequence but not all subsequences are substrings
</p>


<div id="org0984199" class="figure">
<p><img src="./imgs/IMG_20231007_212317.jpg" alt="IMG_20231007_212317.jpg" />
</p>
</div>


<div id="orgc01dd4a" class="figure">
<p><img src="./imgs/IMG_20231007_212424.jpg" alt="IMG_20231007_212424.jpg" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcbb32b7" class="outline-4">
<h4 id="orgcbb32b7"><span class="section-number-4">30.5.2.</span> Analyzing problem</h4>
<div class="outline-text-4" id="text-30-5-2">
<p>
Suppose two strings are \(X = \langle x_1, x_2 ... x_m \rangle\) and \(Y = \langle y_1, y_2 ... y_n \rangle\).
<br />
We assume the longest subsequence is \(Z = \langle z_1, z_2 ... z_k \rangle\)
</p>
<ul class="org-ul">
<li>If \(x_m = y_n\), then \(z_k = x_m\) and the remaining \(Z_{k-1}\) is LCS of \(X_{m-1}\) and \(Y_{n-1}\)</li>
<li>If \(x_m != y_n\) then \(z_k != x_m\) and \(z_k != y_m\). The LCS of \(Z\) is either LCS of \(X\) and \(Y_{n-1}\); or it the the LCS of \(X_{m-1}\) and \(Y\), based on which one is longer</li>
<li>The LCS of with either \(X_0\) or \(Y_0\) is empty string as well</li>
</ul>
<p>
Therefore, to get the longest subsequence we will similarly store it in m[,]
</p>

<p>
Using our analysis we can say that 
</p>
<pre class="example">
	 { 0                        ; if i or j == 0
m[i,j] = { m[i-1,j-1] + 1           ; if x_i == y_j
	 { max{m[i,j-1], m[i-1,j]}  ; if x_i != y_j
</pre>
<p>
For \(X = \langle x_1, x_2 ... x_m \rangle\) and \(Y = \langle y_1, y_2 ... y_n \rangle\), we need to find m[m,n]
</p>
</div>
</div>
<div id="outline-container-org91f073b" class="outline-4">
<h4 id="org91f073b"><span class="section-number-4">30.5.3.</span> Recursive solution</h4>
<div class="outline-text-4" id="text-30-5-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i and j are sizes of X and Y respectively</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">LCS</span>(<span style="color: #c18401;">string</span> <span style="color: #8b4513;">X</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>, <span style="color: #c18401;">string</span> <span style="color: #8b4513;">Y</span>,<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span>){
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if lendth of either X or Y is zero, then LCS is 0</span>
  <span style="color: #a626a4;">if</span>(i == 0 || j == 0)
    <span style="color: #a626a4;">return</span> 0;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if last character's match,</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">the length of LCS is 1 + LCS(X[:-1], Y[:-1])</span>
  <span style="color: #a626a4;">if</span>(X[i] == Y[j])
    <span style="color: #a626a4;">return</span> LCS(X, i-1, Y, j-1) + 1;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">else it is either LCS(X[:-1],Y) or LCS(X,Y[:-1])</span>
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> max(LCS(X, i-1, Y, j), LCS(X, i, Y, j-1));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgac9fa47" class="outline-4">
<h4 id="orgac9fa47"><span class="section-number-4">30.5.4.</span> Applying Dynamic Programming</h4>
<div class="outline-text-4" id="text-30-5-4">
<p>
<b>Top-down solution</b>
</p>

<p>
We can use memoization to get top-down dynamic programming solution. As usual this is very simple since we only need to store already calculated results in an array and then return them if they are already calculated
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[X.len, Y.len] = {(<span style="color: #c18401;">int</span>) INFINITY};
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">LCS</span>(<span style="color: #c18401;">string</span> <span style="color: #8b4513;">X</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>, <span style="color: #c18401;">string</span> <span style="color: #8b4513;">Y</span>,<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span>){
  <span style="color: #a626a4;">if</span>(m[i,j] != INFINITY)
    <span style="color: #a626a4;">return</span> m[i,j];

  <span style="color: #a626a4;">if</span>(i == 0 || j == 0){
    m[i,j] = 0;
    <span style="color: #a626a4;">return</span> 0;
  }

  <span style="color: #a626a4;">if</span>(X[i] == Y[j]){
    m[i,j] = LCS(X, i-1, Y, j-1) + 1;
    <span style="color: #a626a4;">return</span> m[i,j];
  }<span style="color: #a626a4;">else</span>{
    m[i,j] = max(LCS(X, i-1, Y, j), LCS(X, i, Y, j-1));
    <span style="color: #a626a4;">return</span> m[i,j];
  }
}  
</pre>
</div>

<p>
<b>Bottom-up solution</b>
</p>

<p>
For bottom-up dynamic programming, let's consider example with \(X = \langle x_1, x_2, x_3, x_4 \rangle\) and \(Y = \langle y_1, y_2, y_3 \rangle\). We will cosider the worst case scenario, i.e, no matching characters in \(X\) and \(Y\)
</p>


<div id="org9f36e5a" class="figure">
<p><img src="./imgs/Untitled-2023-10-08-1048.excalidraw.svg" alt="Untitled-2023-10-08-1048.excalidraw.svg" class="org-svg" />
</p>
</div>

<p>
From graph, we know that after all \((i,0)\) and \((0,j)\), we need to solve in following order 
<br />
(1,1) =&gt; (1,2) =&gt; (1,3) =&gt; (1,4)
<br />
Then,
<br />
(2,1) =&gt; (2,2) =&gt; (2,3) =&gt; (2,4)
<br />
(3,1) =&gt; (3,2) =&gt; (3,3) =&gt; (3,4)
</p>

<p>
In general, we need to follow order
<br />
(1,1) =&gt; (1,2) =&gt; (1,3) &#x2026; =&gt; (1,n)
<br />
(2,1) =&gt; (2,2) =&gt; (2,3) &#x2026; =&gt; (2,n)
<br />
(3,1) =&gt; (3,2) =&gt; (3,3) &#x2026; =&gt; (3,n)
<br />
&#x2026;&#x2026;&#x2026;&#x2026;.
<br />
(m,1) =&gt; (m,2) =&gt; (m,3) &#x2026; =&gt; (m,n)
</p>

<p>
Therefore, bottom up solution is
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">LCS</span>(<span style="color: #c18401;">string</span> <span style="color: #8b4513;">X</span>, <span style="color: #c18401;">string</span> <span style="color: #8b4513;">Y</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[X.len, Y.len];
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; X.len; i++)
    m[i,0] = 0;
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; Y.len; j++)
    m[0,j] = 0;

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; X.len; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; Y.len; j++){
      <span style="color: #a626a4;">if</span>(X[i] == Y[j])
        m[i,j] = m[i-1,j-1] + 1;
      <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (m[i, j-1] &gt; m[i - 1, j])
        m[i,j] = m[i, j-1];
      <span style="color: #a626a4;">else</span>
        m[i,j] = m[i - 1, j];
    }
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf19b0e3" class="outline-4">
<h4 id="orgf19b0e3"><span class="section-number-4">30.5.5.</span> Constructing solution</h4>
<div class="outline-text-4" id="text-30-5-5">
<p>
In order to get the LCS, we are using
</p>
<pre class="example">
	   { LCS(i-1,j-1) + 1 ; if x_i == y_j
LCS(i,j) = { LCS(i, j - 1)    ; if LCS(i, j - 1).len &gt; LCS(i - 1, j).len
	   { LCS(i - 1, j)    ; if LCS(i, j - 1).len &lt; LCS(i - 1, j).len
</pre>
<ul class="org-ul">
<li>So to construct \(LCS(i,j)\), we need to store which of the following three was used to calculate the maximum length LCS</li>
<li>For cases where \(X_i == Y_j\), we also store the character which matched. This is one of the character of our matched subsequence \(Z\) (read Anlayzing problem section for more info)</li>
</ul>
<p>
So, we store solution as
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a626a4;">typedef</span> <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">solution</span> <span style="color: #c18401;">solution</span>;
<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">solution</span> {
  <span style="color: #c18401;">char</span> <span style="color: #8b4513;">matched_char</span>;
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">next_row</span>;
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">next_column</span>;
};
</pre>
</div>
</div>
<div id="outline-container-org0bc97e7" class="outline-5">
<h5 id="org0bc97e7"><span class="section-number-5">30.5.5.1.</span> Storing solution in top-down</h5>
<div class="outline-text-5" id="text-30-5-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[X.len, Y.len] = {(<span style="color: #c18401;">int</span>) INFINITY};
<span style="color: #c18401;">solution</span> <span style="color: #8b4513;">sol</span>[X.len, Y.len];
<span style="color: #c18401;">void</span> <span style="color: #0184bc;">LCS</span>(<span style="color: #c18401;">string</span> <span style="color: #8b4513;">X</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>, <span style="color: #c18401;">string</span> <span style="color: #8b4513;">Y</span>,<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span>){
  <span style="color: #a626a4;">if</span>(m[i,j] != INFINITY)
    <span style="color: #a626a4;">return</span> m[i,j];

  <span style="color: #a626a4;">if</span>(i == 0 || j == 0){
    m[i,j] = 0;
    sol[i,j] = (solution) {
      .next_row = INFINITY, .next_col = INFINITY,
      .matched_char = <span style="color: #50a14f;">'\0'</span> };
    <span style="color: #a626a4;">return</span> 0;
  }

  <span style="color: #a626a4;">if</span>(X[i] == Y[j]){
    m[i,j] = LCS(X, i-1, Y, j-1) + 1;
    sol[i,j] = (solution) { .next_row = (i - 1), .next_col = (j - 1),
                            .matched_char = X[i] };
    <span style="color: #a626a4;">return</span> m[i,j];
  }<span style="color: #a626a4;">else</span>{
    m[i - 1, j] = LCS(X, i-1, Y, j);
    m[i, j - 1] = LCS(X, i, Y, j - 1);

    <span style="color: #a626a4;">if</span>(m[i - 1, j] &gt; m[i, j - 1]){
      m[i,j] = m[i - 1, j];
      sol[i,j] = (solution) { .next_row = (i - 1), .next_col = j,
                              .matched_char = <span style="color: #50a14f;">'\0'</span> };
    }<span style="color: #a626a4;">else</span>{
      m[i,j] = m[i, j - 1];
      sol[i,j] = (solution) { .next_row = i, .next_col = (j - 1),
                              .matched_char = <span style="color: #50a14f;">'\0'</span> };
    }

    <span style="color: #a626a4;">return</span> m[i,j];
  }
}  
</pre>
</div>
</div>
</div>
<div id="outline-container-org299ed7c" class="outline-5">
<h5 id="org299ed7c"><span class="section-number-5">30.5.5.2.</span> Storing solution in bottom-up</h5>
<div class="outline-text-5" id="text-30-5-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">LCS</span>(<span style="color: #c18401;">string</span> <span style="color: #8b4513;">X</span>, <span style="color: #c18401;">string</span> <span style="color: #8b4513;">Y</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[X.len, Y.len];
  <span style="color: #c18401;">solution</span> <span style="color: #8b4513;">sol</span>[X.len, Y.len];
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; X.len; i++){
    m[i,0] = 0;
    sol[i,0] = (solution) { .next_row = INFINITY, .next_col = INFINITY,
                            .matched_char = <span style="color: #50a14f;">'\0'</span> };
  }

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; Y.len; j++){
    m[0,j] = 0;
    sol[0,j] = (solution) { .next_row = INFINITY, .next_col = INFINITY,
                            .matched_char = <span style="color: #50a14f;">'\0'</span> };
  }

  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; X.len; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 0; j &lt; Y.len; j++){
      <span style="color: #a626a4;">if</span>(X[i] == Y[j]){
        m[i,j] = m[i-1,j-1] + 1;
        sol[i,j] = (solution) { .next_row = (i - 1), .next_col = (j - 1),
                                .matched_char = X[i] };
      }<span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (m[i, j-1] &gt; m[i - 1, j]){
        m[i,j] = m[i, j-1];
        sol[i,j] = (solution) { .next_row = i, .next_col = (j - 1),
                                .matched_char = <span style="color: #50a14f;">'\0'</span> };
      }<span style="color: #a626a4;">else</span>{
        m[i,j] = m[i - 1, j];
        sol[i,j] = (solution) { .next_row = (i - 1), .next_col = j,
                                .matched_char = <span style="color: #50a14f;">'\0'</span> };
      }
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge9e660c" class="outline-5">
<h5 id="orge9e660c"><span class="section-number-5">30.5.5.3.</span> Printing solution</h5>
<div class="outline-text-5" id="text-30-5-5-3">
<p>
Now we can simply follow the stored solution to get our string
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">print_subsequence</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>) {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if having a matched char, print it</span>
  <span style="color: #a626a4;">if</span>(sol[i,j].matched_char != <span style="color: #50a14f;">'\0'</span>)
    printf(<span style="color: #50a14f;">"%c"</span>, sol[i,j].matched_char);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if not at end, print subsequence further</span>
  <span style="color: #a626a4;">if</span>(sol[i,j].next_row != INFINITY)
    print_subsequence(sol[i,j].next_row, sol[i,j].next_row);
}
</pre>
</div>
<ul class="org-ul">
<li>Note : this will print subsequence in reverse order</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org133c533" class="outline-4">
<h4 id="org133c533"><span class="section-number-4">30.5.6.</span> More compact way to store solution</h4>
<div class="outline-text-4" id="text-30-5-6">
<p>
The previous method to store solution uses three fields for each cell of sol[,] matrix. But the data can be in a more compact manner
</p>
<ul class="org-ul">
<li>We will ues a single char for each cell of sol[,]</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">char</span> <span style="color: #8b4513;">sol</span>[X.len, Y.len];
</pre>
</div>
<ul class="org-ul">
<li>If \(X_i == Y_j\), then we can store char '↖', showing that next cell is up-left in sol[,] table. The matched character will simply be \(X[i]\)</li>
<li>If \(m[i, j - 1] < m[i - 1, j]\), then we store char '←', showing that next cell is to the left of current in sol[,] table</li>
<li>If \(m[i, j - 1] > m[i - 1, j]\), then we store char '↑', showing that next cell is to the top of current in sol[,] table</li>
<li>For \(i == 0\ and\ j == 0\), we can store char '✗', showing that we are at the end</li>
</ul>
<div class="org-src-container">
<pre class="src src-c">{
  <span style="color: #a626a4;">for</span>(i == 0 or j == 0){
    m[i,j] = 0;
    sol[i,j] = <span style="color: #50a14f;">'&#10007;'</span>;
  }

  <span style="color: #a626a4;">if</span>(X[i] == Y[j]){
    m[i,j] = m[i-1,j-1] + 1;
    sol[i,j] = <span style="color: #50a14f;">'&#8598;'</span>;
  }<span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (m[i, j - 1] &lt; m[i - 1, j]){
    m[i,j] = m[i - 1, j];
    sol[i,j] = <span style="color: #50a14f;">'&#8592;'</span>;
  }<span style="color: #a626a4;">else</span>{
    m[i,j] = m[i, j - 1];
    sol[i,j] = <span style="color: #50a14f;">'&#8593;'</span>;
  }
}
</pre>
</div>

<p>
Now, we can simply print solution by simply inferring the meaning of these arrows
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">print_subsequence</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>) {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if having a matched char, print it</span>
  <span style="color: #a626a4;">if</span>(sol[i,j] == <span style="color: #50a14f;">'&#8598;'</span>)
    printf(<span style="color: #50a14f;">"%c"</span>, X[i]);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if not at end, print subsequence further</span>
  <span style="color: #a626a4;">if</span>(sol[i,j] == <span style="color: #50a14f;">'&#8592;'</span>)
    print_subsequence(i - 1, j);
  <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span>(sol[i,j] == <span style="color: #50a14f;">'&#8593;'</span>)
    print_subsequence(i, j - 1);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org90519ec" class="outline-3">
<h3 id="org90519ec"><span class="section-number-3">30.6.</span> 0/1 knapsack problem</h3>
<div class="outline-text-3" id="text-30-6">
</div>
<div id="outline-container-org72fc2f4" class="outline-4">
<h4 id="org72fc2f4"><span class="section-number-4">30.6.1.</span> Analyzing problem</h4>
<div class="outline-text-4" id="text-30-6-1">
<p>
Suppose the items are stored in struct
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">item</span> {
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">profit</span>;
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">weight</span>;
};
</pre>
</div>
<p>
and the function is
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">n is the number of items</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">W is the maximum capacity of knapsack</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">knapsack</span>(<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">item</span> <span style="color: #8b4513;">items</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">W</span>);
</pre>
</div>
<ul class="org-ul">
<li>If either number of items \(n\) is 0 or capacity of knapsack \(W\) is 0, then maximum profit is also 0</li>
<li>For each \(n^{th}\) item, we need to consider both cases in which we include and when we exclude the \(n^{th}\) item.</li>
<li>In case, \(items[n].weight > W\), we have no choice but to exclude the item</li>
</ul>
<p>
Thus the complete formula is for maximum profit m[n,W] is
\[ m[n,W] = \begin{cases} 0 & \text{,if $n = 0$ or $W = 0$}  \\ m[n - 1, W] & \text{,if $item[n].weight > W$} \\ \mathbf{max \Bigl (} m[n - 1, W]  \  \mathbf{,} \ p_n + m[n - 1, W - w_n] \mathbf{\Bigr )} & \text{,if $item[n].weight \le W$} \end{cases} \]
Here \(w_n\) is weight of \(n^{th}\) item and \(p_n\) is profit of \(n^{th}\) item
</p>
</div>
</div>
<div id="outline-container-org4638e29" class="outline-4">
<h4 id="org4638e29"><span class="section-number-4">30.6.2.</span> Recursive solution</h4>
<div class="outline-text-4" id="text-30-6-2">
<p>
The recursive solution for 0/1 knapsack is
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">W is capacity of knapsack</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">n is number of items</span>
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">knapsack</span>(<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">item</span> <span style="color: #8b4513;">items</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">W</span>) {
  <span style="color: #a626a4;">if</span>(n == 0 || W &lt;= 0)
    <span style="color: #a626a4;">return</span> 0;

  <span style="color: #a626a4;">if</span>(items[n].weight &gt; W)
    <span style="color: #a626a4;">return</span> knapsack(items, n - 1, W);
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> max( <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">exclude the item</span>
                knapsack(items, n - 1, W),
                <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">include the item</span>
                items[n].profit + knapsack(items, n - 1, W - items[n].weight));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0fef1f8" class="outline-4">
<h4 id="org0fef1f8"><span class="section-number-4">30.6.3.</span> Applying Dynamic Programming</h4>
<div class="outline-text-4" id="text-30-6-3">
<p>
<b>Top-down solution</b>
</p>

<p>
As ever, the top-down solution using memoization is going to be simpler to apply to the existing recursive solution.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[n + 1, w + 1] = {INFINITY};
<span style="color: #c18401;">int</span> <span style="color: #0184bc;">knapsack</span>(<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">item</span> <span style="color: #8b4513;">items</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">W</span>) {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">return memoized solution</span>
  <span style="color: #a626a4;">if</span>(m[n, W] != INFINITY)
    <span style="color: #a626a4;">return</span> m[n, W];

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">base cases</span>
  <span style="color: #a626a4;">if</span>(n == 0 || W &lt;= 0){
    <span style="color: #a626a4;">if</span> (W &lt; 0) W = 0;
    m[n, W] = 0;
    <span style="color: #a626a4;">return</span> m[n,W];
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if weight of n_th item is greater than capacity W</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">on_exclude</span> = knapsack(items, n - 1, W);
  <span style="color: #a626a4;">if</span>(items[n].weight &gt; W){
    m[n,W] = on_exclude;
    <span style="color: #a626a4;">return</span> m[n,W];
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">else check max on both include and excluding n_th item</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">on_include</span> = items[n].profit
    + knapsack(items, n - 1, W - items[n].weight);
  <span style="color: #a626a4;">if</span>(on_exclude &gt; on_include)
    m[n, W] = on_exclude;
  <span style="color: #a626a4;">else</span>
    m[n, W] = on_include;

  <span style="color: #a626a4;">return</span> m[n, W];
}
</pre>
</div>

<p>
<b>Bottom-up solution</b>
</p>

<p>
Using the formula for calculating any \(m[n,W]\), if we arrange all n's for row labels and al W's for column of dynamic programming table. We can see that for a cell in the table, all previous rows are calculated and that
</p>
<ul class="org-ul">
<li>For a given cell \(m[n,W]\), the cell \(m[n - 1, W]\) i.e, the cell to the top of current needs to be solved</li>
<li>For cell \(m[n,W]\), the cell \(m[n - 1, W - item[n].weight]\) needs to be solved, \(n - 1\) means row to the top but the \(W - item[n].weight\) will depend on the item. So we consider previous row is already solved.</li>
</ul>
<p>
<i>So we need to move from left-to-right and top-to-bottom if n's label row and W's label column.</i>
</p>

<p>
The traversal is done in this sequence
</p>

<p>
(1,1), (1,2), (1,3) &#x2026;. (1,W),
<br />
(2,1), (2,2), (2,3) &#x2026;. (2,W),
<br />
(3,1), (3,2), (3,3) &#x2026;. (3,W),
<br />
&#x2026;.
<br />
(n,1), (n,2), (n,3) &#x2026;. (n,W),
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">knapsack</span>(<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">item</span> <span style="color: #8b4513;">items</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">W</span>) {
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">m</span>[n+1,W+1];

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">base cases</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt;= n; i++)
    m[i,0] = 0;
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt;= W; i++)
    m[0,i] = 0;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">filling dynamic programming table</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= n; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= W; j++){
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">here i is the current element</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">and j is the current capacity</span>

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if weight of current item is greater than capacity</span>
      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">on_exclude</span> = m[i - 1, j];
      <span style="color: #a626a4;">if</span>(items[i].weight &gt; j){
        m[i,j] = on_exclude;
        <span style="color: #a626a4;">continue</span>;
      }

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">else check max on both include and excluding n_th item</span>
      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">on_include</span> = items[i].profit + m[i - 1, j - items[i].weight];
      <span style="color: #a626a4;">if</span>(on_include &gt; on _exclude)
        m[i,j] = on_include;
      <span style="color: #a626a4;">else</span>
        m[i,j] = on_exclude;
    }
  }

  <span style="color: #a626a4;">return</span> m[n, W];
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd4efe9d" class="outline-4">
<h4 id="orgd4efe9d"><span class="section-number-4">30.6.4.</span> Constructing solution</h4>
<div class="outline-text-4" id="text-30-6-4">
<p>
In order to construct solution, we will store for every calculated \(m[n,W]\) it's associated \(sol[n,W]\) which will store whether the item \(n\) was included or excluded
</p>
<ul class="org-ul">
<li>If \(m[n,W]\) has \(n\) included, then we will store \(sol[n,W]\) as \(1\)</li>
<li>If \(m[n,W]\) has \(n\) excluded, then we will store \(sol[n,W]\) as \(0\)</li>
<li>For base cases \(sol[n,W]\) (i.e, n = 0 or W = 0) we will store \(-1\)</li>
</ul>
<p>
Then the solution is printed as
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">print_solution</span>(<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">item</span> <span style="color: #8b4513;">items</span>[], <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sol</span>[],
                    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">W</span>){
  <span style="color: #a626a4;">if</span>(n == 0 || W &lt;= 0)
    <span style="color: #a626a4;">return</span>;
  printf(<span style="color: #50a14f;">"Item no : %d Included : %d \n"</span>, n, sol[n,W]);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if n was included for solution</span>
  <span style="color: #a626a4;">if</span>(sol[n,W] == 1)
    print_solution(n - 1, W - items[n].weight);
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">else n was not included for solution</span>
  <span style="color: #a626a4;">else</span>
    print_solution(n - 1, W);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org34d5e30" class="outline-3">
<h3 id="org34d5e30"><span class="section-number-3">30.7.</span> Floyd-Warshall algorithm</h3>
<div class="outline-text-3" id="text-30-7">
</div>
<div id="outline-container-orge27de99" class="outline-4">
<h4 id="orge27de99"><span class="section-number-4">30.7.1.</span> Analyzing problem</h4>
<div class="outline-text-4" id="text-30-7-1">
<p>
Suppose a graph has \(N\) nodes which are labeled \(1,2,3,...,N\). The function which tells the cost of shortest path between any two nodes \(i\) and \(j\) is \(sp(i,j,k)\) when only nodes in set \({1,2,...,k}\) are used to construct the path
</p>
<ul class="org-ul">
<li>If \(k = 0\), then the set of allowed nodes in path is \(\{ \}\), therefore the shortest path is simply given by \(sp(i,j,0) = w(i,j)\). Here, \(w(i,j)\) is weight of edge between \(i\) and \(j\) if it exists else it is \(\infty\). <b>Also \(w(i,i) = 0\).</b></li>
<li>For some arbitrary value of \(k\)
<ul class="org-ul">
<li>If shortest path from \(i\) to \(j\) does not contain node \(k\), then the shortest path cost is \(sp(i,j,k-1)\)</li>
<li>If shortest path from \(i\) to \(j\) contains the node \(k\), then the shortest path cost is \(sp(i,k,k-1) + sp(k,j,k-1)\). Because the shortest path from node \(i\) to \(j\) can be broken into two paths. One from node \(i\) to \(k\) and another from \(k\) to \(j\)</li>
</ul></li>
</ul>
<p>
Therefore the recursive funtion for cost of shortest path is
\[ sp(i,j,k) = \begin{cases} w(i,j) & \text{if $k = 0$} \\ min \Bigl \{  sp(i,j,k-1), \Bigl ( sp(i,k,k-1) + sp(k,j,k-1) \Bigr ) \Bigr \} & \text{if $k \ne 0$}  \end{cases} \]
For graph with \(N\) nodes, we want to find \(sp(i,j,N)\) for all pairs of \((i,j)\) in the graph
</p>
</div>
</div>
<div id="outline-container-org0495371" class="outline-4">
<h4 id="org0495371"><span class="section-number-4">30.7.2.</span> Recursive solution</h4>
<div class="outline-text-4" id="text-30-7-2">
<p>
The recurisve solution is given by
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">int</span> <span style="color: #0184bc;">sp</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>,<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span>,<span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span>){
  <span style="color: #a626a4;">if</span>(k == 0){
    <span style="color: #a626a4;">if</span>(i == j) <span style="color: #a626a4;">return</span> 0;
    <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">return</span> w(i,j);
  }

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp_without_k</span> = sp(i,j,k-1);
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp_with_k</span> = sp(i,k,k-1) + sp(k,j,k-1);

  <span style="color: #a626a4;">if</span>(sp_with_k &lt; sp_without_k)
    <span style="color: #a626a4;">return</span> sp_with_k;
  <span style="color: #a626a4;">else</span>
    <span style="color: #a626a4;">return</span> sp_without_k;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7ebbea7" class="outline-4">
<h4 id="org7ebbea7"><span class="section-number-4">30.7.3.</span> Dynamic Programming</h4>
<div class="outline-text-4" id="text-30-7-3">
<p>
The top-down dynamic programming will simply memoize the above recursive program.
</p>

<p>
For bottom-up dynamic programming, we can see that
</p>
<ul class="org-ul">
<li>Base case is \(k = 0\)</li>
<li>For any \(k\), \(k-1\) needs to be solved</li>
</ul>
<p>
Therefore, <b>we will solve in order \(k = 0,1,2,...,N\)</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">shortes_path</span>(){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp</span>[N+1,N+1];

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for k = 0</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= N; j++){
      sp[i,j] = w(i,j);
    }
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">all sp[i,i] should be 0</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
    sp[i,i] = 0;
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for k = 1,2,..,N</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span> = 1; k &lt;= N, k++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
      <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= N; j++){
        <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp_without_k</span> = sp[i,j,k-1];
        <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp_with_k</span> = sp[i,k,k-1] + sp[k,j,k-1];

        <span style="color: #a626a4;">if</span>(sp_with_k &lt; sp_without_k)
          sp[i,j,k] = sp_with_k;
        <span style="color: #a626a4;">else</span>
          sp[i,j,k] = sp_without_k;
      }
    }
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org27b856e" class="outline-4">
<h4 id="org27b856e"><span class="section-number-4">30.7.4.</span> Reconstructing path (solution)</h4>
<div class="outline-text-4" id="text-30-7-4">
<p>
Inorder to reconstruct the path, for every pair of node \(i\) and \(j\), we will store the node that appears just before \(j\) in the path from \(i\) to \(j\)
</p>
<ul class="org-ul">
<li>If <b>\(i = j\) or \(k = 0\)</b>, we will store <b>\(sol[i,j] = i\)</b></li>
<li>When \(k\) is some other arbitrary value
<ul class="org-ul">
<li>If <b>\(sp[i,j,k]\) does not use \(k\)</b>, then we <b>don't need to update \(sol[,]\)</b>. That is we can do \(sol[i,j] = sol[i,j]\)</li>
<li>If <b>\(sp[i,j,k]\) uses the node \(k\)</b>, we will need to update \(sol[,]\). <b>The solution is updated to \(sol[i,j] = sol[k,j]\)</b>. This is because we are now using the path between \(k\) and \(j\) for new shortest path.</li>
</ul></li>
</ul>
<p>
The example storing the \(sol[,]\) matrix is
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">shortes_path</span>(){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp</span>[N+1,N+1];
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sol</span>[N+1,N+1];

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for k = 0</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= N; j++){
      sp[i,j] = w(i,j);
      sol[i,j] = i;
    }
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">all sp[i,i] should be 0</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
    sp[i,i] = 0;
    sol[i,i] = i;
  }

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for k = 1,2,..,N</span>
  <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">k</span> = 1; k &lt;= N, k++){
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
      <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span> = 1; j &lt;= N; j++){
        <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp_without_k</span> = sp[i,j,k-1];
        <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sp_with_k</span> = sp[i,k,k-1] + sp[k,j,k-1];

        <span style="color: #a626a4;">if</span>(sp_with_k &lt; sp_without_k){
          sp[i,j,k] = sp_with_k;
          sol[i,j] = sol[k,j];
        }<span style="color: #a626a4;">else</span>{
          sp[i,j,k] = sp_without_k;
        }
      }
    }
  }
}
</pre>
</div>
<p>
The algorithm to then print the path is simple
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">print_path</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">j</span>, <span style="color: #c18401;">int</span> <span style="color: #8b4513;">sol</span>[,]){
  printf(<span style="color: #50a14f;">"%d &lt;- "</span>, j);
  <span style="color: #a626a4;">do</span>{
    printf(<span style="color: #50a14f;">"%d &lt;- "</span>, sol[i,j]);
    j = sol[i,j];
  }<span style="color: #a626a4;">while</span>(sol[i,j] != i);
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org58cd23e" class="outline-2">
<h2 id="org58cd23e"><span class="section-number-2">31.</span> Greedy algorithm</h2>
<div class="outline-text-2" id="text-31">
<p>
Greedy algorithms are algorithms that make best choice at the moment. These algorithms are usually used in optimization problems.
</p>
<ul class="org-ul">
<li>Unlike dynamic programming, were every possible combination is considered, greedy algorithms simple choose what looks the best. This means that the solution <i>may not be optimal for many problems.</i></li>
<li>The advantage is that <i>greedy algorithms have much better performance.</i></li>
<li>This does not mean that greedy algorithms never give optimal solutions. For a wide range of problems, simple greedy algorithms give the optimal solution.</li>
<li>A common trend in greedy algorithms is that all options are sorted, and then the top options are selected till limit of selections is reached</li>
</ul>
</div>
<div id="outline-container-orge471206" class="outline-3">
<h3 id="orge471206"><span class="section-number-3">31.1.</span> Activity-selection problem</h3>
<div class="outline-text-3" id="text-31-1">
<p>
Suppose for a festival, we have a single stage and a set of activities (i.e, shows and performances). For each activity, we know what they want their starting time \(s_i\) and finishing time \(f_i\).
</p>

<p>
Our goal is to get as many activities done on a single stage as possible (making this an optimization problem).
</p>
</div>
<div id="outline-container-orgea92b37" class="outline-4">
<h4 id="orgea92b37"><span class="section-number-4">31.1.1.</span> Analyzing problem</h4>
<div class="outline-text-4" id="text-31-1-1">
<p>
Since there is a single stage, we need to <b>make sure none of the selected activities collide.</b>
</p>
<ul class="org-ul">
<li>Two activities \(i\) and \(j\) are non-colliding if, either \(s_i \ge f_j\) or \(s_j \ge f_i\)</li>
</ul>
<p>
Example, let's take the example dataset
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Activity name</th>
<th scope="col" class="org-right">Start time (s)</th>
<th scope="col" class="org-right">Finish time (f)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(a_1\)</td>
<td class="org-right">5</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-left">\(a_2\)</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">\(a_3\)</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">\(a_4\)</td>
<td class="org-right">0</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">\(a_5\)</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-left">\(a_6\)</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>
<p>
We can these activities on a timeline graph
</p>


<div id="org175f070" class="figure">
<p><img src="./imgs/Untitled-2023-10-08-1356.excalidraw.svg" alt="Untitled-2023-10-08-1356.excalidraw.svg" class="org-svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-org38ce40b" class="outline-4">
<h4 id="org38ce40b"><span class="section-number-4">31.1.2.</span> Greedy solution</h4>
<div class="outline-text-4" id="text-31-1-2">
<p>
Since we want <b>to maximize the number of activities, we are greedy for activities that finish quick</b>
</p>
<ol class="org-ol">
<li>Sort activities by ascending order of finishing time.</li>
<li>Start from activity at the top
<ol class="org-ol">
<li>If activity can be selected (non-colliding with already selected activities), then select it</li>
<li>If can't be selected, leave the activity</li>
<li>Move onto the next activity in sorted list</li>
</ol></li>
<li>Repeat step 2 till we have checked every activity in list</li>
</ol>
<p>
In our example dataset, after sorting we will get
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Activity name</th>
<th scope="col" class="org-right">Start time (s)</th>
<th scope="col" class="org-right">Finish time (f)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(a_2\)</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">\(a_3\)</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">\(a_4\)</td>
<td class="org-right">0</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">\(a_5\)</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-left">\(a_1\)</td>
<td class="org-right">5</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-left">\(a_6\)</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>
<p>
Then we go through list,
</p>
<ul class="org-ul">
<li>\(a_2\) can be selected since there are no other selected activities. Selected = \((a_2)\)</li>
<li>\(a_3\) can be selected since it does not collide with \(a_2\). Selected = \((a_2, a_3)\)</li>
<li>\(a_4\) cannot be selected since it collides with \(a_2\). Selected = \((a_2, a_3)\)</li>
<li>\(a_5\) can be selected since it does not collide with either \(a_2\) or \(a_3\). Selected = \((a_2, a_3, a_5)\)</li>
<li>\(a_1\) cannot be selected, it collides with \(a_5\). Selected = \((a_2, a_3, a_5)\)</li>
<li>\(a_6\) can be selected, it does not collide with either \(a_2\),\(a_3\) or \(a_5\). Selected = \((a_2, a_3, a_5, a_6)\)</li>
</ul>
<p>
The final timeline with all selected activities is
</p>


<div id="orgd7d43e7" class="figure">
<p><img src="./imgs/Untitled-2023-10-08-13561.excalidraw.svg" alt="Untitled-2023-10-08-13561.excalidraw.svg" class="org-svg" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org34041b7" class="outline-3">
<h3 id="org34041b7"><span class="section-number-3">31.2.</span> Job Scheduling with deadlines</h3>
<div class="outline-text-3" id="text-31-2">
<p>
Suppose we are given a list of jobs with their deadlines and their profit. <b>Each job takes a unit of time</b>. We want to maximize our profits
</p>
</div>
<div id="outline-container-org04017fa" class="outline-4">
<h4 id="org04017fa"><span class="section-number-4">31.2.1.</span> Greedy algorithm</h4>
<div class="outline-text-4" id="text-31-2-1">
<p>
The algorithm <b>will use a Gantt chart</b> and works as follows
</p>
<ol class="org-ol">
<li>Sort the jobs by profit in descending order</li>
<li>Start with the first job in sorted list</li>
<li>Start looking for empty position just before deadline, and look for empty spot backwards</li>
<li>Go to the next job in sorted list and repeat step 3 till either all jobs jobs are checked or gantt chart is full</li>
</ol>
</div>
</div>
<div id="outline-container-orga6dbc32" class="outline-4">
<h4 id="orga6dbc32"><span class="section-number-4">31.2.2.</span> Worked Example</h4>
<div class="outline-text-4" id="text-31-2-2">
<p>
We will look at the problem using the example,
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Job</th>
<th scope="col" class="org-right">Deadline</th>
<th scope="col" class="org-right">Profit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">J1</td>
<td class="org-right">5</td>
<td class="org-right">200</td>
</tr>

<tr>
<td class="org-left">J2</td>
<td class="org-right">3</td>
<td class="org-right">180</td>
</tr>

<tr>
<td class="org-left">J3</td>
<td class="org-right">3</td>
<td class="org-right">190</td>
</tr>

<tr>
<td class="org-left">J4</td>
<td class="org-right">2</td>
<td class="org-right">300</td>
</tr>

<tr>
<td class="org-left">J5</td>
<td class="org-right">4</td>
<td class="org-right">120</td>
</tr>

<tr>
<td class="org-left">J6</td>
<td class="org-right">2</td>
<td class="org-right">100</td>
</tr>
</tbody>
</table>
<p>
<b>We are greedy for maximum profit, therefore we sort in descending order by profit</b>
</p>

<p>
So our table will become
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Job</th>
<th scope="col" class="org-right">Deadline</th>
<th scope="col" class="org-right">Profit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">J4</td>
<td class="org-right">2</td>
<td class="org-right">300</td>
</tr>

<tr>
<td class="org-left">J1</td>
<td class="org-right">5</td>
<td class="org-right">200</td>
</tr>

<tr>
<td class="org-left">J3</td>
<td class="org-right">3</td>
<td class="org-right">190</td>
</tr>

<tr>
<td class="org-left">J2</td>
<td class="org-right">3</td>
<td class="org-right">180</td>
</tr>

<tr>
<td class="org-left">J5</td>
<td class="org-right">4</td>
<td class="org-right">120</td>
</tr>

<tr>
<td class="org-left">J6</td>
<td class="org-right">2</td>
<td class="org-right">100</td>
</tr>
</tbody>
</table>
<p>
The maximum deadline in our example is 5
</p>

<p>
So gantt chart is
</p>
<pre class="example">
0   1   2   3   4   5
|   |   |   |   |   |
</pre>
<ul class="org-ul">
<li>We can do job J4 and have position for it before 2</li>
</ul>
<pre class="example">
0   1   2   3   4   5
|   |J4 |   |   |   |
</pre>
<ul class="org-ul">
<li>We can do job J1 and have position for it before 5</li>
</ul>
<pre class="example">
0   1   2   3   4   5
|   |J4 |   |   |J1 |
</pre>
<ul class="org-ul">
<li>We can do job J3 and have position for it before 3</li>
</ul>
<pre class="example">
0   1   2   3   4   5
|   |J4 |J3 |   |J1 |
</pre>
<ul class="org-ul">
<li>We can do job J2, the position before 3 and 2 is taken; but position before 1 is empty which we can use.</li>
</ul>
<pre class="example">
0   1   2   3   4   5
|J2 |J4 |J3 |   |J1 |
</pre>
<ul class="org-ul">
<li>We can do job J5, the position before 4 is empty</li>
</ul>
<pre class="example">
0   1   2   3   4   5
|J2 |J4 |J3 |J5 |J1 |
</pre>
<ul class="org-ul">
<li>We cannot do job J6, since it's deadline is 2 and all positions before 2 are taken</li>
</ul>

<p>
Therefore, the final schedule is 
</p>
<pre class="example">
0   1   2   3   4   5
|J2 |J4 |J3 |J5 |J1 |
</pre>
</div>
</div>
</div>
<div id="outline-container-org84cd44c" class="outline-3">
<h3 id="org84cd44c"><span class="section-number-3">31.3.</span> Fractional knapsack</h3>
<div class="outline-text-3" id="text-31-3">
<p>
In the knapsack problem, we are given items with their weights and profits. We need to fill our knapsack (which has a weight limit), in a way that we get maximum possible profit.
</p>

<p>
Knapsack problem is of two types
</p>
<ol class="org-ol">
<li>Fractional knapsack =&gt; We can take a fraction of the item in our knapsack. So taking \(1/2\) or \(1/8\) or any fraction of item</li>
<li>0/1 knapsack =&gt; We cannot take fractions of item, so we either take the item (\(1\)), or leave the item (\(0\))</li>
</ol>
<p>
The 0/1 knapsack problem is more complex and requires dynamic programming to get optimal solution
</p>

<p>
But, we can get optimal solution for fractional knapsack with greedy method
</p>
</div>
<div id="outline-container-org65a9d94" class="outline-4">
<h4 id="org65a9d94"><span class="section-number-4">31.3.1.</span> Greedy algorithm</h4>
<div class="outline-text-4" id="text-31-3-1">
<p>
The capacity of knapsack is \(W\). The weights of items are \(w_i\) and profits for each are \(p_i\)
</p>
<ol class="org-ol">
<li>Compute the value-to-weight ratio, \(\frac{p_i}{w_i}\) for each item \(i\)</li>
<li>Sort by descending value-to-weight ratio</li>
<li>Fill the items one by one, from top of list to bottom of list as many as possible</li>
<li>Once we get to a item, which we cannot take completely, we take it's fraction \(\left( \frac{\text{remaining capacity of knapsack}}{w_i} \right)\)</li>
</ol>
</div>
</div>
<div id="outline-container-org6c822f6" class="outline-4">
<h4 id="org6c822f6"><span class="section-number-4">31.3.2.</span> Worked example</h4>
<div class="outline-text-4" id="text-31-3-2">
<p>
The weight capacity of our knapsack (W) is 60. The items are
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Item</th>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-right">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">I1</td>
<td class="org-right">5</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-left">I2</td>
<td class="org-right">10</td>
<td class="org-right">40</td>
</tr>

<tr>
<td class="org-left">I3</td>
<td class="org-right">15</td>
<td class="org-right">45</td>
</tr>

<tr>
<td class="org-left">I4</td>
<td class="org-right">22</td>
<td class="org-right">77</td>
</tr>

<tr>
<td class="org-left">I5</td>
<td class="org-right">25</td>
<td class="org-right">90</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Calculate value-to-weight ratio's</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Item</th>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-right">Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">I1</td>
<td class="org-right">5</td>
<td class="org-right">30</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">I2</td>
<td class="org-right">10</td>
<td class="org-right">40</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">I3</td>
<td class="org-right">15</td>
<td class="org-right">45</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">I4</td>
<td class="org-right">22</td>
<td class="org-right">77</td>
<td class="org-right">3.5</td>
</tr>

<tr>
<td class="org-left">I5</td>
<td class="org-right">25</td>
<td class="org-right">90</td>
<td class="org-right">3.6</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Sorting by value-to-weight ratio in descending order</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Item</th>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-right">Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">I1</td>
<td class="org-right">5</td>
<td class="org-right">30</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">I2</td>
<td class="org-right">10</td>
<td class="org-right">40</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">I5</td>
<td class="org-right">25</td>
<td class="org-right">90</td>
<td class="org-right">3.6</td>
</tr>

<tr>
<td class="org-left">I4</td>
<td class="org-right">22</td>
<td class="org-right">77</td>
<td class="org-right">3.5</td>
</tr>

<tr>
<td class="org-left">I3</td>
<td class="org-right">15</td>
<td class="org-right">45</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Take as many items as possible</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Knapsack Capacity Remaining</th>
<th scope="col" class="org-left">Items in Knapsack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">60</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-right">55</td>
<td class="org-left">I1</td>
</tr>

<tr>
<td class="org-right">45</td>
<td class="org-left">I1, I2</td>
</tr>

<tr>
<td class="org-right">20</td>
<td class="org-left">I1, I2, I5</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Knapsack has remaining capcity, but the weight of next item I4 is greater than the capacity. Therefore, we will take fraction of I4</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Knapsack Capacity Remaining</th>
<th scope="col" class="org-left">Items in Knapsack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">60</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-right">55</td>
<td class="org-left">I1</td>
</tr>

<tr>
<td class="org-right">45</td>
<td class="org-left">I1, I2</td>
</tr>

<tr>
<td class="org-right">20</td>
<td class="org-left">I1, I2, I5</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-left">I1, I2, I5, \(\frac{20}{22}\) I4</td>
</tr>
</tbody>
</table>
<p>
Since items in knapsack are \(\langle I1, I2, I5, \frac{20}{22} I4\rangle\), the total profit is
</p>

<p>
\(Profit = p_1 + p_2 + p_5 + \frac{20}{22} p_4\)
</p>
</div>
</div>
</div>
<div id="outline-container-org85bcb56" class="outline-3">
<h3 id="org85bcb56"><span class="section-number-3">31.4.</span> Huffman coding</h3>
<div class="outline-text-3" id="text-31-4">
<p>
Huffman coding is used to compress information. In paritcular, it is a simple lossless algorithm to compress 8-bit ASCII values, i.e text.
</p>

<p>
On average huffman coding reduces size by half. The amount of compression that is done depends on how frequently characters appear in text.
</p>
</div>
<div id="outline-container-org7f2e639" class="outline-4">
<h4 id="org7f2e639"><span class="section-number-4">31.4.1.</span> Encoding</h4>
<div class="outline-text-4" id="text-31-4-1">
<p>
Encoding has two major steps
</p>
<ol class="org-ol">
<li>Building a Huffman tree from input</li>
<li>Traverse Huffman tree to assign codes to characters</li>
</ol>
</div>
<div id="outline-container-org00f7f9b" class="outline-5">
<h5 id="org00f7f9b"><span class="section-number-5">31.4.1.1.</span> Building Huffman tree</h5>
<div class="outline-text-5" id="text-31-4-1-1">
<ol class="org-ol">
<li>Find the frequency of all the characters that are in input (including spaces)</li>
<li>Form nodes, where each node stores the character and it's frequency</li>
<li>Put all nodes in a min-heap</li>
<li>Take two nodes from the heap and make them child of a new node.
<ul class="org-ul">
<li>The value of new node is the sum of values of it's two child nodes</li>
<li>Put this new parent node back on the heap</li>
</ul></li>
<li>Repeat step 4 till heap has a single node remaining</li>
<li>The last node in heap is the root of huffman tree</li>
</ol>

<p>
Example, the input is "duke blue devils"
</p>
<ul class="org-ul">
<li>Frequencies of characters is =&gt; e:3, d:2, u:2, l:2, []:2, k:1, b:1, v:1, i:1, s:1 ([] denotes space)</li>
<li>Form nodes and sort them according to frequency</li>
</ul>


<div id="orgfaa5ec5" class="figure">
<p><img src="./imgs/Untitled-2023-10-08-1815.excalidraw.svg" alt="Untitled-2023-10-08-1815.excalidraw.svg" class="org-svg" />
</p>
</div>

<ul class="org-ul">
<li>Group smallest pair of nodes, put them under same parent and repeat till tree is formed</li>
</ul>


<div id="org2583325" class="figure">
<p><img src="./imgs/Untitled-2023-10-08-18151.excalidraw.svg" alt="Untitled-2023-10-08-18151.excalidraw.svg" class="org-svg" />
</p>
</div>

<p>
Another example,
</p>


<div id="org01013b6" class="figure">
<p><img src="Greedy_algorithm/2023-10-08_19-42-22_screenshot.png" alt="2023-10-08_19-42-22_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org7ea8e3d" class="outline-5">
<h5 id="org7ea8e3d"><span class="section-number-5">31.4.1.2.</span> Traversing huffman tree to encode</h5>
<div class="outline-text-5" id="text-31-4-1-2">
<ol class="org-ol">
<li>Assign all left edges value of \(0\), and right edges value of \(1\)</li>
<li>Traverse down to each leaf node</li>
<li>The character at leaf node get's the encoding, of it's edges values concatnated (Note : encoding will be left-to-right when going top to down)</li>
</ol>

<div id="org652eebd" class="figure">
<p><img src="./imgs/Untitled-2023-10-08-181.excalidraw.svg" alt="Untitled-2023-10-08-181.excalidraw.svg" class="org-svg" />
</p>
</div>

<p>
The encoding is
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">e</td>
<td class="org-right">000</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">001</td>
</tr>

<tr>
<td class="org-left">u</td>
<td class="org-right">010</td>
</tr>

<tr>
<td class="org-left">l</td>
<td class="org-right">011</td>
</tr>

<tr>
<td class="org-left">[]</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-left">k</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">1100</td>
</tr>

<tr>
<td class="org-left">v</td>
<td class="org-right">1101</td>
</tr>

<tr>
<td class="org-left">i</td>
<td class="org-right">1110</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-right">1111</td>
</tr>
</tbody>
</table>
<p>
"duke blue devils" will be encoded as
\[ 001 | 010 | 101 | 000 | 100 | 1100 | 011 | 010 | 000 | 100 | 001 | 000 | 1101 | 1110 | 011 | 1111 \]
Orignal size = 128bits
<br />
Encoded size = 52bits
<br />
Compression ratio = \(\frac{128}{52}\)
</p>
</div>
</div>
</div>
<div id="outline-container-org8c3c882" class="outline-4">
<h4 id="org8c3c882"><span class="section-number-4">31.4.2.</span> Decoding</h4>
<div class="outline-text-4" id="text-31-4-2">
<p>
For decoding we will use the same huffman tree.
</p>
<ol class="org-ol">
<li>Start reading compressed message, traverse tree by matching bits of message with edge bit</li>
<li>On reaching a leaf node, we have found the corresponding character.</li>
<li>Go back to the root of the huffman tree and repeat till whole message is decoded</li>
</ol>
<p>
So we read 001 and reach 'd' in huffman tree so we know first character is 'd'.
<br />
Then we go back to root node and read 010 and know the next character is 'u'.
<br />
We repeat this till we get the orignal message.
</p>
</div>
</div>
</div>
<div id="outline-container-org51153fa" class="outline-3">
<h3 id="org51153fa"><span class="section-number-3">31.5.</span> Minimum spanning trees</h3>
<div class="outline-text-3" id="text-31-5">
<p>
The spanning tree of an undirected graph is a subgraph which is a tree that contains all of the nodes of the graph. A given graph can have multiple spanning trees.
</p>

<p>
For a weighted undirected graph, the spanning tree the sum of whose edge costs is the minimum among all possible spanning trees is called the minimum spanning tree
</p>
</div>
<div id="outline-container-orgdf5b40d" class="outline-4">
<h4 id="orgdf5b40d"><span class="section-number-4">31.5.1.</span> Kruskal's algorithm</h4>
<div class="outline-text-4" id="text-31-5-1">
<p>
This algorithm works by adding safe edges (i.e, edges which won't form a cycle) to a growing spanning tree. For a graph \(G = (V,E)\), it works as follows.
</p>

<p>
<b>Simply put</b>, the algorithm is greedy for small weight edges. It will start selecting edges from smallest weight and only leave an edge if it is causing a cycle. Example
</p>

<p>
TODO : Add images here
</p>
</div>

<div id="outline-container-org16bb0c2" class="outline-5">
<h5 id="org16bb0c2"><span class="section-number-5">31.5.1.1.</span> Algorithm</h5>
<div class="outline-text-5" id="text-31-5-1-1">
<p>
The formal algorithm is 
</p>
<ol class="org-ol">
<li>Make \(|V|\) sets, each one of these sets will contain a single vertex of the graph (we seperate all vertices into sets)</li>
<li>Sort all the edges of the graph by their weight in increasing order</li>
<li>Pick the smallest weight edge \((u,v)\) from sorted list</li>
<li>Check if node \(u\) and node \(v\) are in the same set currently</li>
<li>If they are not in the same set then merge the two sets which contain node \(u\) and \(v\)</li>
<li>Pick the next smallest weight edge \((u,v)\)</li>
<li>Repeat step 4 till only a single set is left</li>
</ol>
</div>
</div>
<div id="outline-container-orgd134609" class="outline-5">
<h5 id="orgd134609"><span class="section-number-5">31.5.1.2.</span> Pseudocode</h5>
<div class="outline-text-5" id="text-31-5-1-2">
<p>
TODO : Add image of graph from wikipedia
</p>

<p>
The edge list in sorted order is
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8b4513;">edge_list</span> = [ [<span style="color: #50a14f;">'a'</span>,<span style="color: #50a14f;">'d'</span>,5], [<span style="color: #50a14f;">'c'</span>,<span style="color: #50a14f;">'e'</span>,5], [<span style="color: #50a14f;">'d'</span>,<span style="color: #50a14f;">'f'</span>,6],
              [<span style="color: #50a14f;">'b'</span>,<span style="color: #50a14f;">'e'</span>,7], [<span style="color: #50a14f;">'a'</span>,<span style="color: #50a14f;">'b'</span>,7], [<span style="color: #50a14f;">'b'</span>,<span style="color: #50a14f;">'c'</span>,8],
              [<span style="color: #50a14f;">'f'</span>,<span style="color: #50a14f;">'e'</span>,8], [<span style="color: #50a14f;">'e'</span>,<span style="color: #50a14f;">'g'</span>,9], [<span style="color: #50a14f;">'d'</span>,<span style="color: #50a14f;">'b'</span>,9],
              [<span style="color: #50a14f;">'g'</span>,<span style="color: #50a14f;">'f'</span>,11], [<span style="color: #50a14f;">'d'</span>,<span style="color: #50a14f;">'e'</span>,15] ]
</pre>
</div>
<p>
The collection of sets, each with initially single vertex of the graph (along with helper functions to work on collection)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8b4513;">sets</span> = [[<span style="color: #50a14f;">'a'</span>], [<span style="color: #50a14f;">'b'</span>], [<span style="color: #50a14f;">'c'</span>], [<span style="color: #50a14f;">'d'</span>],
        [<span style="color: #50a14f;">'e'</span>], [<span style="color: #50a14f;">'f'</span>], [<span style="color: #50a14f;">'g'</span>]]

<span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">returns the index of set which has given node</span>
<span style="color: #a626a4;">def</span> <span style="color: #0184bc;">set_id</span>(c):
    <span style="color: #a626a4;">for</span> i <span style="color: #a626a4;">in</span> <span style="color: #e44649;">range</span>(<span style="color: #e44649;">len</span>(sets)):
        <span style="color: #a626a4;">if</span> c <span style="color: #a626a4;">in</span> i:
            <span style="color: #a626a4;">return</span> i

<span style="color: #a0a1a7; font-weight: bold;"># </span><span style="color: #a0a1a7;">merge the two sets into a single set</span>
<span style="color: #a626a4;">def</span> <span style="color: #0184bc;">merge_sets</span>(a,b):
    <span style="color: #a626a4;">for</span> element <span style="color: #a626a4;">in</span> sets[b]:
        sets[a].append(element)
    <span style="color: #a626a4;">del</span> sets[b]

</pre>
</div>
<p>
Then the kruskal's algorithm will work as follows
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8b4513;">selected_edges</span> = []

<span style="color: #a626a4;">for</span> edge <span style="color: #a626a4;">in</span> <span style="color: #8b4513;">edge_list</span>:
    set_u = set_id(edge[0])
    <span style="color: #8b4513;">set_v</span> = set_id(edge[1])
    <span style="color: #a626a4;">if</span> set_u != set_v:
        selected_edges.append(edge)
        merge_sets(set_u,set_v)

<span style="color: #e44649;">print</span>(selected_edges)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org48e5cf3" class="outline-4">
<h4 id="org48e5cf3"><span class="section-number-4">31.5.2.</span> Prim's algorithm</h4>
<div class="outline-text-4" id="text-31-5-2">
<p>
Prim's algorithm works by selecting smallest edges starting with an initial node
</p>

<p>
Unlike kruskal's algorithm, we will start with an initial node and try to reach every other node of the graph by only selecting the smallest edges
</p>
</div>
<div id="outline-container-orgee54df8" class="outline-5">
<h5 id="orgee54df8"><span class="section-number-5">31.5.2.1.</span> Algorithm</h5>
<div class="outline-text-5" id="text-31-5-2-1">
<p>
TODO : later
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org928de1f" class="outline-3">
<h3 id="org928de1f"><span class="section-number-3">31.6.</span> Single source shortest path</h3>
<div class="outline-text-3" id="text-31-6">
<p>
TODO : this is also in todo section
</p>
</div>
</div>
</div>
<div id="outline-container-org6f04cc7" class="outline-2">
<h2 id="org6f04cc7"><span class="section-number-2">32.</span> Backtracking</h2>
<div class="outline-text-2" id="text-32">
<p>
Backtracking algorithms are used for solving problems where we can verify partial solution like in constraint satisfaction problems
</p>

<p>
<b><span class="underline">Constraint Satisfaction Problems</span></b>
</p>

<p>
It is a type of problem, where each entry in the solution, or every state of the solution has to satisfy a set of constraints. Example, in sudoku every cell has the following constraints
</p>
<ul class="org-ul">
<li>The number in cell must be between 1-9</li>
<li>The number must be unique in the cell's row and column</li>
<li>The number must be unique in cell's square</li>
</ul>
<p>
Using these two constraints, it's easy to test whether a number is correctly placed. So even if we are given a parital solution, i.e, a half filled in sudoku problem, we can check if it is currently correct or not
</p>
</div>
<div id="outline-container-org0cec865" class="outline-3">
<h3 id="org0cec865"><span class="section-number-3">32.1.</span> How to backtrack</h3>
<div class="outline-text-3" id="text-32-1">
<p>
The backtracking method will think of the set of all states of solution in form of a tree
</p>
<ul class="org-ul">
<li>The root node will be the empty state, here no entries are made to the solution yet</li>
<li>Every child node has a single new guess for the correct entry from to it's parent</li>
<li>The backtracking algorithm will traverse this tree is Dept-first search (DFS) order
<ul class="org-ul">
<li>Rather than going to the deepest node for each branch of the tree, we check partial solution of each node</li>
<li>If partial solution of the node is correct, we continue to go deeper</li>
<li>Else we will abandon the branch return to the parent</li>
</ul></li>
</ul>

<p>
The general pseudocode for a backtrack algorithm is
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a626a4;">def</span> <span style="color: #0184bc;">backtrack</span>(currentNode):
  <span style="color: #50a14f; font-style: italic;">""" if partial solution is wrong, return to parent """</span>
  <span style="color: #a626a4;">if</span> (<span style="color: #a626a4;">not</span> correct(currentNode)):
    <span style="color: #a626a4;">return</span>

  <span style="color: #50a14f;">""" work on current node here</span>
<span style="color: #50a14f;">  we test if we found a solution here """</span>

  <span style="color: #50a14f;">""" go the children nodes """</span>
  <span style="color: #a626a4;">for</span> child <span style="color: #a626a4;">in</span> children(currentNode):
    backtrack(child)
</pre>
</div>
</div>
</div>
<div id="outline-container-org608bd26" class="outline-3">
<h3 id="org608bd26"><span class="section-number-3">32.2.</span> n-Queen problem</h3>
<div class="outline-text-3" id="text-32-2">
<p>
In this problem, we have to place \(n\) queens on a \(n \times n\) chessboard, such that no queen is threatening another queen
</p>
<ul class="org-ul">
<li>The root node will be an empty chessboard</li>
<li>Each \(n^{th}\) child of a node will have a queen on the \(n^{th}\) column</li>
<li>Every \(n^{th}\) depth of tree will nodes with queen till the \(n^{th}\) row</li>
</ul>
<p>
Example, for a 4-queen problem, the search for a solution happens as shown in the following diagram
</p>

<div id="orgd741bb7" class="figure">
<p><img src="Backtracking/2023-12-11_21-44-59_189khR1bWFu0Tc0TY44_vFw.png" alt="2023-12-11_21-44-59_189khR1bWFu0Tc0TY44_vFw.png" />
</p>
</div>

<p>
The program to solve n-queen problem is
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">queen</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span>) {
  <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">solved</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">current</span>[n][n] = {0};

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">row_num</span> = -1;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">a function to test that current placement of queens is correct</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO : maybe implement this, we just need to check every row, column and diagonal</span>
  <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">correct</span>();

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">backtrack</span>() {
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>correct()) <span style="color: #a626a4;">return</span>;
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we correctly placed a queen on bottom most row</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">then we have solved</span>
    <span style="color: #a626a4;">if</span> (row_num == (n - 1)) solved = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    <span style="color: #a626a4;">if</span> (solved) <span style="color: #a626a4;">return</span>;

    row_num++;
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">int</span> <span style="color: #8b4513;">col_num</span> = 0; col_num &lt; n; col_num++) {
      <span style="color: #a626a4;">if</span> (solved) <span style="color: #a626a4;">return</span>;

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">clean previous loops stuff</span>
      <span style="color: #a626a4;">if</span>(col_num != 0)
        current[row_num][col_num - 1] = 0;

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">place new queen, then recursively test</span>
      current[row_num][col_num] = 1;
      backtrack();
    }
    row_num--;
  }

  backtrack();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff549c0" class="outline-3">
<h3 id="orgff549c0"><span class="section-number-3">32.3.</span> Graph coloring problem</h3>
<div class="outline-text-3" id="text-32-3">
<p>
TODO
</p>
</div>
</div>
<div id="outline-container-org5b9dcad" class="outline-3">
<h3 id="org5b9dcad"><span class="section-number-3">32.4.</span> Hamiltonian Cylces</h3>
<div class="outline-text-3" id="text-32-4">
<p>
A hamiltonian cycle is a cycle or loop which visits every vertex of the graph exactly once and returns to starting vertex. The constraints will be as follows
</p>
<ol class="org-ol">
<li>There cannot be same node multiple times in the path</li>
<li>There must be an edge from end of the path, to the start of the path</li>
</ol>
<p>
For a graph with \(n\) nodes, the backtracking algorithm will start an with initial node in the root
</p>
<ul class="org-ul">
<li>There will be \(n\) child nodes, each of which will try adding the \(n^{th}\) node of graph to the path</li>
<li>We will go to each child and check if the path is valid, if it is not valid we will return</li>
<li>After we have a path with all nodes, we will check if it is a loop else we will return</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #c18401;">void</span> <span style="color: #0184bc;">hamiltonian</span>() {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">graph is something</span>
  graph = {};
  <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">solved</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">N is number of nodes in graph</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">path</span>[N] = {0};
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">path_len</span> = 0;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO : function to check if the path is correct</span>
  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">correct</span>();

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">backtrack</span>(){
    <span style="color: #a626a4;">if</span>(<span style="font-weight: bold;">!</span>correct()) <span style="color: #a626a4;">return</span>;
    <span style="color: #a626a4;">if</span>(path_len == N){
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if there is edge from last to first node of path then solved</span>
      <span style="color: #a626a4;">if</span>(w(path[path_len - 1], path[0]) != INFINITY)
        solved = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    }
    <span style="color: #a626a4;">if</span> (solved) <span style="color: #a626a4;">return</span>;

    path_len++;
    <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 1; i &lt;= N; i++){
      <span style="color: #a626a4;">if</span> (solved) <span style="color: #a626a4;">return</span>;
      path[path_len - 1] = i;
      backtrack();
    }
    path_len--;
  }

  backtrack();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6cdbea8" class="outline-3">
<h3 id="org6cdbea8"><span class="section-number-3">32.5.</span> Sum-of-subsets</h3>
<div class="outline-text-3" id="text-32-5">
<p>
TODO
</p>
</div>
</div>
</div>
<div id="outline-container-orge2aa9ed" class="outline-2">
<h2 id="orge2aa9ed"><span class="section-number-2">33.</span> Branch and Bound</h2>
<div class="outline-text-2" id="text-33">
<p>
Branch and Bound method is a generalization of the backtracking algorithm.
</p>
<ul class="org-ul">
<li>It can be used to solve problems where partial solutions may not tell if we are approaching the correct solution, like in optimization problems
<ul class="org-ul">
<li>That is, it can be used for problems where we can't check if a partial solution is correct</li>
</ul></li>
<li>Since we can't check partial solutions, it uses a special bounding function to know when to backtrack from current branch</li>
</ul>
<p>
Therefore, the main problem in branch and bound algorithms is using the appropriate bounding function
</p>
</div>
<div id="outline-container-orge2b53cc" class="outline-3">
<h3 id="orge2b53cc"><span class="section-number-3">33.1.</span> Travelling Salesman Problem</h3>
<div class="outline-text-3" id="text-33-1">
<p>
We are given a list of cities, and distances between each pair of cities. Our goal is to find the shortest possible route which visits every city exactly once and returns to original city
</p>

<p>
That is, we are looking for the smallest cost hamiltonian cycle in a graph
</p>
</div>
<div id="outline-container-orgbf59b4f" class="outline-4">
<h4 id="orgbf59b4f"><span class="section-number-4">33.1.1.</span> Bounding function</h4>
<div class="outline-text-4" id="text-33-1-1">
<p>
TODO
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Anmol Nawani</p>
<p class="date">Created: 2024-08-19 Mon 18:12</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
