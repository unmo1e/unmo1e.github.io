<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-04 Mon 04:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Computer Networks</title>
<meta name="author" content="Anmol Nawani" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" href="src/org.css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Computer Networks</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga25741f">1. Introduction</a>
<ul>
<li><a href="#org4f1d50f">1.1. Types of computer networks</a></li>
</ul>
</li>
<li><a href="#orgac7f597">2. Unique Identifiers of Computer Network</a>
<ul>
<li><a href="#org366f97f">2.1. Hostname</a></li>
<li><a href="#org802b8fe">2.2. IP Address</a></li>
<li><a href="#org0370024">2.3. MAC Address</a></li>
<li><a href="#orgb9bc8df">2.4. Ports</a></li>
</ul>
</li>
<li><a href="#org2f1c523">3. Network Models</a>
<ul>
<li><a href="#org84d7471">3.1. OSI Model</a>
<ul>
<li><a href="#org4f7d57b">3.1.1. Physical Layer</a></li>
<li><a href="#org1cdd19e">3.1.2. Data Link Layer (DLL)</a></li>
<li><a href="#org73fcfad">3.1.3. Network Layer</a></li>
<li><a href="#orgcbf380d">3.1.4. Transport Layer</a></li>
<li><a href="#org76249cd">3.1.5. Session Layer</a></li>
<li><a href="#orgfd824e7">3.1.6. Presentation Layer</a></li>
<li><a href="#orgcc19db5">3.1.7. Application Layer</a></li>
</ul>
</li>
<li><a href="#org6834f41">3.2. TCP/IP Model</a>
<ul>
<li><a href="#org0d8661c">3.2.1. Link layer</a></li>
<li><a href="#org038311a">3.2.2. Internet layer</a></li>
<li><a href="#org1b1fdfc">3.2.3. Transport</a></li>
<li><a href="#orgf901bba">3.2.4. Application layer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf18d222">4. Physical Layer</a>
<ul>
<li><a href="#org846ba11">4.1. Transmission Media</a>
<ul>
<li><a href="#org84a8308">4.1.1. Guided Media</a></li>
</ul>
</li>
<li><a href="#org64688c2">4.2. Data and signals</a>
<ul>
<li><a href="#orgf8678a9">4.2.1. Bandwidth and maximum data rate</a>
<ul>
<li><a href="#org8a377dd">4.2.1.1. Maximum data transfer rate for noiseless wires</a></li>
<li><a href="#orgccd82bc">4.2.1.2. Maximum data transfer rate for noisy wires</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaf8fbb8">4.3. Digital-to-digital conversion</a>
<ul>
<li><a href="#org40351d7">4.3.1. Line coding</a>
<ul>
<li><a href="#orgdc181ca">4.3.1.1. Unipolar NRZ</a></li>
<li><a href="#org9db4ec3">4.3.1.2. Polar NRZ</a></li>
<li><a href="#org523f0d7">4.3.1.3. Polar RZ</a></li>
<li><a href="#orgeaf1e28">4.3.1.4. Biphase</a></li>
<li><a href="#orgfcbe7a1">4.3.1.5. AMI and pseudoternary</a></li>
<li><a href="#orgfa63699">4.3.1.6. Summary of line codes</a></li>
</ul>
</li>
<li><a href="#org07ed68d">4.3.2. Block coding</a></li>
<li><a href="#org3332d95">4.3.3. Scrambling</a></li>
</ul>
</li>
<li><a href="#org66eb9c4">4.4. Network Topology</a>
<ul>
<li><a href="#orgeab73fb">4.4.1. Point-to-Point</a></li>
<li><a href="#org65f7065">4.4.2. Daisy chaining</a></li>
<li><a href="#orgcdaafe1">4.4.3. Mesh topology</a></li>
<li><a href="#org41ca6ff">4.4.4. Star topology</a></li>
<li><a href="#org170bd6d">4.4.5. Bus topology</a></li>
<li><a href="#org962b884">4.4.6. Ring topology</a></li>
<li><a href="#org4f27c93">4.4.7. Tree topology</a></li>
<li><a href="#orge209a16">4.4.8. Hybrid topology</a></li>
</ul>
</li>
<li><a href="#org67b09dd">4.5. Switching</a>
<ul>
<li><a href="#org842334b">4.5.1. Circuit switching</a></li>
<li><a href="#orgc222e44">4.5.2. Packet switching</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7e8beb3">5. Data Link Layer</a>
<ul>
<li><a href="#org58d1865">5.1. Services Provided to Network Layer</a></li>
<li><a href="#orgafa0b98">5.2. Framing</a>
<ul>
<li><a href="#orgab2e93d">5.2.1. Use of framing</a></li>
<li><a href="#orgb86a60b">5.2.2. How framing is done</a>
<ul>
<li><a href="#org4fe1e5f">5.2.2.1. Byte count</a></li>
<li><a href="#orgc445c47">5.2.2.2. Flag byte</a></li>
<li><a href="#orgc7710f9">5.2.2.3. Byte stuffing</a></li>
<li><a href="#org7c9ea16">5.2.2.4. Bit stuffing</a></li>
<li><a href="#orgbe21243">5.2.2.5. Physical layer coding violations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf3b57bd">5.3. Error Control</a>
<ul>
<li><a href="#orgd09dcdf">5.3.1. Using Acknowledgements</a></li>
<li><a href="#org0a4806c">5.3.2. Lost frames</a></li>
<li><a href="#orgea07dc9">5.3.3. Retransmission of lost frames</a></li>
</ul>
</li>
<li><a href="#org8fd589f">5.4. Error detection and correction</a>
<ul>
<li>
<ul>
<li><a href="#org52a0d6c">5.4.0.1. Which method to use</a></li>
<li><a href="#org2e0b88d">5.4.0.2. Types of errors in channel</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7e195a9">5.5. Codewords and Code rate</a>
<ul>
<li><a href="#org01bb3da">5.5.1. Hamming distance</a></li>
<li><a href="#org440e101">5.5.2. Use of hamming distance</a></li>
</ul>
</li>
<li><a href="#org96075ce">5.6. Error-Correcting codes</a>
<ul>
<li><a href="#org5699270">5.6.1. Hamming code</a>
<ul>
<li><a href="#org0a404c7">5.6.1.1. Creating hamming codeword</a></li>
<li><a href="#orgd73018b">5.6.1.2. Error detection and correction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org57922cb">5.7. Error-Detecting codes</a>
<ul>
<li><a href="#orgeda17f8">5.7.1. Parity</a>
<ul>
<li><a href="#org5bb93a9">5.7.1.1. Vertical Redundancy Check (VRC)</a></li>
<li><a href="#org8c113e2">5.7.1.2. Longitudinal Redundancy Check (LRC)</a></li>
</ul>
</li>
<li><a href="#orgf444763">5.7.2. Checksum</a></li>
<li><a href="#orgf606983">5.7.3. Cyclic Redundancy Checks</a>
<ul>
<li><a href="#orgf5065db">5.7.3.1. Generator polynomial</a></li>
<li><a href="#org032336a">5.7.3.2. Data append bits</a></li>
<li><a href="#orgfc63b62">5.7.3.3. Getting redundant bits</a></li>
<li><a href="#orgb14c606">5.7.3.4. Transmitted data</a></li>
<li><a href="#orga25a962">5.7.3.5. On receiver's side</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbdcf06b">5.8. Flow control : Stop-and-wait ARQ</a>
<ul>
<li><a href="#org468fa66">5.8.1. Flow Control : Stop-and-Wait</a></li>
<li><a href="#orgad1b46b">5.8.2. Error Correction : Sequence Numbers and ARQ</a></li>
</ul>
</li>
<li><a href="#orga917c03">5.9. Improving Efficiency</a>
<ul>
<li><a href="#orgbf49fa9">5.9.1. Bidirectional Transmission : Piggybacking</a>
<ul>
<li><a href="#org0f8fa57">5.9.1.1. Piggybacking</a></li>
<li><a href="#org5ece4c4">5.9.1.2. Advantages of piggybacking</a></li>
<li><a href="#org6670b52">5.9.1.3. Problem with piggybacking (and it's solution)</a></li>
</ul>
</li>
<li><a href="#org80d603e">5.9.2. Multiple frames at a time : Sliding Windows</a>
<ul>
<li><a href="#org2d62ac1">5.9.2.1. On sender's side</a></li>
<li><a href="#orgbe2450b">5.9.2.2. On receiver's side</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0a2860d">5.10. Sliding Windows</a>
<ul>
<li><a href="#org2edc59c">5.10.1. Properties of sliding window protocols</a>
<ul>
<li><a href="#org378051f">5.10.1.1. Bandwidth-Delay Product</a></li>
<li><a href="#org88ab20c">5.10.1.2. Optimal/Maximum Window Size</a></li>
<li><a href="#org7af1c72">5.10.1.3. Pipelining</a></li>
</ul>
</li>
<li><a href="#org2adec44">5.10.2. One-Bit Sliding Window (Stop-and-Wait ARQ)</a></li>
<li><a href="#orgbe9c1bc">5.10.3. Go-Back-N ARQ</a></li>
<li><a href="#org9ec71b4">5.10.4. Selective Repeat ARQ</a></li>
<li><a href="#org419c99c">5.10.5. Properties of Go-Back-N and Selective Repeat</a>
<ul>
<li><a href="#orgc819bcf">5.10.5.1. Cumulative ACK vs Independent ACK</a></li>
<li><a href="#org68f4e64">5.10.5.2. Relation between sequence numbers and window sizes</a></li>
<li><a href="#orgb654ee5">5.10.5.3. Negetive ACK (NAK)</a></li>
<li><a href="#orgaf7a369">5.10.5.4. Efficiency</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org991dd62">6. Medium Access Control Sublayer</a>
<ul>
<li><a href="#org8269377">6.1. Multiple Access Protocols</a>
<ul>
<li><a href="#orgd79553e">6.1.1. ALOHA</a>
<ul>
<li><a href="#orgd153355">6.1.1.1. Pure ALOHA</a></li>
<li><a href="#org805ed5e">6.1.1.2. Slotted ALOHA</a></li>
</ul>
</li>
<li><a href="#org0315f7f">6.1.2. Carrier Sense Multiple Access Protocols (CSMA/CD)</a>
<ul>
<li><a href="#org7c082f7">6.1.2.1. Minimum frame size for CSMA and Efficiency, Throughput</a></li>
</ul>
</li>
<li><a href="#orgd0f15a6">6.1.3. CSMA with Collision Avoidance (CSMA/CA)</a>
<ul>
<li><a href="#org46b0e78">6.1.3.1. Contention window / Contention slots</a></li>
</ul>
</li>
<li><a href="#org4dc10d6">6.1.4. Reservation</a></li>
<li><a href="#org132e331">6.1.5. Polling</a>
<ul>
<li><a href="#orgc7138f2">6.1.5.1. Poll</a></li>
<li><a href="#org62f6646">6.1.5.2. Select</a></li>
<li><a href="#orga20a960">6.1.5.3. Efficiency</a></li>
</ul>
</li>
<li><a href="#org0889888">6.1.6. Token Passing</a></li>
</ul>
</li>
<li><a href="#org8b9d90a">6.2. Ethernet</a>
<ul>
<li><a href="#org814a0ad">6.2.1. Standard Ethernet : MAC sublayer</a>
<ul>
<li><a href="#org1ea90c5">6.2.1.1. Frame Format</a></li>
<li><a href="#org5f408b2">6.2.1.2. Addressing</a></li>
<li><a href="#orgd756e8a">6.2.1.3. Access method : CSMA/CD</a></li>
</ul>
</li>
<li><a href="#org725e4dd">6.2.2. Standard Ethernet : Physical Layer</a>
<ul>
<li><a href="#org71e44fb">6.2.2.1. 10Base5 : Thick Ethernet</a></li>
<li><a href="#org85a43b1">6.2.2.2. 10Base2 : Thin Ethernet</a></li>
<li><a href="#org20f727b">6.2.2.3. 10Base-T : Twisted-Pair Ethernet</a></li>
<li><a href="#org9ce8fb9">6.2.2.4. 10Base-F : Fiber Ethernet</a></li>
</ul>
</li>
<li><a href="#orgb9b9f97">6.2.3. Switched Ethernet / Bridged Ethernet</a>
<ul>
<li><a href="#org2697327">6.2.3.1. Bridges</a></li>
<li><a href="#org3216677">6.2.3.2. Using N-port bridge</a></li>
<li><a href="#org8d9aa8e">6.2.3.3. Full-duplex switched ethernet</a></li>
</ul>
</li>
<li><a href="#org0f87460">6.2.4. Fast Ethernet</a>
<ul>
<li><a href="#org99415e1">6.2.4.1. Implementations of Fast Ethernet</a></li>
</ul>
</li>
<li><a href="#orgf943f16">6.2.5. Gigabit Ethernet</a>
<ul>
<li><a href="#org7435eb2">6.2.5.1. MAC sublayer</a></li>
<li><a href="#orgffc402e">6.2.5.2. Implementations of Gigabit Ethernet</a></li>
</ul>
</li>
<li><a href="#org3ee3c67">6.2.6. Ten-Gigabit Ethernet</a></li>
</ul>
</li>
<li><a href="#org41b5e39">6.3. Connecting devices</a>
<ul>
<li><a href="#org6d1c7ff">6.3.1. Passive Hubs</a></li>
<li><a href="#org6e18b61">6.3.2. Repeaters and Active Hubs</a></li>
<li><a href="#orgbd18162">6.3.3. Bridges</a></li>
<li><a href="#org65f4a0e">6.3.4. Transparent Bridges</a>
<ul>
<li><a href="#orgdcd8436">6.3.4.1. Learning</a></li>
<li><a href="#org407fb1f">6.3.4.2. Avoiding Loops</a></li>
</ul>
</li>
<li><a href="#org6cc420b">6.3.5. Switches</a></li>
<li><a href="#orgb36caf8">6.3.6. Routers (Three-layer switches)</a></li>
<li><a href="#orgd747d18">6.3.7. Gateway</a></li>
</ul>
</li>
<li><a href="#org07d4def">6.4. Backbone networks and Virtual LANs</a>
<ul>
<li><a href="#orgf12159e">6.4.1. Backbone networks</a>
<ul>
<li><a href="#orgf8882e7">6.4.1.1. Bus backbone</a></li>
<li><a href="#org035c125">6.4.1.2. Star backbone</a></li>
<li><a href="#org89a890e">6.4.1.3. Connecting remote LANs</a></li>
</ul>
</li>
<li><a href="#org02ad145">6.4.2. Virtual LANs</a>
<ul>
<li><a href="#org63d2669">6.4.2.1. Membership in VLANs</a></li>
<li><a href="#orgcb50e0d">6.4.2.2. Configuration</a></li>
<li><a href="#org6121b22">6.4.2.3. Communication between switches</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbc63c24">7. Network Layer</a>
<ul>
<li><a href="#org6cead4f">7.1. IPv4 Address</a>
<ul>
<li><a href="#org72a2df0">7.1.1. Address Space</a></li>
<li><a href="#orgc192c73">7.1.2. Notation</a></li>
<li><a href="#orgdd3bb61">7.1.3. Classful addressing</a>
<ul>
<li><a href="#org6a72f50">7.1.3.1. Network ID and Host ID</a></li>
<li><a href="#orgcef158e">7.1.3.2. Mask</a></li>
<li><a href="#orgb05e2ef">7.1.3.3. Supernetting</a></li>
</ul>
</li>
<li><a href="#org47a1c58">7.1.4. Classless addressing</a>
<ul>
<li><a href="#org3d8b8d6">7.1.4.1. Mask (CIDR notaion)</a></li>
<li><a href="#org72d0225">7.1.4.2. First and last address of block</a></li>
<li><a href="#org2aecacd">7.1.4.3. Hierarchy in IP addresses</a></li>
</ul>
</li>
<li><a href="#org07a054c">7.1.5. Network Address Translation (NAT)</a>
<ul>
<li><a href="#orgcf28ef9">7.1.5.1. Address translation</a></li>
<li><a href="#org2d4625a">7.1.5.2. Translation table</a></li>
<li><a href="#orge976dcf">7.1.5.3. Usuage of NAT by ISPs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org108ca2f">7.2. IPv6 Addresses</a>
<ul>
<li><a href="#org5365b49">7.2.1. Notation</a>
<ul>
<li><a href="#orgd4ab684">7.2.1.1. Abbriviating notation</a></li>
</ul>
</li>
<li><a href="#org523a257">7.2.2. Address Space</a>
<ul>
<li><a href="#org799c08e">7.2.2.1. Unicast address</a></li>
<li><a href="#org7fc15f2">7.2.2.2. Multicast addresses</a></li>
<li><a href="#org2f6108c">7.2.2.3. Anycast addresses</a></li>
<li><a href="#org71bdb39">7.2.2.4. Reserved addresses</a></li>
<li><a href="#orgef1ed41">7.2.2.5. Local addresses</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2f0ef81">7.3. The Internet Protocol</a>
<ul>
<li><a href="#org115a3e5">7.3.1. IPv4</a>
<ul>
<li><a href="#orge0e1623">7.3.1.1. Datagram format</a></li>
<li><a href="#org792bf82">7.3.1.2. Fragmentation</a></li>
</ul>
</li>
<li><a href="#orgef3c990">7.3.2. IPv6</a>
<ul>
<li><a href="#orgdfea950">7.3.2.1. Packet format</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge81c1df">7.4. Address Mapping</a>
<ul>
<li><a href="#org521e640">7.4.1. Mapping Logical to Physical Address : ARP</a>
<ul>
<li><a href="#org2d4a2f1">7.4.1.1. Cache memory</a></li>
<li><a href="#orgaad5ff9">7.4.1.2. Packet Format</a></li>
<li><a href="#org5aa5fe6">7.4.1.3. Proxy ARP</a></li>
</ul>
</li>
<li><a href="#org09dce48">7.4.2. Mapping Physical to Logical Address : BOOTP and DHCP</a>
<ul>
<li><a href="#org18fb2fa">7.4.2.1. BOOTP</a></li>
<li><a href="#orgd4f0175">7.4.2.2. DHCP</a></li>
</ul>
</li>
<li><a href="#orgf031f47">7.4.3. ICMP</a>
<ul>
<li><a href="#org39fbf11">7.4.3.1. Types of messages</a></li>
<li><a href="#orgd11a400">7.4.3.2. Message format</a></li>
<li><a href="#orgb514932">7.4.3.3. Error reporting</a></li>
<li><a href="#org894ec85">7.4.3.4. Query messages</a></li>
</ul>
</li>
<li><a href="#orgf632871">7.4.4. ICMPv6</a>
<ul>
<li><a href="#org05960a3">7.4.4.1. Error messages</a></li>
<li><a href="#orgce1e901">7.4.4.2. Query messages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgec4599a">7.5. Delivery</a></li>
<li><a href="#org5e105fb">7.6. Forwarding</a>
<ul>
<li><a href="#orge6efbda">7.6.1. Forwarding Techniques</a>
<ul>
<li><a href="#orgb12bc0d">7.6.1.1. Next-Hop method vs Route Method</a></li>
<li><a href="#orgba38b6f">7.6.1.2. Network-specific method vs Host-specific method</a></li>
<li><a href="#org2bf81af">7.6.1.3. Default method</a></li>
</ul>
</li>
<li><a href="#org971f801">7.6.2. Forwarding Process</a>
<ul>
<li><a href="#org51842f5">7.6.2.1. Address Aggregation</a></li>
<li><a href="#orgeeb9ad6">7.6.2.2. Longest Mask Matching</a></li>
<li><a href="#orge9907d9">7.6.2.3. Hierarchical Routing</a></li>
</ul>
</li>
<li><a href="#org9061114">7.6.3. Routing Table</a>
<ul>
<li><a href="#org4ae17fa">7.6.3.1. Format of routing table</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge9f804a">7.7. Unicast Routing protocols</a>
<ul>
<li><a href="#orgd5cd5c4">7.7.1. Intra- and Interdomain Routing</a></li>
<li><a href="#orgec8b403">7.7.2. Distance Vector Routing</a>
<ul>
<li><a href="#org40f4625">7.7.2.1. When to share</a></li>
<li><a href="#org5277bea">7.7.2.2. Instability</a></li>
<li><a href="#org9aa57bf">7.7.2.3. RIP</a></li>
</ul>
</li>
<li><a href="#orgbc71ea9">7.7.3. Link State Routing</a>
<ul>
<li><a href="#orga5b36eb">7.7.3.1. Link State Packet (LSP)</a></li>
<li><a href="#orgf5d79fa">7.7.3.2. Formation of shortest path tree</a></li>
<li><a href="#orgf7b55f8">7.7.3.3. OSPF</a></li>
</ul>
</li>
<li><a href="#orga72bfbc">7.7.4. Path Vector Routing</a>
<ul>
<li><a href="#orgf0b87fe">7.7.4.1. Border Gateway Protocol (BGP)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org51afdec">8. Transport Layer</a>
<ul>
<li><a href="#org2cd0deb">8.1. Client/Server Paradigm</a>
<ul>
<li><a href="#orgc9dec6c">8.1.1. Addressing</a>
<ul>
<li><a href="#org0a2de9e">8.1.1.1. IANA Ranges</a></li>
<li><a href="#orgcdc4206">8.1.1.2. Socket Addresses</a></li>
</ul>
</li>
<li><a href="#orgdcfc513">8.1.2. Multiplexing and Demultiplexing</a></li>
<li><a href="#org1f0a694">8.1.3. Connectionless vs Connection-Oriented service</a></li>
<li><a href="#org186c10d">8.1.4. Reliable vs Unreliable</a>
<ul>
<li><a href="#org40b08e6">8.1.4.1. Why have reliability on transport layer?</a></li>
</ul>
</li>
<li><a href="#org6cd7d14">8.1.5. Three Protocols</a></li>
</ul>
</li>
<li><a href="#orgd476ee4">8.2. User Datagram Protocol (UDP)</a>
<ul>
<li><a href="#orgde3e7c5">8.2.1. Well-known ports of UDP</a></li>
<li><a href="#orgfd030e2">8.2.2. User Datagram</a></li>
<li><a href="#org8c2223b">8.2.3. Checksum</a></li>
<li><a href="#org5b86335">8.2.4. UDP Operation</a></li>
<li><a href="#orga449c55">8.2.5. Use of UDP</a></li>
</ul>
</li>
<li><a href="#org708bc96">8.3. Transmission Control Protocol (TCP)</a>
<ul>
<li><a href="#org2841c40">8.3.1. Well-known ports of TCP</a></li>
<li><a href="#org8b9659d">8.3.2. Stream Delivery Service</a></li>
<li><a href="#orgf572ecb">8.3.3. Features</a>
<ul>
<li><a href="#org750aec3">8.3.3.1. Numbering System</a></li>
<li><a href="#orgfdf86d2">8.3.3.2. Flow Control</a></li>
<li><a href="#org5528c70">8.3.3.3. Error Control</a></li>
<li><a href="#org2c8161b">8.3.3.4. Congestion Control</a></li>
</ul>
</li>
<li><a href="#orga6f1558">8.3.4. Segment</a></li>
<li><a href="#org703e9c6">8.3.5. TCP Connection</a>
<ul>
<li><a href="#org40174e2">8.3.5.1. Connection Establishment</a></li>
<li><a href="#orgfd962dc">8.3.5.2. Data transfer</a></li>
<li><a href="#org4bbdcd1">8.3.5.3. Connection termination</a></li>
</ul>
</li>
<li><a href="#org2d6636d">8.3.6. Flow Control</a></li>
<li><a href="#org1d4e8ef">8.3.7. Error Control</a>
<ul>
<li><a href="#org9320b90">8.3.7.1. Checksum</a></li>
<li><a href="#orgda8496c">8.3.7.2. Acknowledgement</a></li>
<li><a href="#orgf5f4397">8.3.7.3. Out-of-order segments</a></li>
<li><a href="#org900d60c">8.3.7.4. Retransmission</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<hr />
</p>
<div id="outline-container-orga25741f" class="outline-2">
<h2 id="orga25741f"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
A computer network is collection of two or more computers that can communicate with each other.
</p>

<p>
Computer networks have two basic building blocks
</p>
<ol class="org-ol">
<li><b>Nodes</b> : these are devices that are connected to the network. They can either be network redistribution points or communication endpoints. Example of nodes are computers, routers, switches and other devices on the network.</li>
<li><b>Links</b> : these are the connections between nodes. It includes the type of connectivity (wired or wireless) and the protocols that are used for communication between the nodes.</li>
</ol>
<p>
Computer networks are made of protocols which allow us to send data through links between nodes.
</p>
</div>
<div id="outline-container-org4f1d50f" class="outline-3">
<h3 id="org4f1d50f"><span class="section-number-3">1.1.</span> Types of computer networks</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Computer networks can fall under two broad categories
</p>
<ol class="org-ol">
<li><b>Client-Server Architecture</b> : in this architecture a communicating node can either be a server or a client. The client sends requests to the server, the server fulfills that request and sends a response. There are multiple clients connected to the same server.</li>
<li><b>Peer-to-Peer</b> : in this architecture there is no central server, tasks are divided amongst the nodes. Each node has the same set of capabilities and responsibilities.</li>
</ol>
<p>
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-orgac7f597" class="outline-2">
<h2 id="orgac7f597"><span class="section-number-2">2.</span> Unique Identifiers of Computer Network</h2>
<div class="outline-text-2" id="text-2">
<p>
In order to establish communication between two nodes, we need to identify the nodes. This is done by using unique identifiers given to devices on a network.
</p>
</div>
<div id="outline-container-org366f97f" class="outline-3">
<h3 id="org366f97f"><span class="section-number-3">2.1.</span> Hostname</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A hostname is a human readable label that is assigned to a device on the network. On the internet, a hostname is a domain name which has been assigned to a host computer. It is useful to identify devices on a local network.
</p>
</div>
</div>
<div id="outline-container-org802b8fe" class="outline-3">
<h3 id="org802b8fe"><span class="section-number-3">2.2.</span> IP Address</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Also known as the logical address, every device to which a direct communication can be established will have a unique IP address. Interned Assigned Numbers Authority (IANA) assigns and manages ip addresses globally. Previously, ipv4 (version 4) was used and was an address of 32 bits, hence there are \(2^{32}\) unique ipv4 addresses. Because there are limited number of ipv4 addresses, we are running out of them. A new version of ip addresses ipv6 is now implemented. It has addresses of size 128 bits.
</p>
</div>
</div>
<div id="outline-container-org0370024" class="outline-3">
<h3 id="org0370024"><span class="section-number-3">2.3.</span> MAC Address</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Stands for Media Access Control Address. It is also known as the physical address. Every Network Interface Card (NIC) is assigned a unique identifier. These are assigned by the manufacturer and cannot be changed. The length of a MAC address is 48 bits.
<hr />
</p>
</div>
</div>
<div id="outline-container-orgb9bc8df" class="outline-3">
<h3 id="orgb9bc8df"><span class="section-number-3">2.4.</span> Ports</h3>
<div class="outline-text-3" id="text-2-4">
<p>
A single system has multiple connections and network applications running. A port is a logical channel through which data can be sent or recieved. A port number is always associated with a network address such as an IP address so that we can identify the device whose port was referenced. The unique combination of ip address and port number together is called a <b>socket</b>, example 192.168.0.1:8000
<br />
The ip address and port number are seperated by a colon (:)
</p>

<p>
The ports are divided into three categories.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Port Type</th>
<th scope="col" class="org-left">Range</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Well known ports</td>
<td class="org-left">0 - 1023</td>
</tr>

<tr>
<td class="org-left">Registered ports</td>
<td class="org-left">1024 - 49151</td>
</tr>

<tr>
<td class="org-left">Dynamic ports</td>
<td class="org-left">49152 - 65535</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>The ports from 0 through 1023 are called well-known ports or system ports. They are used by system processes to provide widely used network services. Example, port 20 is for FTP and 80 is for HTTP.</li>

<li>Ports in the range from 1024 to 49151 are user or registered ports. These ports can be freely used by the user. Unlike system ports, most OS will allow applications to use these ports without superuser privelages.</li>

<li>Ports in range 49152 to 65535 are dynamic ports or private ports. They are also called ephemeral ports, because they are used for very short period of time. The TCP, UDP and SCTP typically use ephemeral port for client end of communication. The allocation of ephemeral port is temporary and only valid for short duration of communication session.</li>
</ul>

<p>
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org2f1c523" class="outline-2">
<h2 id="org2f1c523"><span class="section-number-2">3.</span> Network Models</h2>
<div class="outline-text-2" id="text-3">
<p>
A network model defines a way to organize a system's functions and features. It also defines it's structure and protocols.
</p>

<p>
In order to assign functionality to different parts of a network, these models are organized into layered structure. Each layer has a set of functions to perform. Protocols are created to handle functions in each layer. So each layer will have it's own collection of protocols which is called a <i>protocol suite</i>.
</p>

<p>
There are a few guiding principles for creating layers in a network model, such as
</p>
<ul class="org-ul">
<li>Not creating too many layers, as it may lead to unneccessary complexity.</li>
<li>Reduce the number of interactions between the layers</li>
<li>Collect similar functions and seperating fundamentally different functions in different layers</li>
<li>Indentify whether the function of layer is based on hardware or software.</li>
</ul>

<p>
Lower layers are linked with hardware whereas, the upper layers are linked with software.
</p>

<p>
There have been many network models, many of them are no longer used. IBM's SNA model, Apple's AppleTalk and IPX/SPX model are all no longer in use. They were phased out by the popular and most commonly used model today, the TCP/IP model.
<hr />
</p>
</div>
<div id="outline-container-org84d7471" class="outline-3">
<h3 id="org84d7471"><span class="section-number-3">3.1.</span> OSI Model</h3>
<div class="outline-text-3" id="text-3-1">

<div id="org98bef42" class="figure">
<p><img src="Network_Models/2023-12-03_16-54-07_Screenshot 2023-12-03 165347.png" alt="2023-12-03_16-54-07_Screenshot 2023-12-03 165347.png" />
</p>
</div>

<p>
The OSI model is used as a reference model. This means that it is used to provide building blocks for other network models and compare other network models to improve connectivity and consistency.
</p>

<p>
The OSI model has 7 layers. Each layer has different functionality. The principles applied for the 7 layers are
</p>
<ol class="org-ol">
<li>A layer should be created where a different abstraction is needed</li>
<li>Each layer should should perform a well-defined function</li>
<li>The function for each layer should be chosen with eye toward defining an internationally standardized protocols</li>
<li>Minimize the information flow across layer boundries</li>
<li>The number of layers should be large enough that distinct functions need not be in same layer, but small enough that architecture is not unwieldy</li>
</ol>
</div>
<div id="outline-container-org4f7d57b" class="outline-4">
<h4 id="org4f7d57b"><span class="section-number-4">3.1.1.</span> Physical Layer</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
The lowest layer of the OSI model. Responsible for physical connections between the devices. The physical layer handles data in form of bits and is responsible for transmitting bits without loss from one node to another.
</p>

<p>
Functions of physical layer are
</p>
<ul class="org-ul">
<li><b>Bit Synchronization</b> : the physical layer provides a clok to synchronize sending and recieving of data between nodes</li>
<li><b>Bit rate  control</b> : the physical layer also controls the the number of bits sent per second.</li>
<li><b>Physical topologies</b> : topology defines how the nodes and links are arranged in the network</li>
<li><b>Transmission mode</b> : the physical layer defines how data will flow from one node to another. Some transmissions modes are simplex, half-duplex and full-duplex</li>
</ul>

<p>
Hub, repeater, moden and cables are physical layer devices
</p>
</div>
</div>
<div id="outline-container-org1cdd19e" class="outline-4">
<h4 id="org1cdd19e"><span class="section-number-4">3.1.2.</span> Data Link Layer (DLL)</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
This layer is responsible for node-to-node delivery of the message. It makes sure that data transfer is error-free from one node to another, over the physical layer. When packet enters a network, it is the responsibility of DLL to transmit it to the host using MAC address.
</p>

<p>
The DLL has two sublayers:
</p>
<ol class="org-ol">
<li>Logical Link Control (LLC)</li>
<li>Media Access Control (MAC)</li>
</ol>

<p>
The packet recieved from <b>network layer</b> is divided into frames, depending on the frame size of NIC. The reciever's MAC address is obtained by placing an Address Resolution Protocol (ARP) request, asking for MAC address for given IP address. The destination host replies to the ARP request with it's MAC address.
</p>

<p>
The functions of DLL are
</p>
<ul class="org-ul">
<li><b>Framing</b> : since physical layer only accepts and transmits stream of bits without meaning or structure, the DLL breaks message into recognizable frame with boundries. This is done by attaching special bit patterns at beginning and end of a frame. Breaking message into frames is called framing.</li>
<li><b>Physical addressing</b> : after creating frames, the DLL will add MAC address of the sender and reciever in the header of each frame.</li>
<li><b>Error control</b> : DLL will detect and retransmit damaged or lost frames.</li>
<li><b>Flow control</b> : the data rate must be constant on both sides to not cause corruption in data. Flow control is coordinated by the DLL to avoid this.</li>
<li><b>Access contrl</b> : when a single communication channel is shared by multiple devices, the MAC sub-layer of DLL determines which device has control over the channel at a given time.</li>
</ul>

<p>
DLL is handled by the NIC and device drivers of host machines.
Switch and bridges are example of DLL devices.
</p>
</div>
</div>
<div id="outline-container-org73fcfad" class="outline-4">
<h4 id="org73fcfad"><span class="section-number-4">3.1.3.</span> Network Layer</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
The network layer controls operations of the subnet.
It is responsible for transmission of data from one host to other located on different subnets. It is also responsible for packet routing i.e, the selection of the shortest path for the packets. The sender and reciever IP addresses are place in the header by the network layer.
</p>

<p>
Routes can be based on static table that rarely changed, or are updated automatically at the start of conversation. Routes can also be highly dynamic to reflect the current network load.
</p>

<p>
Too many packets present in subnet can cause bottlenecks. <b>Handling congestion is also the responsibility of network layer</b>. The <b>quality of service</b> (delay, transit time, jitter, etc.) are also a network layer issue.
</p>

<p>
Functions of network layer are
</p>
<ul class="org-ul">
<li><b>Routing</b> : the network layer determines which route will be used to send packet from sender to reciever.</li>
<li><b>Logical addressing</b> : the network layer identifies the IP addresses of sender and reciever in the network an places them in the header.</li>
</ul>

<p>
The implementation of network layer is in devices such as routers and switches.
</p>
</div>
</div>
<div id="outline-container-orgcbf380d" class="outline-4">
<h4 id="orgcbf380d"><span class="section-number-4">3.1.4.</span> Transport Layer</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
The data in transport layer is referred to as <b>segments</b>. This layer is responsible for end to end delivery of messages. It also acknowledges successful transmission and re-transmits data if error is found.
</p>

<p>
At sender's side, this layer recieves data from upper layers, performs <b>segmentation</b> and also implements <b>flow and error control</b>. It also adds source and destination port numbers in headers and forwards the segmented data to network layer. The destination port number is configured either by default or manually. example, when requesting web server, we use destination port 80 for the request because it is default port used for HTTP requests.
</p>

<p>
At reciever's side, it performs sequencing and reassembling of segmented  data. Then port number is read from the header and data is forwarded to the respective application.
</p>

<p>
Transport layer is an <b>end-to-end layer</b>. It carries data all the way from source to destination. That is, a program on source machine carries on a conversation with similar program on destination machine using headers and control messages. The lower layers, have protocols which communicate between machine and immediate neighbours, not the source and destination. <i><b>Layers 1 to 3 are chained, i.e. communicate with neighbours while layers 4 to 7 are end-to-end.</b></i>
</p>

<p>
Funtions of transport layer are
</p>
<ul class="org-ul">
<li><b>Segmentation and Reassembly</b> : at sender the message from session layer is broken into smaller units called segments, at receiver the segements are reassembled into message.</li>
<li><b>Service Point Addressing</b> : the transport layer determines what type of service is provided to the session layer and ultimately, to the user. The type of service is determined when connection is established via port address.</li>
</ul>

<p>
The service of transport layer is of two types
</p>
<ol class="org-ol">
<li><b>Connection Oriented Service</b> : it is a three phase service that has connection establishment, data transfer and then termination. The receiving node will send and acknowledgment and asks for re-transmission if there is error. This type of transmission is reliable and secure. example, TCP</li>
<li><b>Connectionless service</b> : in this type of transmission,  there is no need to establish a connection before data transfer and the receiver does not send an acknowledgement. This approach allows faster communication but is less reliable. example, UDP</li>
</ol>

<p>
Transport layer is operated by the OS. This layer is called the <b>heart of OSI model</b>.
</p>
</div>
</div>
<div id="outline-container-org76249cd" class="outline-4">
<h4 id="org76249cd"><span class="section-number-4">3.1.5.</span> Session Layer</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
This layer is responsible for establishing connection, maintanance of communication sessions and authentication. It ensures the security in connection.
</p>

<p>
The services provided by session layer are
</p>
<ul class="org-ul">
<li><b>Connection establishmen and release</b> : The session layer open a connection between two nodes, this connection is called a <b>session</b>. In OSI, transport layer does not terminate the connection, the session layer is responsible for that. In TCP/IP model, this is done by the transport layer.</li>
<li><b>Dialogue control</b> : in a session, there can be three different types of dialogue - two way simultaneous (full-duplex), two way alternate (half-duplex) and one way (simplex). It controls which side has the turn during communication.</li>
<li><b>Synchronization points and resynchronization</b> : this layer allows the two sides to insert synchronization points between dialogue and allow them to resynchronize to a previous synchronization point, aborting the current transmission. This can be used for real-time audio/video.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfd824e7" class="outline-4">
<h4 id="orgfd824e7"><span class="section-number-4">3.1.6.</span> Presentation Layer</h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
Also called the translation layer. This layer translates files and data from local formats to standard, transmittable formats.
</p>

<p>
The services provided by presentation layer are
</p>
<ul class="org-ul">
<li><b>Data conversion</b> : example, converting file formats such as bmp to webp which are easier to transmit in a network.</li>
<li><b>Character code translation</b> : changing strings to bits that can be transmitted.</li>
<li><b>Compression</b> : compressing and decompressing data in order to reduce the amount of data has to be sent.</li>
<li><b>Encryption and Decryption</b> : encrypting and decryting of messages for security</li>
<li><b>Serialization</b> : converting complex data structures into flat structures using mechanisms like JSON and XML.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcc19db5" class="outline-4">
<h4 id="orgcc19db5"><span class="section-number-4">3.1.7.</span> Application Layer</h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
Also called the Desktop Layer. This layer acts as the window for applications to access the network. This layer produces the data which will be transferred over network and displays the information to user. This layer also contains the protocols for interfaces to different functionalities of the web.
</p>

<p>
This layer has protocols such as HTTP, FTP, SMTP, DNS and provides the functionality to use services associated with these protocols.
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org6834f41" class="outline-3">
<h3 id="org6834f41"><span class="section-number-3">3.2.</span> TCP/IP Model</h3>
<div class="outline-text-3" id="text-3-2">
<p>
TCP/IP was used in ARPANET and now the worldwide Internet. The ARPANET started as a network of hundreds of universities and government installations. When satellite and radio networks were added, they caused problems with existing protocols. This need for a model that can connect multiple networks in a seamless way was the major goal of the TCP/IP model.
</p>

<p>
Another requirment was that connections remain intact as long as the source and destination machines were working, even if some machines or transmission lines were out of operation. So a flexible and robust network was needed.
</p>

<p>
The TCP/IP model had 4 layers, but sometimes physical layer is also included in the model.
</p>
</div>

<div id="outline-container-org0d8661c" class="outline-4">
<h4 id="org0d8661c"><span class="section-number-4">3.2.1.</span> Link layer</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
The requirnment for a robust network led to the choice of packet-switching network based on a connectionless layer that runs across different networks. The link layer describes what links like serial lines and classic ethernet must do to meet needs of this connectionless internet layer. It is not a layer in normal sense, but rather an interface between different hosts and transmission links.
</p>
</div>
</div>

<div id="outline-container-org038311a" class="outline-4">
<h4 id="org038311a"><span class="section-number-4">3.2.2.</span> Internet layer</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
This layer roughly corresponds to the OSI network layer. Its job is to permit hosts to <b>inject packets into any network and have them travel independently to the destination</b>. That is, it will allow packets from go to one network to another while they are going to destination. This property that packets can travel through any network makes the whole network more robust, by allowing communication even if a few networks in some path are down.
</p>

<p>
The packets may even arrive in a completely different order than in which they were sent. If in-order delivery was needed, then it's the responsibility of higher layers to rearrange them.
</p>

<p>
It is similar to the <b>old mail system</b>. When a sequence of international letters are dropped in a mailbox from one country, most mails will be delivered to the correct address in destination country. The mails may not go in the same sequence they we entered in the mailbox. Furthermore, each country (network for our analogy) has it's own stamps, envelope size, and other rules and protocols.
</p>

<p>
The internet layer defines an official packet format and protocol called <b>Internet Protocol</b> (IP), with a companion protocol <b>Internet Control Message Protocol</b> (ICMP) that helps its function.
</p>

<p>
The job of internet layer is to deliver IP packets where they are supposed to go. Packet routing is the major obstacle for this layer. (IP has proven not effective to avoid congestion)
</p>
</div>
</div>
<div id="outline-container-org1b1fdfc" class="outline-4">
<h4 id="org1b1fdfc"><span class="section-number-4">3.2.3.</span> Transport</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Same functionality as the transport layer in the OSI model
</p>
</div>
</div>
<div id="outline-container-orgf901bba" class="outline-4">
<h4 id="orgf901bba"><span class="section-number-4">3.2.4.</span> Application layer</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
Same functionality as the presentation layer and the application layer in the OSI model. Also handles some functions of the session layer.
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf18d222" class="outline-2">
<h2 id="orgf18d222"><span class="section-number-2">4.</span> Physical Layer</h2>
<div class="outline-text-2" id="text-4">
<p>
The lowest layer of the TCP/IP model. It describes the standard for the physical connections between nodes. It only views the data as a stream of bits and is concerned with transmission of bits without error.
<hr />
</p>
</div>
<div id="outline-container-org846ba11" class="outline-3">
<h3 id="org846ba11"><span class="section-number-3">4.1.</span> Transmission Media</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The transmission medium is the physical path between the transmitter and receiver i.e, the channel through which data is sent from one place to another.
</p>

<p>
Transmission media is broadly classified into two types
</p>
<ol class="org-ol">
<li>Guided media (wired)</li>
<li>Unguided media (wireless)</li>
</ol>
</div>
<div id="outline-container-org84a8308" class="outline-4">
<h4 id="org84a8308"><span class="section-number-4">4.1.1.</span> Guided Media</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Also referred to as wired or Bounded transmission media.
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org64688c2" class="outline-3">
<h3 id="org64688c2"><span class="section-number-3">4.2.</span> Data and signals</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgf8678a9" class="outline-4">
<h4 id="orgf8678a9"><span class="section-number-4">4.2.1.</span> Bandwidth and maximum data rate</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
<b>Bandwidth is the measure of carrying capacity of a medium</b>. There are two ways to define bandwidth.
</p>
<ul class="org-ul">
<li>When working on the physical layer, <b>bandwidth can be seen as the maximum frequency of the signals</b> that can travel in the medium. It is measured in Hertz (Hz)</li>
<li>In other context, bandwidth is the <b>maximum possible data transfer rate of the medium</b>. It is measured in bits per second (bps).</li>
</ul>
<p>
These two ways to define bandwidth are linked and are not actually different ideas.
</p>

<p>
The reason for this difference of Hz and bps measurements is that the <b>maximum frequency of medium is something that only the physical layer is concerned with.</b> In every other layer, we only care about how much data can be transferred. Therefore, <b>unless we are working on physical layer, bandwidth is the maximum data transfer rate of the medium.</b>
</p>
</div>
<div id="outline-container-org8a377dd" class="outline-5">
<h5 id="org8a377dd"><span class="section-number-5">4.2.1.1.</span> Maximum data transfer rate for noiseless wires</h5>
<div class="outline-text-5" id="text-4-2-1-1">
<p>
Suppose our analog signal has \(V\) different levels. Then for a noiseless wire with bandwidth of \(B\), the maximum data rate is
\[ \text{maximum data rate} = 2\ B\ log_2V \text{ bits/sec} \]
Example, a noiseless 3-kHz channel cannot transmit binary signal (two levels) at rate 6000 bps.
</p>
</div>
</div>
<div id="outline-container-orgccd82bc" class="outline-5">
<h5 id="orgccd82bc"><span class="section-number-5">4.2.1.2.</span> Maximum data transfer rate for noisy wires</h5>
<div class="outline-text-5" id="text-4-2-1-2">
<p>
But the noiseless wire is an ideal case, which is not possible in real wires. Amount of noise is measured using ratio of signal power to noise power called <b>SNR (Signal-to-Noise Ratio)</b>. \(S\) denotes signal power and \(N\) denotes noise power.
\[ SNR = \frac{S}{N} \]
The ratio is expressed on a log scale as
\[ SNR_{dB} = 10\ log_{10} (S/N) \text{ dB} \]
The unit of \(SNR_{dB}\) is <b>decibals (dB)</b>
</p>

<p>
Using SNR, the maximum data rate in a noisy medium is
\[ \text{maximum data rate} = B\ log_2(1 + S/N) \text{ bits/sec} \]
<b>Example</b>, suppose \(SNR_{dB}\) is of 40 dB and bandwidth is 1MHz. Then, using formula for SNR, \(S/N\) is \(10^4\). Therefore, the maximum data rate is
\[ \text{maximum data rate} = 1\ log_2 (10^4) \text{ Mbps}\]
\[ \text{maximum data rate} = 13.288 \text{ Mbps} \]
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaf8fbb8" class="outline-3">
<h3 id="orgaf8fbb8"><span class="section-number-3">4.3.</span> Digital-to-digital conversion</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Digital-to-digital conversion refers to converting digital data into digital signals. The way to convert digital data to digital signals is called <b>line coding</b>
</p>

<p>
Block coding and scrambling are done along with line coding but are not always necessary. They are used under specific conditions that depend on channel.
<img src="./imgs/Untitled-2023-09-28-1310.png" alt="Untitled-2023-09-28-1310.png" />
</p>
</div>
<div id="outline-container-org40351d7" class="outline-4">
<h4 id="org40351d7"><span class="section-number-4">4.3.1.</span> Line coding</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
Encoding digital data to digital signals is called line coding. Based on the number of levels used, we have three types of line coding
</p>
<ol class="org-ol">
<li><b>Unipolar</b> : a single voltage level i.e, a single polarity is used to represent data. Uses a single voltage and idle line.</li>
<li><b>Polar</b> : two polarities i.e, voltage levels are used to represent data. Two voltages and idle line is used</li>
<li><b>Bipolar</b> : uses three possible voltage levels. Usually shown by negative, positive and zero.</li>
</ol>
<p>
There are also Multilevel and Multitransition line codings but they are not within the scope of discussion. We only focus on these three
</p>
</div>
<div id="outline-container-orgdc181ca" class="outline-5">
<h5 id="orgdc181ca"><span class="section-number-5">4.3.1.1.</span> Unipolar NRZ</h5>
<div class="outline-text-5" id="text-4-3-1-1">

<div id="org7bd1921" class="figure">
<p><img src="./imgs/unipolar_nrz.png" alt="unipolar_nrz.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org9db4ec3" class="outline-5">
<h5 id="org9db4ec3"><span class="section-number-5">4.3.1.2.</span> Polar NRZ</h5>
<div class="outline-text-5" id="text-4-3-1-2">

<div id="orge8944ab" class="figure">
<p><img src="./imgs/polar_nrz.png" alt="polar_nrz.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org523f0d7" class="outline-5">
<h5 id="org523f0d7"><span class="section-number-5">4.3.1.3.</span> Polar RZ</h5>
<div class="outline-text-5" id="text-4-3-1-3">

<div id="org9942bdf" class="figure">
<p><img src="./imgs/polar_rz.png" alt="polar_rz.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgeaf1e28" class="outline-5">
<h5 id="orgeaf1e28"><span class="section-number-5">4.3.1.4.</span> Biphase</h5>
<div class="outline-text-5" id="text-4-3-1-4">

<div id="org2ab31df" class="figure">
<p><img src="./imgs/biphase.png" alt="biphase.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfcbe7a1" class="outline-5">
<h5 id="orgfcbe7a1"><span class="section-number-5">4.3.1.5.</span> AMI and pseudoternary</h5>
<div class="outline-text-5" id="text-4-3-1-5">

<div id="org95f3368" class="figure">
<p><img src="./imgs/bipolar.png" alt="bipolar.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfa63699" class="outline-5">
<h5 id="orgfa63699"><span class="section-number-5">4.3.1.6.</span> Summary of line codes</h5>
<div class="outline-text-5" id="text-4-3-1-6">
<p>
TODO: This table is very very wrong, fix this
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Category</th>
<th scope="col" class="org-left">Scheme</th>
<th scope="col" class="org-left">Bandwidth</th>
<th scope="col" class="org-left">Synchronization</th>
<th scope="col" class="org-left">Has DC component</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Unipolar</td>
<td class="org-left">NRZ</td>
<td class="org-left">B = N/2</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Polar</td>
<td class="org-left">NRZ-L</td>
<td class="org-left">B = N/2</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Polar</td>
<td class="org-left">NRZ-I</td>
<td class="org-left">B = N/2</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Polar</td>
<td class="org-left">Biphase</td>
<td class="org-left">B = N</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Bipolar</td>
<td class="org-left">AMI</td>
<td class="org-left">B = N/2</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
</table>
<p>
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org07ed68d" class="outline-4">
<h4 id="org07ed68d"><span class="section-number-4">4.3.2.</span> Block coding</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
TODO : Here
</p>
</div>
</div>
<div id="outline-container-org3332d95" class="outline-4">
<h4 id="org3332d95"><span class="section-number-4">4.3.3.</span> Scrambling</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
TODO : Here
</p>
</div>
</div>
</div>
<div id="outline-container-org66eb9c4" class="outline-3">
<h3 id="org66eb9c4"><span class="section-number-3">4.4.</span> Network Topology</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The arrangement of nodes and links in a computer network is called network topology. There are various types of topologies
</p>
</div>

<div id="outline-container-orgeab73fb" class="outline-4">
<h4 id="orgeab73fb"><span class="section-number-4">4.4.1.</span> Point-to-Point</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
It is the simplest connection with two nodes and a single link between them.
</p>


<div id="org7ce0e4f" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-39-47_screenshot.png" alt="2023-10-21_15-39-47_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org65f7065" class="outline-4">
<h4 id="org65f7065"><span class="section-number-4">4.4.2.</span> Daisy chaining</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
Also called linear topology, the nodes are connected in a series. Message will follows the whole chain till it reaches the destination. If a link fails in this topology, it is hard to find it, therefore it is not good for large networks.
</p>


<div id="orgb9a8d2f" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-41-06_screenshot.png" alt="2023-10-21_15-41-06_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcdaafe1" class="outline-4">
<h4 id="orgcdaafe1"><span class="section-number-4">4.4.3.</span> Mesh topology</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
Every node is connected to another node through a direct link. In mesh topology, we use AHCP (Ad Hoc Configuration Protocol) and DHCP (Dynamic Host Configuration Protocol).
</p>

<p>
So every node is connected to every other node directly connected through a link. So if there are \(N\) nodes, then the each node has \((N - 1)\) links.
</p>

<p>
If there are \(N\) nodes, then in a mesh topology, the total number of links will be
\[ \text{number of links in mesh topology : } \frac{N(N - 1)}{2} \]
\[ \text{where } N \text{ is the number of nodes} \]
</p>

<p>
Advantages of mesh topology are
</p>
<ul class="org-ul">
<li>communication is fast between any pair of nodes</li>
<li>data transfer is reliable since there are dedicated links between all nodes</li>
<li>since every pair of node has dedicated link, this provides security and privacy</li>
<li>the network is more robust single a failure of single device won't break the network</li>
</ul>

<p>
Drawbacks of mesh topology are
</p>
<ul class="org-ul">
<li>installation is hard, since each link needs to be configured</li>
<li>excessive amount of cables and channels are required to connect all nodes</li>
<li>the cost of maintanance is very high</li>
</ul>

<p>
Mesh topology is of two types
</p>
<ol class="org-ol">
<li><b>Full mesh topology</b> : it is the traditional mesh topology, where every node is connected with other node thus every node has \((N - 1)\) connections.</li>
<li><b>Partial mesh topology</b> : a more practical implementation where it is not necessary to connect all nodes to one another. Only channels with high amount of traffic are connected. This is not the traditional way to implement mesh topology.</li>
</ol>


<div id="orgde46861" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-44-08_screenshot.png" alt="2023-10-21_15-44-08_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org41ca6ff" class="outline-4">
<h4 id="org41ca6ff"><span class="section-number-4">4.4.4.</span> Star topology</h4>
<div class="outline-text-4" id="text-4-4-4">
<p>
All nodes are connected to a central node (called the hub) through links. Hubs are not communication endpoints, their function is to forward packets across all ports. The hubs can either be passive in nature or active.
</p>

<p>
Active hubs repeat and strengthen incoming transmissions, while passive hubs simply serve as a point of connectivity. Active hubs are also referred to as <b>repeaters</b>.
</p>

<p>
Advantages of star topology are
</p>
<ul class="org-ul">
<li>only \(N\) links are required to connect \(N\) nodes to a network</li>
<li>each device will need only one port</li>
<li>if one link fails, it won't affect other links</li>
<li>cost effictive</li>
</ul>

<p>
Drawback of star topology are
</p>
<ul class="org-ul">
<li>if the hub fails, then whole network is down</li>
<li>performace is dependant on the hubs</li>
</ul>


<div id="org4600810" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-47-17_screenshot.png" alt="2023-10-21_15-47-17_screenshot.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org170bd6d" class="outline-4">
<h4 id="org170bd6d"><span class="section-number-4">4.4.5.</span> Bus topology</h4>
<div class="outline-text-4" id="text-4-4-5">
<p>
In bus topology, all the nodes are connected to a single backbone line. This backbone is bi-directional, there are lines from node to backbone called droplines. This topology is not robust, since if backbone is damaged, the whole network is down.
</p>

<p>
In this topology, various MAC protocols are followed like TDMA, Pure Aloha, CDMA, etc.
</p>

<p>
Advantages of Bus topology
</p>
<ul class="org-ul">
<li>there is only a single link and \(N\) drop lines required</li>
<li>reduces the cost for installation</li>
<li>CSMA is the most common method for this topology</li>
</ul>

<p>
Drawbacks
</p>
<ul class="org-ul">
<li>if backbone fails, then whole network is down</li>
<li>this topology can't handle heavy traffic</li>
<li>adding new nodes slows the network</li>
<li>security is very lower</li>
</ul>


<div id="org2df9380" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-51-02_screenshot.png" alt="2023-10-21_15-51-02_screenshot.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org962b884" class="outline-4">
<h4 id="org962b884"><span class="section-number-4">4.4.6.</span> Ring topology</h4>
<div class="outline-text-4" id="text-4-4-6">
<p>
A daisy chain in a closed circular loop is called a ring topology. The most common method for communication in this topology is token passing. A <b>token</b> is a frame which is circulated around the network. The token is passed from one node to another till it reaches its destination.
</p>

<p>
Advantages
</p>
<ul class="org-ul">
<li>better for traffic than bus topology</li>
<li>cheap to install and expand</li>
</ul>

<p>
Disadvantages
</p>
<ul class="org-ul">
<li>single node failure can cause entire network to fail</li>
<li>troubleshooting is difficult</li>
<li>the topology is not secure</li>
</ul>


<div id="orgf93c9cf" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-52-50_screenshot.png" alt="2023-10-21_15-52-50_screenshot.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4f27c93" class="outline-4">
<h4 id="org4f27c93"><span class="section-number-4">4.4.7.</span> Tree topology</h4>
<div class="outline-text-4" id="text-4-4-7">
<p>
Also called a star-bus topology. It can be seen as multiple star topologies connected via a backbone like in bus topology. Tree topology is hierarchical and there are parent and child star networks. It uses protocols like DHCP and SAC. The backbone is like the truck of the tree and various star networks branch out from it.
</p>

<p>
The hubs connected directly to main backbone are central hubs. The hubs connected to other hubs are child hubs. This makes this topology very flexible.
</p>

<p>
Advantages
</p>
<ul class="org-ul">
<li>allows networks to prioritize different computers</li>
<li>new nodes are easy to add</li>
<li>error detection and error correction is easy</li>
</ul>

<p>
Drawbacks
</p>
<ul class="org-ul">
<li>if backbone fails the entire network is down. If a parent hub fails, then all the connected child network is down</li>
<li>cost of maintanance is high</li>
<li>reconfiguration is hard</li>
</ul>


<div id="org2741e75" class="figure">
<p><img src="Physical_Layer/2023-10-21_15-54-51_900px-TreeTopology.png" alt="2023-10-21_15-54-51_900px-TreeTopology.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orge209a16" class="outline-4">
<h4 id="orge209a16"><span class="section-number-4">4.4.8.</span> Hybrid topology</h4>
<div class="outline-text-4" id="text-4-4-8">
<p>
A hybrid topology is when a network combines two or more topologies in a way that does not resemble standard topologies.
</p>

<p>
Advantages
</p>
<ul class="org-ul">
<li>this is very flexible</li>
<li>size of network can be easily expanded</li>
</ul>

<p>
Disadvantages
</p>
<ul class="org-ul">
<li>it is challenging to design and maintain</li>
<li>the infrastructure needs specialization to maintain</li>
</ul>
<p>
<hr />
</p>
</div>
</div>
</div>

<div id="outline-container-org67b09dd" class="outline-3">
<h3 id="org67b09dd"><span class="section-number-3">4.5.</span> Switching</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Two different switching techniques are used by networks.
</p>
<ul class="org-ul">
<li><b>Circuit switching</b> : the switching used in traditional telephone systems</li>
<li><b>Packet switching</b> : the switching used in IP technology</li>
</ul>
<p>
This section will only provide brief introduction with relation to physical layer. Switching is later discussed in network layer.
</p>
</div>
<div id="outline-container-org842334b" class="outline-4">
<h4 id="org842334b"><span class="section-number-4">4.5.1.</span> Circuit switching</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
When a telephone call is placed, the switching equipment looks for a <b>single path</b> from sender to receiver and maintains it for the duration of the communication. This technique of having a direct physical connection is called <b>circuit switching</b>.
</p>

<p>
In early days of telephone, connection was made by operator by plugging jumper cables into input and output sockets. Automatic circuit switching was invented by Almon B. Strowger. For nearly a 100 years, the automatic circuit switching equipment used worldwide was known as Strowger gear.
</p>

<p>
The parts of path between telephone may in fact be microwave or fibre or any other type of medium. There are thousand of calls multiplexed on parts of links.
</p>

<p>
The main property of circuit switching is that <b>there is a single path for the whole duration of communication.</b> Therefore, it needs to set up and end-to-end path before any data can be sent. The bandwidth required for communication is also reserved before data is sent.
</p>

<p>
Since there is a reserved path, <b>once setup is complete the only dealy for data is propogation time for signals</b>. Also once path is reserved, there is no danger of congestion. Of course the <b>conjestion can be felt before connection is established, as it may take a while due to switching or trunk capacity.</b>
</p>
</div>
</div>
<div id="outline-container-orgc222e44" class="outline-4">
<h4 id="orgc222e44"><span class="section-number-4">4.5.2.</span> Packet switching</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
In contrast to circuit switching, there is <b>no need to set up dedicated path in advance. Packet switching is analogous to sending data in form of series of letters using postal system</b>.
</p>

<p>
Each packet will travel independently of others and can choose any path to reach destination in the network. It is <b>up to routers</b> to use store-and-forward transmission to send each packet on its way towards the destination. Since every packet travels independently, they may arrive out of order.
</p>

<p>
Packet-switching networks place <b>tight upper limit on the packet sizes</b>. This ensures that <b>no single user can monopolize any transmission line for long</b>, so that network can handle interactive traffic. It also reduces delay since first packet of a long message can be forwarded before second is fully formed. However, there is more delay than circuit switching. In ciruit switching, bits can flow continuously without anything ever being stored and forwarded later.
</p>

<p>
Since bandwidth is not reserved, packets may have to wait to be forwarded, this introduces <b>queuing delay</b> and congestion. On the other hand, we don't have to wait to establish a connection. Therefore, in circuit switching (during setup) and packet switching (packets are travelling) congestion occurs at different times.
</p>

<p>
Packet switching does not waster bandwidth which is limited resource. <b>Packet switching is also more fault tolerant</b>, in fact that was why packet switching was chosen for internet. If some switches go down, packets can travel around them.
</p>

<p>
These differences in the types of switching also leads to the difference in which billing is usually done for both networks. With circuit switching main load factors are distance and time of communication, therefore billing is done for how long connection is established (talktime on phone calles). Whereas in packet switching main load factor is how much traffic is added to network by a user, therefore billing is done based on how much data is transferred by user.
</p>

<p>
The <b>difference between circuit and packet switching</b> is
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Item</th>
<th scope="col" class="org-left">Circuit switched</th>
<th scope="col" class="org-left">Packet switched</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Call Setup</td>
<td class="org-left">Required</td>
<td class="org-left">Not needed</td>
</tr>

<tr>
<td class="org-left">Dedicated Physical Path</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Whole data follows same path</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Data arrives in order</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Is a switch crash fatal</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Bandwidth available</td>
<td class="org-left">Fixed</td>
<td class="org-left">Dynamic</td>
</tr>

<tr>
<td class="org-left">Time of possible congestion</td>
<td class="org-left">At setup</td>
<td class="org-left">On every packet</td>
</tr>

<tr>
<td class="org-left">Potentially wasted bandwidth</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Store-and-forward transmission</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Billing</td>
<td class="org-left">Per minute</td>
<td class="org-left">Per Byte</td>
</tr>
</tbody>
</table>
<p>
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7e8beb3" class="outline-2">
<h2 id="org7e8beb3"><span class="section-number-2">5.</span> Data Link Layer</h2>
<div class="outline-text-2" id="text-5">
<p>
In this layer, data is handelded in form of <b>frames.</b> It handles data transfer between two <b>adjacent machines</b>.
</p>

<p>
Adjacent means two computers connected by a <b>communication channel</b>. The essential property of a communication channel is that it acts <b>conceptually like a wire.</b> That is, bits are delivered in same order in which they are sent.
</p>

<p>
The data link layer uses the services of the physical layer to send and recieve bits from communication channels.
</p>

<p>
The <b>main functions</b> of DLL are
</p>
<ol class="org-ol">
<li>Provide a well defined interface for the network layer</li>
<li><b>Framing</b> sequences of bytes as self-contained segments.</li>
<li><b>Detection and correction of transmission errors</b>.</li>
<li><b>Regulating the flow of data</b> so that slow recievers are not swamped by fast senders.</li>
</ol>
<p>
<hr />
</p>
</div>
<div id="outline-container-org58d1865" class="outline-3">
<h3 id="org58d1865"><span class="section-number-3">5.1.</span> Services Provided to Network Layer</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The <b>principle function of DLL is to transfer data from network layer of source machine to network layer of destination machine</b>. The data link layers of source and destination will communicate via a data link protocol.
</p>

<p>
The service data link layer provides varies from protocol to protocol. Three common possibilities are
</p>
<ol class="org-ol">
<li><b><span class="underline">Unacknowledged connectionless service</span></b> : sends frames to destination without having the destination acknowledge them. Example, ethernet provides this class of service.
<ul class="org-ul">
<li>No logical connection is established.</li>
<li>If frame is lost due to noise, no attempt is made to detect or recover it.</li>
<li>Appropriate when error rate is low and real time traffic (voice or video).</li>
</ul></li>
<li><b><span class="underline">Acknowledged connectionless service</span></b> : step up in terms of reliability.
<ul class="org-ul">
<li>Still no logical connection is established</li>
<li>Each frame sent is individually acknowledged</li>
<li>If sender gets no acknowledgement within a specified time interval, frame is sent again</li>
<li>Acknowledgement in data link layer is an optimization rather than a requirnment. It can also be handled in network layer, but there the whole message is retransmitted rather than a single frame.</li>
<li>On unreliable channels, data link protocols overhead is worth the cost, but it may be unneccessary on reliable channels (wired channels)</li>
</ul></li>
<li><p>
<b><span class="underline">Acknowledged connection-oriented service</span></b> : source and destination machine establish a connection before data transfer begins.
</p>
<ul class="org-ul">
<li>Each frame is numbered</li>
<li>Data link layer will guarantee that each frame is received</li>
<li>Also guarantees that all frames are received only once and in right order</li>
<li>Appropraite over long, unreliable links like satellite channels or telephone circuits</li>
</ul>
<p>
In connection-oriented service, transfer has three distinct phases
</p>
<ol class="org-ol">
<li>Establish connection : both sides initialize variables and counters to keep track of frames</li>
<li>Data transfer : frames are transmitted</li>
<li>Connection released : free variables, buffers and other resources used to maintain connection</li>
</ol></li>
</ol>

<p>
<hr />
</p>
</div>
</div>
<div id="outline-container-orgafa0b98" class="outline-3">
<h3 id="orgafa0b98"><span class="section-number-3">5.2.</span> Framing</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Physical layer accepts raw bit stream and attempt to deliver it to destination. But because channels are noisy, it causes error in the bit stream. The physical layer adds redundany bits to reduce error rate to tolerable level.
</p>

<p>
But the physical layer does not guarantee error-free transmission. Bits may not have equal values or the number of bits received may be different from number of bits sent. It is up to data link layer to detect and if needed, correct errors.
</p>
</div>
<div id="outline-container-orgab2e93d" class="outline-4">
<h4 id="orgab2e93d"><span class="section-number-4">5.2.1.</span> Use of framing</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Data link layer breaks the bit stream into discrete frames, and computes a checksum for each frame and includes it in frame when it is transmitted. When frame arrives at the destination, the receiver can recompute checksum to test if error has ocurred.
</p>
</div>
</div>

<div id="outline-container-orgb86a60b" class="outline-4">
<h4 id="orgb86a60b"><span class="section-number-4">5.2.2.</span> How framing is done</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
A good framing design must make it easy for receiver to find start of new frames while using little bandwidth.
</p>

<ul class="org-ul">
<li><b>Payload data</b> : The data that is carried by a frame which is given to network layer is called payload data.</li>
</ul>
</div>
<div id="outline-container-org4fe1e5f" class="outline-5">
<h5 id="org4fe1e5f"><span class="section-number-5">5.2.2.1.</span> Byte count</h5>
<div class="outline-text-5" id="text-5-2-2-1">
<p>
Uses a field in header to specify number of bytes in the frame. Data link layer at receiver reads the byte count to know where the frame ends.
</p>

<p>
The <b>count can be garbled during transmission</b>. Then receiver cannot locate the correct start of next frame. Even when the checksum fails, sending frame back for retransmission won't help, since destination won't know how many bytes to skip over to start retransmission (resynchronization error).
</p>

<p>
Therefore, byte count method is not used by itself.
</p>
</div>
</div>
<div id="outline-container-orgc445c47" class="outline-5">
<h5 id="orgc445c47"><span class="section-number-5">5.2.2.2.</span> Flag byte</h5>
<div class="outline-text-5" id="text-5-2-2-2">
<p>
The problem of resynchronization is solved by having each frame start and end with special bytes (often the same byte) called <b>flag byte.</b>
Flag byte is usually used as both starting and ending delimiter.
</p>

<p>
<b>Two consecutive flag bytes indicate end of one frame and start of next</b>. So if receiver ever losses synchronization, it can search for two consecutive flag bytes to resynchronize.
</p>

<p>
It may happen that the payload data to be sent has the same byte as the flag byte, this would interfere with framing. There are two ways to solve this, <b>byte stuffing</b> and <b>bit stuffing</b>.
</p>
</div>
</div>
<div id="outline-container-orgc7710f9" class="outline-5">
<h5 id="orgc7710f9"><span class="section-number-5">5.2.2.3.</span> Byte stuffing</h5>
<div class="outline-text-5" id="text-5-2-2-3">
<p>
Sender's data link layer will insert a special <b>escape byte (ESC)</b> before the FLAG byte in payload data
</p>
<ul class="org-ul">
<li>The idea is the same as using \" for inserting quotes in strings</li>
<li>If payload data has FLAG byte, data link layer converts it to ESC FLAG</li>
<li>If payload data has ESC byte, data link layer converts it to ESC ESC</li>
</ul>
<p>
The data link layer on receiver machine will remove the esacape bytes before giving data to network layer. This technique is called <b>byte stuffing</b>.
<br />
This byte-stuffing scheme is a slight simplification of actual used scheme in PPP (Point-to-Point Protocol).
</p>
</div>
</div>
<div id="outline-container-org7c9ea16" class="outline-5">
<h5 id="org7c9ea16"><span class="section-number-5">5.2.2.4.</span> Bit stuffing</h5>
<div class="outline-text-5" id="text-5-2-2-4">
<p>
The problem with byte stuffing is that we use a whole byte to escape flag byte. <b>Inserting a full byte of data every time to escape the flag byte pattern wastes bandwidth</b>
</p>

<p>
In bit stuffing, we use a single bit in order to escape flag byte in payload data. It was developed for <b>HDLC (High-level Data Link Control) Protocol</b>
</p>

<p>
On senders side
</p>
<ul class="org-ul">
<li>The flag byte is 01111110 or 0x7E in hexadecimal</li>
<li>Whenever the payload data has 5 consecutive 1's, a 0 bit is stuffed in the outgoing stream</li>
<li>Therefore only a single bit is used for stuffing rather than a whole byte</li>
</ul>
<p>
On the receivers side
</p>
<ul class="org-ul">
<li>If there are 5 consecutive 1's followed by a 0, layer automatically destuffs (deletes) the 0 bit</li>
<li>The flag byte 0x7E is used to detect frames</li>
</ul>
<p>
Example, if payload data has flag pattern 01111110, it will be transmitted as 011111010 on receiver's side, the 0 bit is discarded and it is given to network layer as 01111110.
\[ \text{Sender side : } 01111110 \text{ transmitted as } 011111010 \]
\[ \text{Receiver side : } 011111010 \text{ read as } 01111110 \]
</p>
</div>
</div>

<div id="outline-container-orgbe21243" class="outline-5">
<h5 id="orgbe21243"><span class="section-number-5">5.2.2.5.</span> Physical layer coding violations</h5>
<div class="outline-text-5" id="text-5-2-2-5">
<p>
Both byte stuffing and bit stuffing have the downside where length of frame depends on content of payload data. So if there are no flag bytes in payload data, then the stuffed data to be sent is small. But if we assume all bytes in payload data are flag bytes, then the data to be sent doubles when using byte stuffing. With bit stuffing, increase is roughly 12.5% for same scenario.
</p>

<p>
If we know that physical layer is using a specific coding for example 4B/5B to reduce redundancy. We can use one of the "coding violations" pattern, i.e. the <b>unused pattern as the flag byte</b>. Since these pattern won't occur in the payload data, this allows us to use these patterns for our flag byte.
</p>

<p>
The advantage of this scheme is that since these patterns don't occur in payload, it is <b>easy to find start and end of frames</b>. This method also <b>avoids need to stuff data.</b>
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf3b57bd" class="outline-3">
<h3 id="orgf3b57bd"><span class="section-number-3">5.3.</span> Error Control</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Another goal of data link layer is to deliver data to network layer in proper order.
</p>

<p>
For unacknowledged connectionless service, sender can keep outputting frames without regard to whether they are arriving properly
</p>
</div>
<div id="outline-container-orgd09dcdf" class="outline-4">
<h4 id="orgd09dcdf"><span class="section-number-4">5.3.1.</span> Using Acknowledgements</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
For reliable service, we need to know if frame reached destination without error
</p>
<ul class="org-ul">
<li>We need to provide the sender feedback about what is received</li>
<li>This is done by protocol calls of the receiver, which send back special control frames with either <i><b>positive or negative acknowledgement</b></i>
<ul class="org-ul">
<li>Positive acknowledgemen means frame was received safely</li>
<li>Negative means the frame must be retransmitted</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0a4806c" class="outline-4">
<h4 id="org0a4806c"><span class="section-number-4">5.3.2.</span> Lost frames</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>There is a possibility that a <i><b>frame vanishes completely, i.e. it is lost</b></i>. This usually happens due to hardware trouble
<ul class="org-ul">
<li>In this case, receiver has no way to know a frame was lost and will not react to it</li>
<li>Similarly, if sender waits for acknowledgement after sending a frame and <i><b>acknowledgement frame is lost, then sender waits forever</b></i></li>
</ul></li>
<li>Frame being lost is <i><b>dealt by using timers</b></i> in data link layer
<ul class="org-ul">
<li>When sender transmits a frame, it starts a timer with an interval long enough for frame to reach destination, be processed there and the acknowledgement to propogate back to sender.</li>
<li>Normally, frame is sent and acknowledgement is received within time interval, in which case timer is discarded</li>
<li>If orignal frame or acknowledgement is lost, timer will go off alerting the sender</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgea07dc9" class="outline-4">
<h4 id="orgea07dc9"><span class="section-number-4">5.3.3.</span> Retransmission of lost frames</h4>
<div class="outline-text-4" id="text-5-3-3">
<ul class="org-ul">
<li>However, the <i>frame can't be simply retransmitted if it is lost</i>. Because there is risk of destination accepting multiple frames and passing them to it's network layer</li>
<li>To prevent this, we need to sequence outgoing frames, so that receiver can distinguish retransmissions and originals</li>
</ul>
<p>
Managing timers and sequencing frames to ensure that each frame is passed to network layer of destination extactly once is an important duty of data link layer.
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org8fd589f" class="outline-3">
<h3 id="org8fd589f"><span class="section-number-3">5.4.</span> Error detection and correction</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Some channels like optical fiber have tiny error rates that are a rare occurance. But other channels (especially wireless) have error rates that are orders of magnitude larger. However, transmission errors are present in every medium, so we need methods to deal with them.
</p>

<p>
There are two basic strategies for dealing with errors. <b>Both add redundant (extra) information</b> to the data that is sent.
</p>

<ul class="org-ul">
<li><b>Error-correction</b> : include enough redundant information to enable receiver to be able to deduce what transmitted data must have been and correct received data. Uses error-correcting codes
<ul class="org-ul">
<li>The use of error correcting codes is refferred to as <b>FEC (Forward Error Correction)</b></li>
</ul></li>
<li><b>Error-detection and retransmission</b> : include only enough redundancy to allow receiver to detect that an error occured and have it request retransmission. Uses error-detecting codes.</li>
</ul>
<p>
A key consideration for both methods is that redundant bits are just as likely to have errors as data bits. So error code must be strong enough to handle these situations.
</p>
</div>
<div id="outline-container-org52a0d6c" class="outline-5">
<h5 id="org52a0d6c"><span class="section-number-5">5.4.0.1.</span> Which method to use</h5>
<div class="outline-text-5" id="text-5-4-0-1">
<p>
Both of these methods have their own uses
</p>
<ul class="org-ul">
<li>On reliable channels such as fiber, it is cheaper to use error-detecting codes and just retransmit the occasional faulty frame</li>
<li>On unreliable channels such as WiFi, it is better to add redundancy to each block so that receiver is able to figure out what what orignal transmitted data was</li>
<li>FEC is used on noisy channels because retransmissions are just as likely to be in error as the first transmission</li>
</ul>
</div>
</div>
<div id="outline-container-org2e0b88d" class="outline-5">
<h5 id="org2e0b88d"><span class="section-number-5">5.4.0.2.</span> Types of errors in channel</h5>
<div class="outline-text-5" id="text-5-4-0-2">
<p>
There are two models of errors that can happen in a channel
</p>
<ol class="org-ol">
<li><b>Single-bit errors</b> : 
Extreme thermal noise that overwhelm the signal briefly and occasionally give rise to isolated single-bit errors.
<ul class="org-ul">
<li>Single-bit errors are easier to correct using error-correcting codes</li>
</ul></li>
<li><b>Burst errors</b> : 
Problem in physical processes which generate signals such as electrical interference can cause errors to code in bursts.
<ul class="org-ul">
<li>Burst errors are much harder to correct than isolated errors.</li>
<li>Since data is sent in blocks in networks. It is easier to use error-detecting codes and retransmit faulty blocks</li>
</ul></li>
</ol>
<p>
Another type of error that occurs is erasure channel
</p>
<ul class="org-ul">
<li><b>Erasure channel</b> :
Sometimes, the location of the error is known.
<ul class="org-ul">
<li>This <b>usually happens when physical layer receives an analog signal that is not expected</b>, so if we were using +5V for 1 bit and -5V for 0 bit, then getting some other voltage means error has occured</li>
<li>This situation is called a erasure channel</li>
<li>It is easy to correct these errors using Forward Error Control (FEC) i.e, by using error-correcting codes</li>
</ul></li>
</ul>
<p>
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org7e195a9" class="outline-3">
<h3 id="org7e195a9"><span class="section-number-3">5.5.</span> Codewords and Code rate</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Data will be sent in blocks containing data bits and the redundant bits.
<br />
In a block, data takes \(m\) bits and redundant data takes \(r\) bits
\[ \text{size of block with error code} (n) = m + r \]
\[ m : \text{number of payload data bits} \]
\[ r : \text{number of redundant data bits} \]
</p>
<ul class="org-ul">
<li>A n-bit unit containing data and check bit sis referred to as an <i>n-bit codeword</i>. We describe it as \((n,m)\) code.</li>
<li>The <i>code rate</i> or simply rate, is the fraction of codeword that carries payload information and not redundant data.
\[ \text{code rate} = \frac{m}{n} \]</li>
<li>Code rate vary depending on channel. It might be 1/2 for noisy channel, and close to 1 for a high-quality channel</li>
</ul>

<div id="org4b2406b" class="figure">
<p><img src="Data_Link_Layer/2023-12-03_15-56-02_Untitled-2023-12-03-1551.png" alt="2023-12-03_15-56-02_Untitled-2023-12-03-1551.png" />
</p>
</div>
</div>
<div id="outline-container-org01bb3da" class="outline-4">
<h4 id="org01bb3da"><span class="section-number-4">5.5.1.</span> Hamming distance</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
Hamming distance is a way to compare two strings of equal lengths.
</p>
<ul class="org-ul">
<li>The number of positions in which two codewords differ is called <i>Hamming distance</i></li>
</ul>
<p>
To calculate hamming distance
</p>
<ul class="org-ul">
<li>Calculate the XOR of two strings</li>
<li>Count the number of 1's in result to get hamming distance</li>
</ul>
<p>
Example, 10001001 and 10110001 are two strings of equal length (8-bits).
</p>

<p>
Their XOR is
\[ 10001001 \oplus 10110001 = 00111000 \]
\[ \text{Hamming distace} (d) = \text{Number of 1's in } 00111000 \]
\[ d = 3 \]
This tells us that the two strings differ in 3 positions
</p>
</div>
</div>
<div id="outline-container-org440e101" class="outline-4">
<h4 id="org440e101"><span class="section-number-4">5.5.2.</span> Use of hamming distance</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
Hamming distance is used to define correct error detecting and error correcting codes.
</p>
<ul class="org-ul">
<li>A code is \(k\) error detecting (i.e, it can detect k single bit errors in a codeword), if and only if, the minimum Hamming distance between any two of its codewords is atleast \(k + 1\)</li>
<li>A code is \(k\) error correcting (i.e, it can correct k single bit errors in a codeword), if and only if, the minimum Hamming distance between any two of its codewords is atleast \(2k + 1\)</li>
</ul>

<p>
This is given by following two equations
\[ \text{Error Detection } : \text{Hamming Distance } \ge k + 1 \]
\[ \text{Error Correction } : \text{Hamming Distance } \ge 2k + 1 \]
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-org96075ce" class="outline-3">
<h3 id="org96075ce"><span class="section-number-3">5.6.</span> Error-Correcting codes</h3>
<div class="outline-text-3" id="text-5-6">
<p>
These codes are often <b>used in the physical layer</b>, particularly for noisy channels, and in higher levels for real-time media and content distribution.
</p>

<p>
There are four common error-correcting codes
</p>
<ol class="org-ol">
<li>Hamming codes</li>
<li>Binary Convolution codes</li>
<li>Reed-Solomon codes</li>
<li>Low-Density Parity Check codes</li>
</ol>
<p>
Most error-correcting codes have properties of being systematic code and linear code
</p>
<ul class="org-ul">
<li><b>Systematic code</b> : The <i>\(m\) data bits are sent directly, along with \(r\) check-bits</i>. So the \(m\) data bits are not encoded before transmission.</li>
<li><b>Linear code</b> : The <i>\(r\) check bits are computed as a linear function of the \(m\) data bits</i>. XOR  or modulo 2 addition is popular choice to compute the check bits. This means the encoding can be done with operations such as matrix multiplication or simple logic circuits.</li>
</ul>
</div>
<div id="outline-container-org5699270" class="outline-4">
<h4 id="org5699270"><span class="section-number-4">5.6.1.</span> Hamming code</h4>
<div class="outline-text-4" id="text-5-6-1">
<p>
Hamming code is a <b>error-correcting, linear code.</b> Because of hamming distance, we know that all \(2^n\) possible bit strings are not legal for error-correcting n-codewords.
</p>

<p>
The relation between number of data bits \(m\) and redundant bits \(r\) is,
<b>\[ \text{for 1 bit error-correcting codes } : 2^r \ge (m + r + 1) \]</b>
<i>This assures a hamming distance of atleast 3</i>, therefore allowing hamming code to correct 1-bit errors.
</p>

<p>
<b>Hamming code uses parity bit to get redundant bits</b>. Hamming code can use both even and odd parity
</p>
</div>
<div id="outline-container-org0a404c7" class="outline-5">
<h5 id="org0a404c7"><span class="section-number-5">5.6.1.1.</span> Creating hamming codeword</h5>
<div class="outline-text-5" id="text-5-6-1-1">
<ul class="org-ul">
<li>Redundant bits are stored at the \(2^i\) positions in the code word, so we store redundant bits \(r_1\), \(r_2\), \(r_4\), \(r_8\) &#x2026;. \(r_{2^i}\)</li>
<li>Remaining positions are for data bits \(m_i\)</li>
<li>\(r_{2^i}\) is the parity bit of data bits with positions, such that position number has 1 as the \(i^{th}\) LSB in binary form
\[ r_{2^i} = parity \left( \forall m_{(1\ at\ (i+1)^{th}\ LSB)} \right) \]</li>
</ul>
<p>
<i>Example,</i> the data bits are <b>\(1100101\)</b>.
<br />
number of data bits is 7, after using \((2^r \ge (m + r + 1))\), number of redundant bits is 4.
<br />
Therefore, in this case, we have a 11-codeword
<img src="./imgs/IMG_20230923_183757.jpg" alt="IMG_20230923_183757.jpg" />
Now, we can calculate parity for \(r_{2^i}\)'s. In this case, we assume we are using <i>even parity</i>
\[ r_1 = parity \left( \forall m_{(1\ at\ 1^{st}\ LSB)} \right) \]
\[ r_1 = parity \left( m_{0011}, m_{0101}, m_{0111}, m_{1001}, m_{1011} \right) \]
\[ r_1 = parity \left( 1,0,0,0,1 \right) = 0\]
Similarly,
\[ r_2 = parity \left( \forall m_{(1\ at\ 2^{nd}\ LSB)} \right) \]
\[ r_2 = parity \left( m_{0011}, m_{0110},m_{0111}, m_{1010}, m_{1011} \right) = 0 \]
<br />
</p>

<p>
\[ r_4 = parity \left( \forall m_{(1\ at\ 3^{rd}\ LSB)} \right) \]
\[ r_4 = parity \left( m_{0101},m_{0110},m_{0111} \right) = 1 \]
<br />
</p>

<p>
\[ r_8 = parity \left( \forall m_{(1\ at\ 4^{th}\ LSB)} \right) \]
\[ r_8 = parity \left( m_{1001}, m_{1010}, m_{1011} \right) = 0 \]
Therefore, the final transmitted codeword is
<img src="./imgs/IMG_20230923_183812.jpg" alt="IMG_20230923_183812.jpg" />
</p>
</div>
</div>
<div id="outline-container-orgd73018b" class="outline-5">
<h5 id="orgd73018b"><span class="section-number-5">5.6.1.2.</span> Error detection and correction</h5>
<div class="outline-text-5" id="text-5-6-1-2">
<p>
When the receiver gets the hamming codeword, it checks the parity again to decide if an error has occured and correct it. Same type of parity (even or odd) is used to decode the codeword as was used to create it
</p>
<ul class="org-ul">
<li>The parities are checked again, each checked parity will include the redundancy bits and the data bits that were used to get the redundancy bit</li>
<li>The concatnation of the checked parity bits will tell the position where single-bit error has occured. If no error has occured, then all checked parities are 0s</li>
</ul>
<p>
Example, let's assume from previous example, <i>the bit at 7th position got flipped</i>
<img src="./imgs/IMG_20230923_183846.jpg" alt="IMG_20230923_183846.jpg" />
</p>
<ul class="org-ul">
<li><p>
The first checked parity is for redundant bit \(r_1\), we will get it by cheking parity of \(r_1\) and the data bits that were used to compute it
\[ c_1 = parity \left( r_1, m_{0011}, m_{0101}, m_{0111}, m_{1001}, m_{1011} \right) \]
\[ c_1 = parity \left( 0, 1, 0, 1, 0, 1 \right) = 1 \]
Similarly, we <i>calculate \(c_i\) for all \(r_{2^{i-1}}\) in received codeword</i>
\[ c_2 = parity \left( r_2, m_{0011}, m_{0110},m_{0111}, m_{1010}, m_{1011} \right) \]
\[ c_2 = parity \left( 0,1,1,1,1,1  \right) = 1 \]
<br />
</p>

<p>
\[ c_3 = parity \left( r_4, m_{0101},m_{0110},m_{0111} \right) \]
\[ c_3 = parity \left( 1,0,1,1 \right) = 1 \]
<br />
</p>

<p>
\[ c_4 = parity \left( r_8, m_{1001}, m_{1010}, m_{1011} \right) \]
\[ c_4 = parity \left( 0,0,1,1 \right) = 0 \]
</p></li>
<li>The position we get by concatnating these bits is the position of the error, in our example position of error is \(c_4c_3c_2c_1\)
\[ c_4c_3c_2c_1 = 0111 \]
i.e, position 7 which is exactly where the error occured</li>
</ul>
<p>
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org57922cb" class="outline-3">
<h3 id="org57922cb"><span class="section-number-3">5.7.</span> Error-Detecting codes</h3>
<div class="outline-text-3" id="text-5-7">
<p>
These codes are commonly <b>used in data link layer, network layer and transport layer.</b>
Error-correcting codes are more useful on noisy and error prone channels (wireless). However, over higher quality channels we can use error-detecting codes to deal with the occasional errors.
</p>

<p>
There are three common error-detecting methods
</p>
<ol class="org-ol">
<li>Parity</li>
<li>Checksums</li>
<li>Cyclic Redundancy Checks (CRCs)</li>
</ol>
</div>
<div id="outline-container-orgeda17f8" class="outline-4">
<h4 id="orgeda17f8"><span class="section-number-4">5.7.1.</span> Parity</h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
TODO: Basic parity first (even parity odd parity)
</p>
</div>
<div id="outline-container-org5bb93a9" class="outline-5">
<h5 id="org5bb93a9"><span class="section-number-5">5.7.1.1.</span> Vertical Redundancy Check (VRC)</h5>
<div class="outline-text-5" id="text-5-7-1-1">
<p>
TODO : Here
</p>
</div>
</div>
<div id="outline-container-org8c113e2" class="outline-5">
<h5 id="org8c113e2"><span class="section-number-5">5.7.1.2.</span> Longitudinal Redundancy Check (LRC)</h5>
<div class="outline-text-5" id="text-5-7-1-2">
<p>
TODO : Here
</p>
</div>
</div>
</div>
<div id="outline-container-orgf444763" class="outline-4">
<h4 id="orgf444763"><span class="section-number-4">5.7.2.</span> Checksum</h4>
<div class="outline-text-4" id="text-5-7-2">
<p>
TODO : Here
</p>
</div>
</div>
<div id="outline-container-orgf606983" class="outline-4">
<h4 id="orgf606983"><span class="section-number-4">5.7.3.</span> Cyclic Redundancy Checks</h4>
<div class="outline-text-4" id="text-5-7-3">
<p>
CRC is an error-detecting code. It uses a polynomial with cofficients only 0 and 1 called the generator polynomial.
</p>

<p>
We will look at how to get redundant bit with
</p>

<p>
<i>Example,</i> A bit stream 1101011011 is transmitted using the standard CRC method. The generator polynomial is \(x^4+x+1\). What is the actual bit string transmitted?
</p>
</div>
<div id="outline-container-orgf5065db" class="outline-5">
<h5 id="orgf5065db"><span class="section-number-5">5.7.3.1.</span> Generator polynomial</h5>
<div class="outline-text-5" id="text-5-7-3-1">
<p>
The generator polynomial is what is used to get the redundant bits from the data. The first step is converting the generator polynomial to a bitstring.
</p>
<ul class="org-ul">
<li>The generator polynomial will only have 0's and 1's and coefficients</li>
<li>These coefficients are what are used to make the bit string</li>
</ul>
<p>
Example, the generator polynomial \(x^4 + x + 1\) is converted to bitstring as:
</p>
<ol class="org-ol">
<li>\(x^4 + x + 1 = \left( 1 \times x^4 + 0 \times x^3 + 0 \times x^2 + 1 \times x + 1 \times 1 \right)\)</li>
<li>Now we can get the coefficients \(1 0 0 1 1\), therefore the generator bitstring is \(10011\)</li>
</ol>
</div>
</div>
<div id="outline-container-org032336a" class="outline-5">
<h5 id="org032336a"><span class="section-number-5">5.7.3.2.</span> Data append bits</h5>
<div class="outline-text-5" id="text-5-7-3-2">
<p>
Before we can start to calculate the redundant bits, we need to append 0's to the LSB side of the data.
</p>

<p>
<i>The number of 0's appended to left is equal to (length of generator bitstring - 1)</i>
</p>

<p>
For our example, the generator bitstring in our example is \(10011\), which has length 5. So we need to append \((5 - 1) = 4\) bits to the data
</p>

<p>
So our data was previously \(1101011011\) and after appending 0's becomes \(11010110110000\)
</p>
</div>
</div>
<div id="outline-container-orgfc63b62" class="outline-5">
<h5 id="orgfc63b62"><span class="section-number-5">5.7.3.3.</span> Getting redundant bits</h5>
<div class="outline-text-5" id="text-5-7-3-3">
<p>
Now we will do special CRC division in-order to get the redundant bits. This division is paritally similar to our long division method
</p>
<ul class="org-ul">
<li>We will do <b>XOR on each step rather than subtraction</b></li>
<li>We will choose the next digit of divisor, so that result of LSB after XOR is 0</li>
<li><b>Only the MSB is discarded from XOR result</b></li>
<li>After ever XOR, we will discard the first bit of the result</li>
<li>Only a single bit is carried down always after discarding the bit</li>
<li>Our final CRC is remainder, when there are no more bits to carry down</li>
</ul>
<p>
Example, for the example we have seen so far, the division process is
</p>

<div id="org086ef4e" class="figure">
<p><img src="Data_Link_Layer/2023-12-03_04-09-05_WhatsApp Image 2023-12-03 at 4.08.35 AM.jpeg" alt="2023-12-03_04-09-05_WhatsApp Image 2023-12-03 at 4.08.35 AM.jpeg" />
</p>
</div>

<p>
The final remainder i.e, the CRC is \(1110\).
</p>
<ul class="org-ul">
<li><b>NOTE</b> : for generator bitstring of size \(n\), the size of CRC is \(n - 1\)</li>
</ul>
<p>
The CRC is the redundant bits
</p>
</div>
</div>
<div id="outline-container-orgb14c606" class="outline-5">
<h5 id="orgb14c606"><span class="section-number-5">5.7.3.4.</span> Transmitted data</h5>
<div class="outline-text-5" id="text-5-7-3-4">
<p>
The transmitted data is our original data (not the one with appended 0's) with the CRC at the LSB side, i.e, the rightmost side
</p>

<p>
In our example, the data is \(1101011011\) and CRC is \(1110\)
</p>
<ul class="org-ul">
<li>The transmitted data is \(cat(1101011011,1110)\) which is \(11010110111110\)</li>
</ul>
</div>
</div>
<div id="outline-container-orga25a962" class="outline-5">
<h5 id="orga25a962"><span class="section-number-5">5.7.3.5.</span> On receiver's side</h5>
<div class="outline-text-5" id="text-5-7-3-5">
<p>
The receiver will use the same division method with the same generator polynomial
</p>
<ul class="org-ul">
<li>If remainder is 0, then there are no errors</li>
<li>If remainder is not 0, then an error has occured</li>
</ul>
<p>
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbdcf06b" class="outline-3">
<h3 id="orgbdcf06b"><span class="section-number-3">5.8.</span> Flow control : Stop-and-wait ARQ</h3>
<div class="outline-text-3" id="text-5-8">
<p>
Flow control is managing the rate of data transmission between two machines to prevent fast sender from overwhelming a slow receiver.
</p>

<p>
If flow control is not implemented, then slow receiver is swamped with frames and may lose them even if transmission was error free.
</p>
<ul class="org-ul">
<li>Flow control is a done in data link layer and higher layers as well.</li>
<li>There are two common approaches to flow control
<ul class="org-ul">
<li><b>Feedback-based flow control</b> : used at both data link layer and higher layers, receiver sends feedback to sender, giving it permission to send more data, or atleast telling sender how receiver is doing</li>
<li><b>Rate-based flow control</b> : used only as part of transport layer, protocol has built-in mechanism that limits rate at which sender may transmit data, without relying on feedback from receiver.</li>
</ul></li>
<li>Rate-based flow control is more common in computer networks now, therefore data link layer hardware is designed to run fast enough that it does not cause loss, i.e. NICs are run at "wire speed", meaning they can handle frames as fast as they can arrive on link</li>
<li>So in modern networks, overruns are not usually a data link layer problem, they are handled by higher layers</li>
</ul>
</div>
<div id="outline-container-org468fa66" class="outline-4">
<h4 id="org468fa66"><span class="section-number-4">5.8.1.</span> Flow Control : Stop-and-Wait</h4>
<div class="outline-text-4" id="text-5-8-1">
<p>
Currently assume that communication channel is error free. We will look at error correction later.
</p>

<p>
<i>Stop-and-Wait is a feedback-based flow control</i>. Most feedback-based protocols have the following basic properties
</p>
<ul class="org-ul">
<li>Protocol contains well defined rules when sender may transmit next frame</li>
<li>Permission is given to sender either implicitly or explicitly</li>
</ul>
<p>
In case of stop-and-wait permission is given explicitly by receiver using acknowledgement frame.
</p>
<ul class="org-ul">
<li>After having passed a packet to its network layer, receiver sends a little dummy frame basck to sender, which gives sender permission to transmit the next frame.</li>
<li>After sending a frame, sender is required by protocol to wait until the dummy (i.e acknowledgement) frame arrives</li>
</ul>
<p>
This protocol has a strict alternation of flow: first sender sends a frame, then receiver sends a frame, then sender again sends a frame and so on. So <b>atleast a half-duplex physical channel</b> is required for this protocol.
</p>
</div>
</div>
<div id="outline-container-orgad1b46b" class="outline-4">
<h4 id="orgad1b46b"><span class="section-number-4">5.8.2.</span> Error Correction : Sequence Numbers and ARQ</h4>
<div class="outline-text-4" id="text-5-8-2">
<p>
In a channel frame may be either damaged or lost completely. If frame is damaged in transit, receiver hardware will detect this when it computes the checksum.
</p>

<p>
The naive approach is to depend on the timer. So if the frame is damaged, receiver discards the frame and when the timer on receiver's end goes off it will retransmit the frame.
</p>

<p>
The problem with this approach is that <b>acknowledgement sent back to the sender can also be lost or damaged, causing sender to retransmit a frame</b> that was already given to the network layer on receiver side.
<br />
To fix this, we use sequence numbers 
</p>
<ul class="org-ul">
<li>Sequence number will be added to the header of each frame. The receiver can read header to know if frame is duplicate or new frame. <b>If it is duplicate, it will be discarded and an acknowledgement is retransmitted</b></li>
<li><i>Ambiguity occurs only between any two consecutive frames</i>.</li>
<li><b>Therefore, a single bit is enough for sequencing</b>. So the sender's data link layer will do sequencing by adding 0 and 1 bit to headers alternatively</li>
<li>When receiver gets a valid frame, it only passes the next frame if it has modulo 2 bit (0 if 1, 1 if 0) of the previous passed frame.
<ul class="org-ul">
<li>Else it will discard the duplicate frame and resends its acknowledgement</li>
</ul></li>
</ul>
<p>
Protocols in which sender waits for positive acknowledgement or timers to send next frame are called <b>Automatic Repeat reQuest (ARQ)</b> or <b>Positive Acknowledgement with Retransmission (PAR)</b>.
</p>

<p>
When we pair this ARQ with Stop-and-Wait protocol, we get the <b>Stop-and-Wait ARQ</b> also called alternating bit protocol.
<img src="./imgs/Stop_and_wait_arq.png" alt="Stop_and_wait_arq.png" />
<hr />
</p>
</div>
</div>
</div>
<div id="outline-container-orga917c03" class="outline-3">
<h3 id="orga917c03"><span class="section-number-3">5.9.</span> Improving Efficiency</h3>
<div class="outline-text-3" id="text-5-9">
<p>
Upto now, data frames were transmitted in one direction only i.e, there was a sender and a receiver machine. But in most practical cases, there is need to transmit data in both directions. Additionally, to increase efficiency we send multiple frames at a time before getting acknowledgement.
</p>
</div>
<div id="outline-container-orgbf49fa9" class="outline-4">
<h4 id="orgbf49fa9"><span class="section-number-4">5.9.1.</span> Bidirectional Transmission : Piggybacking</h4>
<div class="outline-text-4" id="text-5-9-1">
<p>
A simple way to achieve simple full-duplex transmission is to run two instances of half-duplex protocol (like the stop-and-wait ARQ) on both machines.
</p>

<p>
But running half-duplex protocol on both will require two links, one for each running protocol. So we need a way to use two half-duplex protocol with a single link.
</p>

<p>
We already transmit frames in both directions (one direction for data frames and other for acknowledgement), so we will intermix the data frames from A to B, with acknowledgement frames from A to B and same for frames from B to A. The data link layer will look at the header of each frame to determine whether it is a acknowledgement or data frame (<i>kind</i> field in header is used).
</p>
</div>
<div id="outline-container-org0f8fa57" class="outline-5">
<h5 id="org0f8fa57"><span class="section-number-5">5.9.1.1.</span> Piggybacking</h5>
<div class="outline-text-5" id="text-5-9-1-1">
<p>
Although using <i>kind</i> field allows us full-duplex communication, the acknowledgement frames are very small in size when compared to data frames. So in order to have more efficient data transfer, we can have acknowledgement of the received frame be attached in the header of the frame that is to be sent next
</p>

<p>
<b>Rather than sending acknowledgement frame immediately, we will wait for the next data frame that is to be sent. This technique is called piggybacking.</b> The acknowledgement is added to the header of data frame in <i>ack</i> field.
</p>
</div>
</div>
<div id="outline-container-org5ece4c4" class="outline-5">
<h5 id="org5ece4c4"><span class="section-number-5">5.9.1.2.</span> Advantages of piggybacking</h5>
<div class="outline-text-5" id="text-5-9-1-2">
<ol class="org-ol">
<li>Better use of available channel bandwidth. Since the <i>ack</i> field only takes a few bits, whereas a seperate ACK frame will have its own header and checksum</li>
<li>Having fewer frames used for communication means that data transfer is faster</li>
<li>Sending fewer frames also reduces load on receiver</li>
</ol>
</div>
</div>
<div id="outline-container-org6670b52" class="outline-5">
<h5 id="org6670b52"><span class="section-number-5">5.9.1.3.</span> Problem with piggybacking (and it's solution)</h5>
<div class="outline-text-5" id="text-5-9-1-3">
<p>
The problem with piggybacking is deciding how long should data link layer avoid sending a ACK frame.
</p>
<ul class="org-ul">
<li>If data link layer on one side waits too long to send ACK, the link layer on other side will retransmit the frame</li>
<li>This is solved by having a receiver timeout. After a data frame is received, link layer will start a timer. If a packet is given to it by it's own network layer, then <i>ack</i> is attached to it otherwise a seperate ACK frame is sent.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org80d603e" class="outline-4">
<h4 id="org80d603e"><span class="section-number-4">5.9.2.</span> Multiple frames at a time : Sliding Windows</h4>
<div class="outline-text-4" id="text-5-9-2">
<p>
Sliding windows are class of bidirectional transmission protocols. 
</p>
<ul class="org-ul">
<li>In sliding window protocols, <b>each sent frame has a sequence number ranging from \(0\) to \((2^n - 1)\)</b>, where \(n\) is the number of bits for sequence numbers.</li>
<li>Sender maintains sequence number of frames, and is allowed to send a batch of sequence numbers within a <b>sending window</b></li>
<li>Similarly, receiver maintans a <b>receiving window</b> within which it is permitted to accept frames.</li>
<li>The sender's and receiver's <b>windows don't need to be of same size</b></li>
</ul>
<p>
The process of a sliding window is as follows:
</p>
</div>
<div id="outline-container-org2d62ac1" class="outline-5">
<h5 id="org2d62ac1"><span class="section-number-5">5.9.2.1.</span> On sender's side</h5>
<div class="outline-text-5" id="text-5-9-2-1">
<ul class="org-ul">
<li>When a packet arrives from network layer, it is given the next largest sequence number (wraps to zero).</li>
<li>After getting the sequence number, frame is appended to the upper edge of window</li>
<li>When acknowledgement frame for frame on lower edge arrives, the lower edge is advanced by one</li>
</ul>
<p>
This way, the frames in sender's window at any time are the unacknowledged frames.
</p>

<p>
Since the frames in sender's window are unacknowledged, they have to be kept in memory. Therefore, when window is full the network layer is paused till acknowledgement for some frames arrives
</p>

<p>
<i>Sender's window can "grow and shrink" based on number of unacknowledged frames</i>
</p>
</div>
</div>
<div id="outline-container-orgbe2450b" class="outline-5">
<h5 id="orgbe2450b"><span class="section-number-5">5.9.2.2.</span> On receiver's side</h5>
<div class="outline-text-5" id="text-5-9-2-2">
<ul class="org-ul">
<li>The receiver's window contains frame sequences that can be accepted</li>
<li>Initially, the receiver window starts with frame sequence \(0\) at the it's lower edge (at start)</li>
</ul>
<p>
On getting a frame :
</p>
<ul class="org-ul">
<li>If frame contains sequence within the window, it is accepted and acknowledgement is sent</li>
<li>If frame contains sequence outside the window, the frame is discarded and no ACK is sent</li>
<li>When receiver gets a frame with same sequence no. which is on the lower edge, the window is moved (slid) by one position</li>
</ul>
<p>
Unlike sender's window, <i>receiver's window is fixed in size</i>
<hr />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org0a2860d" class="outline-3">
<h3 id="org0a2860d"><span class="section-number-3">5.10.</span> Sliding Windows</h3>
<div class="outline-text-3" id="text-5-10">
<p>
We will look at two protocols that are in category of sliding windows. The first one (one-bit sliding window) is not a sliding window protocol but gives us a way to connect stop-and-wait ARQ to sliding windows
</p>
</div>
<div id="outline-container-org2edc59c" class="outline-4">
<h4 id="org2edc59c"><span class="section-number-4">5.10.1.</span> Properties of sliding window protocols</h4>
<div class="outline-text-4" id="text-5-10-1">
<p>
Before looking at Go-Back-N and Selective Repeat protocols, we will look at shared properties of sliding window protocols
</p>
</div>
<div id="outline-container-org378051f" class="outline-5">
<h5 id="org378051f"><span class="section-number-5">5.10.1.1.</span> Bandwidth-Delay Product</h5>
<div class="outline-text-5" id="text-5-10-1-1">
<p>
The bandwidth-dealy product is the amount of data that can be sent continuously by the sender, before the first acknowledgement from receiver arrives.
\[ \text{Bandwidth-Delay Product} = \text{Bandwidth} \times \text{Round-Trip Delay}  \]
\[ BD = B \times D \]
Example, in the previous example Bandwidth is \(50kbps\) and Round-Trip Delay is \(500ms\), therefore the Bandwidth-Delay Product is
\[ BD = 50kbps \times 500ms \]
\[ BD = 25kb \]
</p>
</div>
</div>
<div id="outline-container-org88ab20c" class="outline-5">
<h5 id="org88ab20c"><span class="section-number-5">5.10.1.2.</span> Optimal/Maximum Window Size</h5>
<div class="outline-text-5" id="text-5-10-1-2">
<p>
For sliding window protocols, we want to maximize the size of window, such that everytime sender's window is almost full a ACK will arrive.
<b>\[ \text{optimal/maximum window size} = ceil \left( \frac{BD}{\text{Frame size}} \right) \]</b>
Since, \(BD = B \times D\), and \(D = 2T_p\)
\[ \text{optimal/maximum window size} = ceil \left( \frac{B \times 2T_p}{\text{Frame size}} \right) \]
Since, \(T_t = \text{Frame Size} / B\)
<b>\[ \text{optimal/maximum window size} = ceil \left( \frac{2T_p}{T_t} \right) \]</b>
</p>
</div>
</div>
<div id="outline-container-org7af1c72" class="outline-5">
<h5 id="org7af1c72"><span class="section-number-5">5.10.1.3.</span> Pipelining</h5>
<div class="outline-text-5" id="text-5-10-1-3">
<p>
Pipelining is sending multiple packets without waiting for their seperate acknowledgements. The main goal for all sliding window protocols is to have efficient pipelining of packets through the data link.
</p>
</div>
</div>
</div>
<div id="outline-container-org2adec44" class="outline-4">
<h4 id="org2adec44"><span class="section-number-4">5.10.2.</span> One-Bit Sliding Window (Stop-and-Wait ARQ)</h4>
<div class="outline-text-4" id="text-5-10-2">
<p>
A one-bit sliding window means the <b>window size is 1</b>. This protocol uses the simple <b>stop-and-wait ARQ</b> since sender window is full after sending a single frame and has to wait for acknowledgement.
</p>

<p>
<b>Example</b>, Suppose there is a channel with bandwidth \(50kbps\) and round-trip propogation delay is \(500ms\)
\[ \text{Bandwidth}(B) = 50 kbps \]
\[ \text{Round-trip Propogation delay}(D) = 500 ms \]
Therefore,
\[ \text{Propogation delay}(T_p) = 250 ms \]
</p>

<p>
Suppose we want to send a \(1000bit\) frame with Stop-and-Wait ARQ
\[ \text{Transmission delay}(T_t) = \frac{1000 bit}{50 kbps} \]
\[ T_t = 20ms \]
\[ \text{Total time taken to deliver data frame} = T_t + T_p \]
\[ \text{Total time taken to deliver data frame} = 250ms + 20ms = 270ms \]
And for the returning acknowledgement frame
\[ \text{Since acknowledgement frame size is very samll, we can neglect its transmission delay} \]
\[ T_t = 0 \]
\[ T_p = 250ms \]
\[ \text{Total time taken to deliver ACK frame} = 250ms \]
Therefore, for a sending a single frame and receiving it's ACK, stop and wait takes total \(270ms + 250ms = 520ms\) time.
</p>
</div>
</div>
<div id="outline-container-orgbe9c1bc" class="outline-4">
<h4 id="orgbe9c1bc"><span class="section-number-4">5.10.3.</span> Go-Back-N ARQ</h4>
<div class="outline-text-4" id="text-5-10-3">
<p>
The difference between Go-Back-N and Selective Repeat is how they deal with errors.
</p>
<ul class="org-ul">
<li>In Go-Back-N ARP, <i>the sender's window is of size \(N\) and the receiver's window is of size \(1\).</i></li>
<li><i>If a frame is lost, all incoming frames are discarded</i>, i.e, receiver will refuse all frames except the next one in the sequence. This is because receiver window is of size 1</li>
<li>By the time sender's link layer timeout's, the pipeline will be empty. On timeout, sender will start retransmitting frames from the lost frame in order again.</li>
</ul>
<p>
This is why protocol is named Go-Back-N, because the sender goes back and restarts the sequence of frames. This works well on channels with very low error rates, but is channel is noisy it wastes a lot of bandwidth
</p>

<p>
The properties of Go-Back-N are:
</p>
<ul class="org-ul">
<li>Uses Cumulative Acknowledgement</li>
<li>Does not used Negetive Acknowledgement</li>
</ul>
</div>
</div>
<div id="outline-container-org9ec71b4" class="outline-4">
<h4 id="org9ec71b4"><span class="section-number-4">5.10.4.</span> Selective Repeat ARQ</h4>
<div class="outline-text-4" id="text-5-10-4">
<p>
The selective repeat ARQ is better for unreliable channels
</p>
<ul class="org-ul">
<li><i>The sender's window and receiver's window are both bigger than \(1\) and of equal size</i></li>
<li><i>This protocol allows receiver to accept any frame in the receiver's window, but window is slid forward only if frame on lower edge is received</i></li>
<li>A <b>negetive acknowledgement</b> (NAK), is sent for the frame which is lost, which it detects when an out of sequence frame is received.</li>
<li>NAK will stimulate retransmission from sender without having to wait for timeout, which improves performance</li>
</ul>
<p>
These two approaches have trade-offs between efficient use of bandwidth and data link layer buffer space.
</p>

<p>
The properties of Selective Repeat ARQ are:
</p>
<ul class="org-ul">
<li>Uses Independent Acknowledgement</li>
<li>Uses Negetive Acknowledgement</li>
</ul>
</div>
</div>
<div id="outline-container-org419c99c" class="outline-4">
<h4 id="org419c99c"><span class="section-number-4">5.10.5.</span> Properties of Go-Back-N and Selective Repeat</h4>
<div class="outline-text-4" id="text-5-10-5">
<p>
Now we will look at the properties of Go-Back-N and Selective Repeat protocols
</p>
</div>
<div id="outline-container-orgc819bcf" class="outline-5">
<h5 id="orgc819bcf"><span class="section-number-5">5.10.5.1.</span> Cumulative ACK vs Independent ACK</h5>
<div class="outline-text-5" id="text-5-10-5-1">
<p>
Go-Back-N uses Cumulative Acknowledgements
</p>
<ul class="org-ul">
<li>After sender stops sending frames, the receiver will send the ACK for the last frame it received correctly
<ul class="org-ul">
<li><b>NOTE :</b> Go-Back-N receiver only receives frames in correct seqence</li>
</ul></li>
<li>Sender will check this ACK to know from where it has to go-back and resend the frames</li>
<li>In case no ACK from receiver arrives, sender will send all frames in it's window in sequence again</li>
</ul>

<p>
Selective Repeat uses Independent ACK
</p>
<ul class="org-ul">
<li>This means that each frame that the receiver window receives, it will send an acknowledgement for it</li>
<li>In case ACK of a frame is lost, sender will send it again, in which case receiver window will resend ACK</li>
</ul>
</div>
</div>
<div id="outline-container-org68f4e64" class="outline-5">
<h5 id="org68f4e64"><span class="section-number-5">5.10.5.2.</span> Relation between sequence numbers and window sizes</h5>
<div class="outline-text-5" id="text-5-10-5-2">
<p>
We need to make sure that window size is small enought that it does not contain overlap sequence numbers. This is done by setting as follows
\[ \text{Window Size} = \frac{\text{Maximum sequence number} + 1}{2} \]
Suppose sequence number uses \(n\) bits, then the window size is given by
\[ \text{Window Size} = \frac{2^{n}}{2} \]
</p>
</div>
</div>
<div id="outline-container-orgb654ee5" class="outline-5">
<h5 id="orgb654ee5"><span class="section-number-5">5.10.5.3.</span> Negetive ACK (NAK)</h5>
<div class="outline-text-5" id="text-5-10-5-3">
<p>
Selective repeat uses Negative ACK to improve performance
</p>
<ul class="org-ul">
<li>If receiver window receives a frame out of sequence, it will store it in it's window. But it will also send back a NACK frame back</li>
<li>This Negetive ACK frame will tell sender that one frame was missing from sequence</li>
<li>On receing NACK for a frame, sender will resend that frame. If receiver gets it successfully this time, then it will send an ACK frame for it</li>
</ul>
</div>
</div>
<div id="outline-container-orgaf7a369" class="outline-5">
<h5 id="orgaf7a369"><span class="section-number-5">5.10.5.4.</span> Efficiency</h5>
<div class="outline-text-5" id="text-5-10-5-4">
<p>
\[ \text{For Stop-and-wait ARQ : } Efficiency = \frac{1}{1 + 2a} \]
\[ \text{For Go-Back-N ARQ : } Efficiency = \frac{N}{1 + 2a} \]
\[ \text{For Selective Repeat ARQ : } Efficiency = \frac{N}{1 + 2a} \]
where, \(a = \frac{T_p}{T_t}\)
</p>

<p>
TODO : show where this comes from maybe
<hr />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org991dd62" class="outline-2">
<h2 id="org991dd62"><span class="section-number-2">6.</span> Medium Access Control Sublayer</h2>
<div class="outline-text-2" id="text-6">
<p>
The data link layer assumes that the user has complete control over the data link. But in reality, the same link is used by multiple devices on both end. These are referred to as <b>broadcast channels, or multiaccess channels</b>
</p>

<p>
The medium access control sublayer has protocols which decide the device which has control over the medium currently. This sublayer is extremely important for LANs specially, where multiple devices are on same channel (example, wifi).
</p>

<p>
Note: technically, the MAC sublayer is below the data link layer. So it is between physical layer and data link layer
</p>

<p>
<b>Functions of MAC sublayer :</b>
</p>

<ul class="org-ul">
<li>provide abstraction of physical layer to upper layers</li>
<li>resolve addressing in the LAN</li>
<li>multiple access resolution in multiaccess channels</li>
<li>collission resolution</li>
</ul>

<p>
<b>Collision :</b>
</p>

<p>
If two frames are transmitted simultaneously, they overlap and resulting data is garbaled. This is called a <b>collision</b>. Resolving collisions is also the duty of MAC sublayer
</p>

<p>
<b>MAC Address :</b>
</p>

<p>
MAC address is a unique identifier alloted to Network Interface Card (NIC) of each device. It is used as address for transmission within the LAN (Example, there are multiple devices connected to same WiFi, the MAC address is used for addressing the devices)
</p>
<ul class="org-ul">
<li>MAC addresses are hardcoded or hardwired into the NIC from the manufacturer, it can't be changed</li>
<li>comprises of six groups of two hexadecimal digits, Example, 00:0A:89:5B:F0:11</li>
</ul>
</div>
<div id="outline-container-org8269377" class="outline-3">
<h3 id="org8269377"><span class="section-number-3">6.1.</span> Multiple Access Protocols</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A single channel can be in use by multiple devices, and they may transmit a frame to channel at same time. If two frames are transmitted simultaneously, they overlap and resulting data is garbaled; this is called collision. To avoid collisions, we need protocols that tell devices when to transmit a frame, these protocols are called Multiple Access Protocols
</p>

<p>
The protocols used for multiple access are divided into three parts
</p>

<div id="orga0fb9e3" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-21_22-01-10_screenshot.png" alt="2023-10-21_22-01-10_screenshot.png" />
</p>
</div>
</div>
<div id="outline-container-orgd79553e" class="outline-4">
<h4 id="orgd79553e"><span class="section-number-4">6.1.1.</span> ALOHA</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
The first ALOHA system has made at University of Hawaii. There are two versions of ALOHA : Pure ALOHA treats time to be continuous, i.e, the devices can start sending packet at any time. Slotted ALOHA divides time into discrete slots into which all frames are fitted
</p>
</div>

<div id="outline-container-orgd153355" class="outline-5">
<h5 id="orgd153355"><span class="section-number-5">6.1.1.1.</span> Pure ALOHA</h5>
<div class="outline-text-5" id="text-6-1-1-1">
<p>
The pure ALOHA protocol is the original ALOHA system. It uses acknowledgements in order to detect collissions. Suppose two sender's transmit packet at the same time and they collide
</p>
<ul class="org-ul">
<li>On the receiver's side the checksums (error detecting codes) will fail. So they won't transmit any acknowledgements</li>
<li>After the timeout on sender's machines, if they both retransmit again, the collision will happen again</li>
<li>To avoid this, every sender will wait for a random (\(T_B\)) time before it can try retransmission. This is called <i>back-off time.</i></li>
<li>The number of times the retransmission fails is store in the variable \(K\)</li>
<li>If \(K\) ever becomes greater than some \(K_{max}\), we will abort the whole process to try later</li>
</ul>


<div id="org4c3de73" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-22_00-36-36_screenshot.png" alt="2023-10-22_00-36-36_screenshot.png" />
</p>
</div>

<p>
We usually calculate \(T_B\) as \(T_B = R \times T_p\) or \(T_B = R \times T_t\), where \(R\) is some random number between \(0\) and \(2^k - 1\). \(T_p\) is propogation delay and \(T_t\) is the transmission delay, so either one of them is used. This method is named <i>binary exponential back-off</i>.
</p>

<p>
\(K_{max}\) is most commonly chosen as 15
</p>

<p>
<b>NOTE :</b> In ALOHA systems, transmission delay \(T_t\), is also sometimes called frame transmission time \(T_f\)
</p>

<p>
<b>Performace of Pure ALOHA :</b>
</p>

<ul class="org-ul">
<li>Transmission delay (time to transmit one frame) is \(T_t\)</li>
<li>Average number of transmissions in time \(T_t\) is \(G\)</li>
</ul>
<p>
Suppose a packet starts transmission at any time \(t\). If we want this packet to complete transmission without collision, no other packet should start transmission between \((t - T_t)\) and \((t + T_t)\).
</p>

<p>
This is shown by the following diagram
</p>


<div id="org5c7e8ba" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-22_10-57-42_screenshot.png" alt="2023-10-22_10-57-42_screenshot.png" />
</p>
</div>

<p>
Therefore, the vulnerable time for transmission is
\[ \text{vulnerable time} = (t + T_t) - (t - T_t) = 2T_t \]
Since average number of packets in time \(T_t\) is \(G\), the number of packets in time \(2T_t\) is \(2G\)
</p>

<p>
Using the poisson distribution, the probability of \(k\) frames in time period of \(2T_t\) is
\[ P(k) = \frac{(2G)^k e^{-2G}}{k!} \]
Collission won't occur when \(P(0)\), therefore the probability of zero collissions is
\[ P(0) = e^{-2G} \]
</p>

<p>
The throughput is given by \(S = G \times P(0)\). So <i>throughput for a pure ALOHA system</i>
\[ S = G \times e^{-2G} \]
Where, \(G\) is the average number of frames in transmission time \(T_t\) and \(S\) is throughput
</p>
</div>
</div>

<div id="outline-container-org805ed5e" class="outline-5">
<h5 id="org805ed5e"><span class="section-number-5">6.1.1.2.</span> Slotted ALOHA</h5>
<div class="outline-text-5" id="text-6-1-1-2">
<p>
The slotted ALOHA was made to increase the throughput of the pure ALOHA system.
</p>
<ul class="org-ul">
<li>Time is divided into discrete slots of size \(T_t\)</li>
<li>A frame can only start transmission at the start of the time slot and has to finish transmission before end of time slot</li>
<li>This decreases the vulnerable time window to only within the time slot of \(T_t\)</li>
</ul>
<p>
Using our previous calculations, in time slot \(T_t\), the average number of frames generated is \(G\)
</p>

<p>
So within the vulnerable window of \(T_t\), the probability of \(k\) frames is
\[ P(k) = \frac{G^k e^{-G}}{k!} \]
and the probability of no collissions is
\[ P(0) = e^{-G} \]
</p>

<p>
Therefore, the <i>throughput of slotted ALOHA is</i>
\[ S = G \times P(0) \]
\[ S = G \times e^{-G} \]
Where, \(G\) is the average number of frames in transmission time \(T_t\) and \(S\) is throughput
The comparision of throughputs for pure ALOHA and slotted ALOHA system is
</p>


<div id="org6fd84eb" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-22_11-20-23_screenshot.png" alt="2023-10-22_11-20-23_screenshot.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org0315f7f" class="outline-4">
<h4 id="org0315f7f"><span class="section-number-4">6.1.2.</span> Carrier Sense Multiple Access Protocols (CSMA/CD)</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
Carrier Sense means that node can sense whether the channel is already being used by some other node. Therefore, it will only try to transmit a frame if channel is not already in use. This reduces the number of possible collissions.
</p>
<ul class="org-ul">
<li>Though CSMA reduces the possibility of a collision, it cannot eliminate it. <i>The possibility of collision still exists due to propogation delay</i></li>
</ul>
<p>
After a node senses that channel is idle, we still need some way or method to tell if a node should use it or not
</p>

<p>
<b>1-persistent method :</b>
</p>

<p>
The 1-persistent method is the simplest method.
</p>
<ul class="org-ul">
<li>The channel is continuously being sensed by all the nodes that want to transmit</li>
<li>As soon as a node finds that channel is idle, it will immediately try to transmit</li>
<li>But this method <i>has high chance of collission</i> since multiple nodes may try to transmit as soon as channel is idle</li>
</ul>

<p>
<b>No Persistent method :</b>
</p>

<p>
In no persistent method, 
</p>
<ul class="org-ul">
<li>The channel is not being continuously sensed by all nodes that want to transmit</li>
<li>Node will check if the channel is idle, if it is idle it will try to transmit the frame</li>
<li>If it is not idle, the node will <i>wait for random amount of time</i></li>
</ul>
<p>
Since it is unlikely that two nodes will wait the same amount of time, the chance of collision is reduced. But the no persistent method <i>reduces efficiency, since there may be times when channel is idle but no node is using it.</i>
</p>

<p>
<b>p-persistent method :</b>
</p>

<p>
This method is used in slotted channels (transmission can start only at start of a time slot).
</p>
<ul class="org-ul">
<li>The channel is sensed at the start of a time slot, <i>one of the two cases will occur</i>
<ul class="org-ul">
<li><i>If channel is idle</i>, frame will be transmitted with probability \(p\). Otherwise, retry transmission at the start of next time slot</li>
<li><i>If channel is busy</i>, act as if collision occured and wait for back-off time</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7c082f7" class="outline-5">
<h5 id="org7c082f7"><span class="section-number-5">6.1.2.1.</span> Minimum frame size for CSMA and Efficiency, Throughput</h5>
<div class="outline-text-5" id="text-6-1-2-1">
<p>
In order for CSMA to work, the minimum size of a frame is given as
\[ \text{lenght of packet} \ge 2 \times T_p \times Bandwidth \]
\[ \text{lenght of packet} \ge \text{Bandwidth-Delay Product} \]
The efficiency is given by
\[ Efficiency = \frac{1}{e^{2a} + a + 1} = \frac{1}{1 + 6.44a} \]
where, \(a = \frac{T_p}{T_t}\)
\[ Throughput = Efficiency \times Bandwidth \]
</p>

<p>
TODO : these probably need more explanation
</p>
</div>
</div>
</div>
<div id="outline-container-orgd0f15a6" class="outline-4">
<h4 id="orgd0f15a6"><span class="section-number-4">6.1.3.</span> CSMA with Collision Avoidance (CSMA/CA)</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Because CSMA do not completely avoid collisions, it would be better for bandwidth if stations could quickly detect a collision and stop transmission. This is known as CSMA with Collision Detection and is the <i>basis for classic Ethernet</i>.
</p>
<ul class="org-ul">
<li>Collision detection is an <b>analog process</b></li>
<li>The station's <b>hardware</b> must listen to the channel while it is transmitting. That is the station will transmit and listen to the signal at the same time</li>
<li>If the signal it reads back different from the signal it is putting out, a collision has occured</li>
<li>Since the signal that is transmitted and that read are to be compared, they must not have a huge difference in signal strength. This is what makes <i>Collision Detection harder for wireless mediums</i></li>
</ul>
<p>
In CSMA/CA protocol, we have three distinct periods of time
</p>
<ul class="org-ul">
<li>Transmission period : The period during which one of the station is transmitting is called the transmission period</li>
<li>Idle period / Inter frame space : The period during which no transmission happens and no station want to transmit frames. Therefore, it is the period in which all the stations are quiet. <i>Inter Frame Space</i> is the idle time that is inserted everytime between contention period and transmission period, this helps avoid collisions in case some station is taking abnormal pause for transmitting a frame</li>
<li>Contention period : The period during which channel is idle and one or more nodes / stations want to transmit frames is called the contention period. During the contention period, the <b>stations will send a very small dummy frame to check if they can "seize" the line</b></li>
</ul>
</div>
<div id="outline-container-org46b0e78" class="outline-5">
<h5 id="org46b0e78"><span class="section-number-5">6.1.3.1.</span> Contention window / Contention slots</h5>
<div class="outline-text-5" id="text-6-1-3-1">
<p>
The contention period is divided into multiple windows or slots. At the start of each slot, the stations that want to transmit will try to seize the line
</p>
<ul class="org-ul">
<li>The size of the contention window depends on the minimum time taken to detect a collision.</li>
<li>Since the dummy frame used to check if it is same to seize channel, the transmission delay \(T_t\) is negligable during contention period i.e, \(T_t = 0\)</li>
<li>Suppose the two farthest stations \(A\) and \(B\) want to transmit. Assume the propogation delay between them is \(T_p\)
<ul class="org-ul">
<li>\(A\) transmits the dummy frame at some time \(t_0\).</li>
<li>Suppose at an instant just before \(t_0 + T_p\), \(B\) transmits the dummy frame</li>
<li>The collision happens just before the station \(B\), therefore it stops transmission immediately</li>
<li>But the noise from collision will take \(T_p\) time to return to station \(A\)</li>
<li>Therefore <b>station needs to wait atleast for time \(2T_p\) before it can seize the channel</b></li>
</ul></li>
</ul>
<p>
Therefore, the size of contention slot is
\[ \text{size of contention slot} \ge 2 \times T_p \]
TODO : image for CSMA/CA
</p>
</div>
</div>
</div>
<div id="outline-container-org4dc10d6" class="outline-4">
<h4 id="org4dc10d6"><span class="section-number-4">6.1.4.</span> Reservation</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
In this method, a node / station needs to make a reservation before sending data. This protocol has two period : a reservation interval and data transmission interval.
</p>
<ul class="org-ul">
<li>Suppose there are \(8\) stations on the channel, then there will be \(8\) slots in the reservation interval. In general if there are \(N\) stations, the reservation interval has \(N\) slots</li>
<li>Each station is allowed to book a reservation for itself within it's time slot during reservation interval. If it misses the chance to book a reservation, it must wait till the next reservation interval for it's next slot</li>
<li>All stations that sucessfully got a reservation get to transmit a frame during the data transmission period. They will transmit the frame in order in which slots are booked</li>
</ul>


<div id="orgdde32c1" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-29_18-35-24_screenshot.png" alt="2023-10-29_18-35-24_screenshot.png" />
</p>
</div>

<p>
<b>Performace</b>
</p>

<p>
During the reservation interval, the very first station (station \(0\)) has to wait for \(N -1\) slots before transmission period begins. For last station, it has to wait \(0\) slots and so on.
</p>
<ul class="org-ul">
<li>Therefore the stations \(0,1,2...N-1\) have to wait \(N-1,N-2,...,0\) slots respectively before transmission period</li>
<li>Therefore, on average evey station waits for \(N\) slots. If a slot is of time teriod \(s\), the average time each slot waits during reservation is \(s \times N\)</li>
</ul>
<p>
Suppose the size of a frame is \(d\)
</p>
<ul class="org-ul">
<li>For <i>low loads</i> the efficiency of channel is \(\frac{d}{d+sN}\), we usually consider \(s = 1\) then <i>efficiency is \(\frac{d}{d+N}\)</i></li>
<li>For <i>high loads</i> the <i>efficiency is \(\frac{d}{d+1}\)</i></li>
</ul>
</div>
</div>

<div id="outline-container-org132e331" class="outline-4">
<h4 id="org132e331"><span class="section-number-4">6.1.5.</span> Polling</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
In polling, the channel has a <b>primary station</b>. All the frames have to pass through the primary station.
Suppose station \(A\) wants to transmit a frame to the station \(B\)
</p>
<ul class="org-ul">
<li>The frame goes from station \(A\) to primary station during a <b>poll</b></li>
<li>The frame is then sent from primary station to the station \(B\) by <b>select</b></li>
</ul>
</div>
<div id="outline-container-orgc7138f2" class="outline-5">
<h5 id="orgc7138f2"><span class="section-number-5">6.1.5.1.</span> Poll</h5>
<div class="outline-text-5" id="text-6-1-5-1">
<p>
The primary station sequentially sends a POLL frame to all the other stations.
</p>
<ul class="org-ul">
<li>If the station receiving POLL doesn't need to transmit a frame, it will send a "poll reject" frame (NACK) to primary station</li>
<li>If the station receiving POLL wants to transmit a frame, it will send a data frame. The primary station sends back ACK on receiving the data frame</li>
</ul>


<div id="org0f30cc1" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-29_20-41-44_screenshot.png" alt="2023-10-29_20-41-44_screenshot.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org62f6646" class="outline-5">
<h5 id="org62f6646"><span class="section-number-5">6.1.5.2.</span> Select</h5>
<div class="outline-text-5" id="text-6-1-5-2">
<p>
After primary station receives a frame, it will transfer it to destination station via a select (SEL)
</p>
<ul class="org-ul">
<li>The primary station sends select frame (SEL) to the destination station</li>
<li>The destination station sends back an ACK, accepting the data frame</li>
<li>The primary station then sends the data frame</li>
<li>When received successfully, the destination will return the ACK to primary station</li>
</ul>


<div id="orgaa7bd8c" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-29_20-44-49_screenshot.png" alt="2023-10-29_20-44-49_screenshot.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orga20a960" class="outline-5">
<h5 id="orga20a960"><span class="section-number-5">6.1.5.3.</span> Efficiency</h5>
<div class="outline-text-5" id="text-6-1-5-3">
<p>
Suppose polling on average is taking time \(T_{poll}\) and on average transmission of data is taking time \(T_t\). Then,
\[ Efficiency = \frac{T_t}{T_t + T_{poll}} \]
</p>
</div>
</div>
</div>

<div id="outline-container-org0889888" class="outline-4">
<h4 id="org0889888"><span class="section-number-4">6.1.6.</span> Token Passing</h4>
<div class="outline-text-4" id="text-6-1-6">
<p>
Token passing is common in ring topologies though it is not exclusive to them. In other topologies we can form a logical ring to emulate rings.
</p>
<ul class="org-ul">
<li>This protocol uses a small frame called a <b>token</b> to give control to transmit to the stations</li>
<li>The token is passed in a ring in a pre-defined direction</li>
<li>If the station that currently holds the token has some frames queued to transmit, it will transmit them</li>
<li>Else the token is passed to it's successor in the ring</li>
</ul>


<div id="org0510272" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-29_23-29-47_screenshot.png" alt="2023-10-29_23-29-47_screenshot.png" />
</p>
</div>

<p>
<b>Logical Ring</b>
</p>

<p>
In case the topology is not a ring topology, we can simply have a logical ring.
</p>
<ul class="org-ul">
<li>In the logical ring, each node will have a successor and a predecessor</li>
<li>After a node has completed transmission, it can pass the token to the successor node</li>
</ul>
<p>
For example, a bus topology in which every node knows it's predecessor and successor's address can form a logical ring to pass token. This protocol is called <b>token bus</b>. This bus ring topology was previously standardized in IEEE 802.4 (now depricated)
</p>

<div id="org9188b90" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-29_23-35-23_screenshot.png" alt="2023-10-29_23-35-23_screenshot.png" />
</p>
</div>

<p>
<b>Performance</b>
</p>

<p>
\[ Delay (\alpha) = \frac{T_p}{N \times T_t} \]
\[ Throughput (S) = \begin{cases} \frac{1}{1 + \alpha} & \text{if $T_p < T_t$} \\ \frac{T_t}{T_p + \alpha T_t} & \text{if $T_p > T_t$} \end{cases} \]
</p>
</div>
</div>
</div>

<div id="outline-container-org8b9d90a" class="outline-3">
<h3 id="org8b9d90a"><span class="section-number-3">6.2.</span> Ethernet</h3>
<div class="outline-text-3" id="text-6-2">
<p>
There are two types of ethernet : <b>classic ethernet</b> also called standard ethernet, which uses the multiple access protocols; and <b>switched ethernet</b>, which uses devices called switches
</p>


<div id="org9783c54" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-30_22-13-17_screenshot.png" alt="2023-10-30_22-13-17_screenshot.png" />
</p>
</div>
</div>
<div id="outline-container-org814a0ad" class="outline-4">
<h4 id="org814a0ad"><span class="section-number-4">6.2.1.</span> Standard Ethernet : MAC sublayer</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
The MAC sublayer of classic ethernet governs the access method. The MAC layer is also responsible for framing of data in the classic Ethernet
</p>
</div>
<div id="outline-container-org1ea90c5" class="outline-5">
<h5 id="org1ea90c5"><span class="section-number-5">6.2.1.1.</span> Frame Format</h5>
<div class="outline-text-5" id="text-6-2-1-1">
<p>
A frame in classic ethernet frame contains seven fields :
</p>
<ol class="org-ol">
<li>Preamble (7 bytes) : The first field of frame is 7 bytes (56 bits) of alternating 0's and 1's (each byte is \(10101010\)). The preamble is added at physical layer and is not formally part of the frame. It alters receiving system that frame is coming and to <i>synchronize input timing</i></li>
<li>Start Frame Delimiter (SFD) (1 byte) : Signals the start of frame. It is the last chance for station to synchronize. It's value is \(10101011\), i.e, last two bits are \(1\) and rest is same as preamble byte</li>
<li>Destination Address (DA) (6 bytes) : The physical address (MAC address) of the destination station</li>
<li>Source Address (SA) (6 bytes) : The MAC address of the source station</li>
<li>Length or type (2 bytes) : in original ethernet, this field was used to define upper-layer protocols using MAC frame. In IEEE ethernet, this field is used to store length of data</li>
<li>Data : this field carries data from upper-layers. Minimum size is 46 bytes and maximum is 1500 bytes. If data from upper layers is less than 46 bytes, it is padded. <i>The lower limit exists for correct operation of CSMA/CD</i>. The upper limit is for two reasons
<ul class="org-ul">
<li>historically, memory was expensive so upper limit ensured low memory usage of stations</li>
<li>the maximum length restricts single station from monopolizing the shared medium</li>
</ul></li>
<li>CRC (4 bytes) : the error detection information. It is CRC-32 of data field</li>
</ol>


<div id="orgb811f09" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-31_22-54-42_screenshot.png" alt="2023-10-31_22-54-42_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org5f408b2" class="outline-5">
<h5 id="org5f408b2"><span class="section-number-5">6.2.1.2.</span> Addressing</h5>
<div class="outline-text-5" id="text-6-2-1-2">
<p>
Every station has it's own network interface card (NIC) with a unique MAC address. It is a 6-byte (48-bits) physical address. It is written with each byte in hexadecimal notation seperated by a colon. The six fields are called six octats
<br />
Example, 06:01:02:01:2C:4B
</p>

<p>
A source address is always unicast, since a frame has to originate from a single machine. But the destation of a frame can be multiple stations. In this case, the destination frame is a multicast address.
</p>
<ul class="org-ul">
<li>A unicast destination address means the frame is sent to a single destination station.
<ul class="org-ul">
<li>The relationship between sender and receiver is one-to-one.</li>
<li>If LSB of first byte in MAC address is 0, it is unicast address. (i.e, first octat number is even)</li>
</ul></li>
<li>A multicast destination address means the frame is sent to multiple destination station.
<ul class="org-ul">
<li>The relationship between sender and receiver is one-to-many.</li>
<li>If LSB of first byte in MAC address is 1, it is a multicast address (i.e, first octat number is odd)</li>
</ul></li>
</ul>


<div id="org1eb6055" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-10-31_23-19-13_screenshot.png" alt="2023-10-31_23-19-13_screenshot.png" />
</p>
</div>

<p>
The <b>broadcast address is FF:FF:FF:FF</b>
</p>
<ul class="org-ul">
<li>it is a special case of multicast address</li>
<li>the recipients are all of the stations on the LAN</li>
</ul>
</div>
</div>
<div id="outline-container-orgd756e8a" class="outline-5">
<h5 id="orgd756e8a"><span class="section-number-5">6.2.1.3.</span> Access method : CSMA/CD</h5>
<div class="outline-text-5" id="text-6-2-1-3">
<p>
Standard ethernet uses I-persistent CSMA/CD. The time given to a slot is given by slot time
</p>

<p>
slot time = round-trip time + time required to send jam sequence
</p>

<p>
The slot time can be calculated as
</p>

<p>
\[\text{slot time} = \frac{\text{packet size}}{\text{speed of NIC}} \]
</p>

<p>
For standard ethernet, the packet size is 512 bits and speed is 10-Mbps. So slot time is
\[ \text{slot time} = \frac{512 bits}{10^7 bps} secs\]
\[ \text{slot time} = 51.2 \mu s \]
The maximum length between two stations is calculated as
\[ \text{max length} = \text{propogation speed} \times \frac{\text{slot time}}{2}\]
The propogation speed is \(2 \times 10^{8} m/s\) in most mediums, therefore the max length is
\[ \text{max length} = 2 \times 10^{8} \times \frac{51.2 \times 10^{-6}}{2} m =  5120 m\]
But <i>due to delay times in repeaters and interfaces</i>, the laximum length is reduced to only
\[ \text{max length} = 2500 m \]
</p>
</div>
</div>
</div>

<div id="outline-container-org725e4dd" class="outline-4">
<h4 id="org725e4dd"><span class="section-number-4">6.2.2.</span> Standard Ethernet : Physical Layer</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
For standard ethernet, physical layer implementation is different; the four most common are discussed here
</p>
<ul class="org-ul">
<li>10Base5 : Bus topology, Thick coaxial cable</li>
<li>10Base2 : Bus topology, Thin coaxial cable</li>
<li>10Base-T : Star topology, Unshielded Twisted Pair (UTP) wire</li>
<li>10Base-F : Star topology, Fiber</li>
</ul>
<p>
All standard ethernet use basebad at 10-Mbps. <b>The line coding used is Manchester scheme.</b>
</p>
</div>
<div id="outline-container-org71e44fb" class="outline-5">
<h5 id="org71e44fb"><span class="section-number-5">6.2.2.1.</span> 10Base5 : Thick Ethernet</h5>
<div class="outline-text-5" id="text-6-2-2-1">
<p>
Called thick ethernet or thicknet. It uses a bus topology
</p>
<ul class="org-ul">
<li>Name comes from size of cable, which is size of garden hose and too stiff to bend</li>
<li>Uses an external transeiver (transmitter/receiver) via a tap cable to the thick cable</li>
<li>10 stands for speed 10Mbps. The 5 stands for maximum length of the coaxial cable which is 500m</li>
<li>Collisions occur only within the thick coaxial cable</li>
</ul>
</div>
</div>
<div id="outline-container-org85a43b1" class="outline-5">
<h5 id="org85a43b1"><span class="section-number-5">6.2.2.2.</span> 10Base2 : Thin Ethernet</h5>
<div class="outline-text-5" id="text-6-2-2-2">
<p>
Also called cheapernet, since it is more affordable. It also uses a bus topology
</p>
<ul class="org-ul">
<li>The cable is flexible and much thinner</li>
<li>Transceiver is part of the NIC</li>
<li>10 stands for speed 10Mbps. The 2 stands for maximum length of coaxial cable which is 185m (very close to 200m)</li>
<li>Collisions occur only within the backbone of bus topology</li>
</ul>
</div>
</div>
<div id="outline-container-org20f727b" class="outline-5">
<h5 id="org20f727b"><span class="section-number-5">6.2.2.3.</span> 10Base-T : Twisted-Pair Ethernet</h5>
<div class="outline-text-5" id="text-6-2-2-3">
<p>
It uses a physical star topology
</p>
<ul class="org-ul">
<li>All stations are connected to a HUB</li>
<li>Two twisted-pair cables are needed per station (one for sending and one for receiving)</li>
<li>The maximum length of a twisted-pair wire is 100m</li>
<li>Collisions happen in the HUB</li>
</ul>
</div>
</div>
<div id="outline-container-org9ce8fb9" class="outline-5">
<h5 id="org9ce8fb9"><span class="section-number-5">6.2.2.4.</span> 10Base-F : Fiber Ethernet</h5>
<div class="outline-text-5" id="text-6-2-2-4">
<p>
It also uses a star topology
</p>
<ul class="org-ul">
<li>All stations are connected to HUB</li>
<li>Two optical fiber cables are needed per station (one for sending and one for receiving)</li>
<li>The maximum length can go upto 2000m</li>
</ul>
<p>
In summary, the different physical layer implementations are
</p>


<div id="org5069da7" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-01_00-56-41_screenshot.png" alt="2023-11-01_00-56-41_screenshot.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb9b9f97" class="outline-4">
<h4 id="orgb9b9f97"><span class="section-number-4">6.2.3.</span> Switched Ethernet / Bridged Ethernet</h4>
<div class="outline-text-4" id="text-6-2-3">
<ul class="org-ul">
<li>The bridged ethernet uses the same MAC sublayer protocols, so <i>frame format and access method is the same.</i></li>
</ul>
</div>
<div id="outline-container-org2697327" class="outline-5">
<h5 id="org2697327"><span class="section-number-5">6.2.3.1.</span> Bridges</h5>
<div class="outline-text-5" id="text-6-2-3-1">
<p>
A bridge is a layer 2 switch (i.e, it works on 2 layers; physical and data link layer). A hub is a simple physical connection of the wires, whereas <i>within a switch, packet switching is done.</i>
</p>
<ul class="org-ul">
<li>The packet received by hub is forwarded to every station connected to the hub</li>
<li>The packet received by switch is forwarded only to the station to which frame is addressed
<ul class="org-ul">
<li>The switch reads the MAC address of the frame to determine which port to send the frame to</li>
</ul></li>
</ul>


<div id="orga07a97b" class="figure">
<p><img src="./Medium_Access_Control_Sublayer/Untitled-2023-11-17-1853.png" alt="Untitled-2023-11-17-1853.png" />
</p>
</div>

<ul class="org-ul">
<li>Since the bridge only forwards packets to the needed port, it <i>reduces the collision domain</i> to only between the bridge and the station</li>
<li>Every port in a layer 2 switch is equivalent to a seperate LAN. So <i>layer 2 switch (bridge) is used to connect different LANs</i></li>
</ul>
</div>
</div>
<div id="outline-container-org3216677" class="outline-5">
<h5 id="org3216677"><span class="section-number-5">6.2.3.2.</span> Using N-port bridge</h5>
<div class="outline-text-5" id="text-6-2-3-2">
<p>
A layer 2 switch with N ports is called an N-port bridge.
</p>
<ul class="org-ul">
<li>Using only bridges in our LAN allows us to achieve faster speeds since bandwidth is not divided</li>
</ul>
<p>
Example, if there are 6 stations and bandwidth is 12mbps, then if we use HUB to connect the six stations each one will get bandwidth \(12/6 = 2mbps\). But if we use a switch to connect the stations, each will get the complete bandwidth of \(12mbps\) since each station has a seperate collission domain
</p>


<div id="org648ea5b" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-17_20-10-24_Screenshot 2023-11-17 200910.png" alt="2023-11-17_20-10-24_Screenshot 2023-11-17 200910.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org8d9aa8e" class="outline-5">
<h5 id="org8d9aa8e"><span class="section-number-5">6.2.3.3.</span> Full-duplex switched ethernet</h5>
<div class="outline-text-5" id="text-6-2-3-3">
<p>
This is the fastest ethernet solution. It uses N-port bridges to connect the stations. Also the connections between the stations and the layer 2 switch is full-duplex
</p>
<ul class="org-ul">
<li><p>
Since every path a packet can travel has a seperate domain, there is <i>no need for CSMA/CD</i> i.e, there is <i>no need for Access Control Protocols</i>
</p></li>
</ul>

<div id="orgdbaf20b" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-17_20-14-16_Screenshot 2023-11-17 201408.png" alt="2023-11-17_20-14-16_Screenshot 2023-11-17 201408.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0f87460" class="outline-4">
<h4 id="org0f87460"><span class="section-number-4">6.2.4.</span> Fast Ethernet</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
IEEE created Fast Ethernet under 802.3u.
</p>
<ul class="org-ul">
<li>It is backward compatible with standard ethernet
<ul class="org-ul">
<li>It uses the <b>same MAC sublayer protocols</b>, this was one of the main goals when making fast ethernet</li>
<li>So minimum and maximum frame size, frame formats and MAC addresses are all same</li>
<li>The only difference is in the physical layer</li>
</ul></li>
<li>It's speed is 100Mbps</li>
<li>The physical topology differes from standard ethernet
<ul class="org-ul">
<li><b>Bus topology is not supported, only star topology is supported</b></li>
<li>If there are only two stations, they can be connected point-to-point</li>
</ul></li>
</ul>

<p>
<b>Autonegotiation</b>
</p>

<p>
Since fast ethernet needed to be backwards compatible, it introduced feature called autonegotiation
</p>
<ul class="org-ul">
<li>This feature allows two devices to negotiate the <b>mode of data transfer (half-duplex or full-duplex)</b>; and <b>the data rate (10Mbps or 100Mbps)</b></li>
<li>This allows incompatible devices, (one using standard ethernet and another using fast ethernet) to form connection</li>
</ul>
</div>
<div id="outline-container-org99415e1" class="outline-5">
<h5 id="org99415e1"><span class="section-number-5">6.2.4.1.</span> Implementations of Fast Ethernet</h5>
<div class="outline-text-5" id="text-6-2-4-1">

<div id="orga1ebdc8" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_00-24-04_Screenshot 2023-11-18 002340.png" alt="2023-11-18_00-24-04_Screenshot 2023-11-18 002340.png" />
</p>
</div>



<div id="org11d6903" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_00-26-25_Screenshot 2023-11-18 002611.png" alt="2023-11-18_00-26-25_Screenshot 2023-11-18 002611.png" />
</p>
</div>


<div id="org8c02014" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_00-25-00_Screenshot 2023-11-18 002450.png" alt="2023-11-18_00-25-00_Screenshot 2023-11-18 002450.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf943f16" class="outline-4">
<h4 id="orgf943f16"><span class="section-number-4">6.2.5.</span> Gigabit Ethernet</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
IEEE commitee calls it 802.3ab. The <i>physical layer is same as the Fast ethernet</i>
</p>
</div>
<div id="outline-container-org7435eb2" class="outline-5">
<h5 id="org7435eb2"><span class="section-number-5">6.2.5.1.</span> MAC sublayer</h5>
<div class="outline-text-5" id="text-6-2-5-1">
<p>
Similar to fast ethernet, at first IEEE tried to keep MAC sublayer untouched. But to reach speed of 1Gbps, this was not possible. So for Gigabit ethernet, changes were done to MAC sublayer. Most Gigabit Ethernet work in Full-duplex but some implementations have been defined for half-duplex. <i>Autonegotiation is supported in gigabit-ethernet</i> 
</p>

<p>
<b>Full-Duplex Mode</b>
</p>

<p>
In this mode, CSMA/CD is not used because of lack of possible collisions. The length of wire is determined by signal attenuation in cable. Therefore, <i>no change from standard ethernet MAC sublayer is done for full-duplex mode</i>. 
</p>

<p>
<b>Half-Duplex Mode</b>
</p>

<p>
Gigabit ethernet can be used in half-duplex but is extremely rare to do so. The MAC sublayer needs to be changed in order to accomadate half-duplex mode. In half-duplex mode HUBs are used, therefore CSMA/CD needs to be used. There are <i>three additions for half-duplex in gigabit ethernet</i>
</p>
<ol class="org-ol">
<li><b>Traditional</b> =&gt; The minimum frame length is same as standard ethernet (512bits). But since speed is 100 times faster, the length is also 100 times less. So length of wire is 25m</li>
<li><b>Carrier Extension</b> =&gt; The minimum length of frame is increased to (4096bits). Since frame size is increase 8 times, the length of wire also increases by 8 times. This increases the length of wire to 200m. But <i>if frame is smaller, the station needs to pad it.</i></li>
<li><b>Frame bursting</b> =&gt; This is used when we are using carrier extension. Carrier extension is very expensive (bandwidth-wise) for smaller frames. So rather than padding a single small frame, multiple data frames are concatnated before being sent to the line.</li>
</ol>
</div>
</div>
<div id="outline-container-orgffc402e" class="outline-5">
<h5 id="orgffc402e"><span class="section-number-5">6.2.5.2.</span> Implementations of Gigabit Ethernet</h5>
<div class="outline-text-5" id="text-6-2-5-2">

<div id="orgde22361" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_00-59-03_Screenshot 2023-11-18 005856.png" alt="2023-11-18_00-59-03_Screenshot 2023-11-18 005856.png" />
</p>
</div>


<div id="orgd5d5616" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_00-59-23_Screenshot 2023-11-18 005917.png" alt="2023-11-18_00-59-23_Screenshot 2023-11-18 005917.png" />
</p>
</div>


<div id="org0763122" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_00-59-39_Screenshot 2023-11-18 005933.png" alt="2023-11-18_00-59-39_Screenshot 2023-11-18 005933.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3ee3c67" class="outline-4">
<h4 id="org3ee3c67"><span class="section-number-4">6.2.6.</span> Ten-Gigabit Ethernet</h4>
<div class="outline-text-4" id="text-6-2-6">
<ul class="org-ul">
<li>Uses same frame format and frame sizes</li>
<li><i>Only full-duplex mode is supported</i>. Therefore, CSMA/CD is no longer part of design</li>
<li>Uses scrambling and 64B/66B encoding</li>
</ul>


<div id="orgaa6a52a" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_01-14-44_Screenshot 2023-11-18 011436.png" alt="2023-11-18_01-14-44_Screenshot 2023-11-18 011436.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org41b5e39" class="outline-3">
<h3 id="org41b5e39"><span class="section-number-3">6.3.</span> Connecting devices</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Connecting devices can be divided into five different categories based on which layer they operate
</p>


<div id="org5e2e9d1" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_13-30-09_Screenshot 2023-11-18 132943.png" alt="2023-11-18_13-30-09_Screenshot 2023-11-18 132943.png" />
</p>
</div>

<ol class="org-ol">
<li>Passive hubs work below the physical layer</li>
<li>Repeater and Active hubs work on the physical layer</li>
<li>Bridges and two-layer switches work on data link layer and physical layer</li>
<li>Routers and three-layer switches work on network layer, data link layer and physical layer</li>
<li>Gateways work on all layers</li>
</ol>
</div>
<div id="outline-container-org6d1c7ff" class="outline-4">
<h4 id="org6d1c7ff"><span class="section-number-4">6.3.1.</span> Passive Hubs</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
A passive hub is just a connector. It connects the wires coming from different branches. It doesn't make any changes to the signal it gets
</p>


<div id="org0da8410" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-18_13-38-46_Screenshot 2023-11-18 133838.png" alt="2023-11-18_13-38-46_Screenshot 2023-11-18 133838.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org6e18b61" class="outline-4">
<h4 id="org6e18b61"><span class="section-number-4">6.3.2.</span> Repeaters and Active Hubs</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
These devices work on the physical layers.
</p>
<ul class="org-ul">
<li>Signals in a medium can only travel a finite distance, based on signal strength</li>
<li>Repeaters and Active Hubs take the <i>signal and regenerate them</i>. This can be used to increase the possible length of wire in LANs i.e, if maxium range for wire is 25m and station is 50m away, we can place a repeater in middle and use two wires to connect the station</li>
</ul>
</div>
</div>
<div id="outline-container-orgbd18162" class="outline-4">
<h4 id="orgbd18162"><span class="section-number-4">6.3.3.</span> Bridges</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
This device works on both physical and data link layer.
</p>
<ul class="org-ul">
<li>Bridge read the physical (MAC) address contained in the frame and send frame to only the destination station</li>
<li>Therefore each port connection to a port is a seperate collission domain</li>
<li>This ability of a bridge to send frame to only a single port avoiding collission is called <i>filtering</i></li>
</ul>
</div>
</div>
<div id="outline-container-org65f4a0e" class="outline-4">
<h4 id="org65f4a0e"><span class="section-number-4">6.3.4.</span> Transparent Bridges</h4>
<div class="outline-text-4" id="text-6-3-4">
<p>
A transparent bridge is a bridge which does not require any additional configuration i.e, we don't need to fill the forwarding table which stores which port have which MAC addresses manually.
</p>
<ul class="org-ul">
<li>The stations are completely unaware of the transparent bridge, i.e, it can be removed or added to network without extra configuration</li>
</ul>
<p>
A transparent bridge <i>must meet three criteria</i>
</p>
<ol class="org-ol">
<li>Frames must be forwarded from station to another correctly</li>
<li>Forwarding table is automatically made by learning frame movements in network</li>
<li>Loops in network must be prevented</li>
</ol>
</div>
<div id="outline-container-orgdcd8436" class="outline-5">
<h5 id="orgdcd8436"><span class="section-number-5">6.3.4.1.</span> Learning</h5>
<div class="outline-text-5" id="text-6-3-4-1">
<p>
Earlier bridges had static forwarding table, and were entered manually. The transparent bridges on other hand have learning capacbility by monitoring flow of frames
</p>
<ol class="org-ol">
<li>Suppose a frame is received by switch which is going from station A to station B</li>
<li>If bridge doesn't have entry for station A, it can read it the frame header to get it's MAC address. This is then stored for later use in the table</li>
<li>If bridge doesn't have entry for station B, it sends the frame to every station (this is called flooding the network)</li>
</ol>
</div>
</div>
<div id="outline-container-org407fb1f" class="outline-5">
<h5 id="org407fb1f"><span class="section-number-5">6.3.4.2.</span> Avoiding Loops</h5>
<div class="outline-text-5" id="text-6-3-4-2">
<p>
Transparent bridges work fine if there are no loops. But sytem admins like to have redundant bridges to make network more reliable. But these redundant bridges create loops
</p>
<ul class="org-ul">
<li>Loops interfere with learning process of transparent bridges</li>
<li>To solve looping problem, <b>bridges use spanning tree algorithms to create loopless topology</b>. Since bridges can't change physical topology themselves, they create a logical topology in form of a spanning tree</li>
<li>Minimum spanning tree algorithms are used to make performance better in network, by selecting the fastest bridges</li>
<li>Bridges use special packets called bridge protocol data units (BPDUs), to create and update spanning tree</li>
</ul>
<p>
But spanning trees aren't the only solution. <i>Some transparent bridges use source routing instead of spanning tree</i>
</p>
<ul class="org-ul">
<li>The routing is done by source station, (and to small extent, by destination station).</li>
<li>The stations define bridges that frame must visit</li>
<li>The source station thus first needs to get locations of bridges using special frames</li>
</ul>
<p>
<b>Source routing is used with Token Ring LANs</b>
</p>
</div>
</div>
</div>
<div id="outline-container-org6cc420b" class="outline-4">
<h4 id="org6cc420b"><span class="section-number-4">6.3.5.</span> Switches</h4>
<div class="outline-text-4" id="text-6-3-5">
<p>
Switches are multiport transparent bridges. Since they have multiple ports, each port is bufferred so that a single line is not flooded with frames
</p>
<ul class="org-ul">
<li>Switches don't divide bandwidth of network among ports (unlike normal HUBs)</li>
<li>Frames are buffered in queue, if multiple frames are to be on same line</li>
<li>Some switches also implement security features</li>
</ul>
<p>
Switches are of two types
</p>
<ol class="org-ol">
<li>Store-and-Forward Switching : this method of switching data packets receives a packet, checks for errors and then forwards packet only when the whole packet has arrived at the switch</li>
<li>Cut-through switching : this method does not process packet at all, as soon as it can read the destination address field, it will send the packet on the correct port without waiting for whole packet to arrive</li>
</ol>
</div>
</div>
<div id="outline-container-orgb36caf8" class="outline-4">
<h4 id="orgb36caf8"><span class="section-number-4">6.3.6.</span> Routers (Three-layer switches)</h4>
<div class="outline-text-4" id="text-6-3-6">
<p>
These are three-layer device which route packets based on their logical address. Routers are usually used to connect LANs to the WANs like the internet
</p>
<ul class="org-ul">
<li>The routing tables are updated dynamically</li>
<li>Network layer contains the protocols to update these routing tables</li>
</ul>


<div id="org5bb3720" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-25_00-00-02_Screenshot 2023-11-24 235944.png" alt="2023-11-25_00-00-02_Screenshot 2023-11-24 235944.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd747d18" class="outline-4">
<h4 id="orgd747d18"><span class="section-number-4">6.3.7.</span> Gateway</h4>
<div class="outline-text-4" id="text-6-3-7">
<p>
These devices work on all five layer of Internet or all seven layers of OSI model (i.e, they work on all layers of network models)
</p>
<ul class="org-ul">
<li>They can read and interpret the application messages</li>
<li>They can be used to connect different network models (like OSI with TCP/IP model network)</li>
<li>Since they can interpret application messages, they are used for security and filtering unwanted messages</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org07d4def" class="outline-3">
<h3 id="org07d4def"><span class="section-number-3">6.4.</span> Backbone networks and Virtual LANs</h3>
<div class="outline-text-3" id="text-6-4">
</div>
<div id="outline-container-orgf12159e" class="outline-4">
<h4 id="orgf12159e"><span class="section-number-4">6.4.1.</span> Backbone networks</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
Networks where several networks are connected using a sigle backbone network
</p>
</div>
<div id="outline-container-orgf8882e7" class="outline-5">
<h5 id="orgf8882e7"><span class="section-number-5">6.4.1.1.</span> Bus backbone</h5>
<div class="outline-text-5" id="text-6-4-1-1">
<p>
Used to connect different buildings of organization
</p>


<div id="org3dc0925" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-25_00-10-35_Screenshot 2023-11-25 001031.png" alt="2023-11-25_00-10-35_Screenshot 2023-11-25 001031.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org035c125" class="outline-5">
<h5 id="org035c125"><span class="section-number-5">6.4.1.2.</span> Star backbone</h5>
<div class="outline-text-5" id="text-6-4-1-2">
<p>
Also called <i>collapsed or switched backbone</i>. The backbone of the network is just a single switch
</p>


<div id="orgc4799d8" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-25_00-11-49_Screenshot 2023-11-25 001145.png" alt="2023-11-25_00-11-49_Screenshot 2023-11-25 001145.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org89a890e" class="outline-5">
<h5 id="org89a890e"><span class="section-number-5">6.4.1.3.</span> Connecting remote LANs</h5>
<div class="outline-text-5" id="text-6-4-1-3">
<p>
In this type of backbone network, the point-to-point bridges are used to connect the different LANs. Each LAN will have it's own bridge which is connected point-to-point to backbone
</p>


<div id="org88e0754" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-25_00-13-31_Screenshot 2023-11-25 001327.png" alt="2023-11-25_00-13-31_Screenshot 2023-11-25 001327.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org02ad145" class="outline-4">
<h4 id="org02ad145"><span class="section-number-4">6.4.2.</span> Virtual LANs</h4>
<div class="outline-text-4" id="text-6-4-2">

<div id="org810c4d4" class="figure">
<p><img src="Medium_Access_Control_Sublayer/2023-11-25_00-17-57_Screenshot 2023-11-25 001637.png" alt="2023-11-25_00-17-57_Screenshot 2023-11-25 001637.png" />
</p>
</div>

<p>
<b>VLANs are software that run of the switch</b>
</p>
<ul class="org-ul">
<li>VLANs divide network into logical LANs, instead of physical seperate networks.</li>
<li>Each VLAN can thus act as a workgroup for an organization</li>
<li>This means that stations can be moved to different workgroups without having to rewire the physical networks</li>
<li>This is useful when messages need to be broadcasted to a paritcular workgroup</li>
<li>Moving people form one workgroup to another is also easier</li>
</ul>
</div>

<div id="outline-container-org63d2669" class="outline-5">
<h5 id="org63d2669"><span class="section-number-5">6.4.2.1.</span> Membership in VLANs</h5>
<div class="outline-text-5" id="text-6-4-2-1">
<p>
A VLAN software may use one or more following characteristics to divide VLANs
</p>
<ol class="org-ol">
<li>Port Numbers : The ports of the switch can be used to define which stations connected to which port of switch are in which VLAN</li>
<li>MAC Addresses</li>
<li>IP Addresses</li>
<li>Multicast IP Addresses (more about these later in network layer)</li>
</ol>
</div>
</div>

<div id="outline-container-orgcb50e0d" class="outline-5">
<h5 id="orgcb50e0d"><span class="section-number-5">6.4.2.2.</span> Configuration</h5>
<div class="outline-text-5" id="text-6-4-2-2">
<p>
The configuration can be of three types
</p>
<ol class="org-ol">
<li>Manual configuration : administrator needs to enter characteristics for the VLAN software</li>
<li>Automatic configuration : admin can define certain criteria (like station names, project IDs or user IDs) to automatically connect or disconnect stations from VLAN</li>
<li>Semiautomatic configuration : initialization done manually and migrations done automatically</li>
</ol>
</div>
</div>

<div id="outline-container-org6121b22" class="outline-5">
<h5 id="org6121b22"><span class="section-number-5">6.4.2.3.</span> Communication between switches</h5>
<div class="outline-text-5" id="text-6-4-2-3">
<p>
When using backbone network, the VLAN software running on backbone switch needs to known membership of stations in other switches. Following methods are used to get this info
</p>
<ul class="org-ul">
<li>Table Maintenance : In this method, when a station sends broadcast frame to its group members, the switches will record station membership in bottom-up fashion. These recorded tables are passed around</li>
<li>Frame tagging : an external header is attached to frame that defines the destination VLAN, this is the frame tag. It is used by receiving switches to determine VLANs to be receiving broadcast messages</li>
</ul>
<p>
IEEE standard uses the frame tagging for VLANs in backbone networks
<hr />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbc63c24" class="outline-2">
<h2 id="orgbc63c24"><span class="section-number-2">7.</span> Network Layer</h2>
<div class="outline-text-2" id="text-7">
<p>
It is a host-to-host layer. This layer has the IP protocol which is used to route packets on the internet. There are two versions of internet protocol IPv4 and IPv6
</p>
</div>
<div id="outline-container-org6cead4f" class="outline-3">
<h3 id="org6cead4f"><span class="section-number-3">7.1.</span> IPv4 Address</h3>
<div class="outline-text-3" id="text-7-1">
<p>
IPv4 address is a 32-bit address that will uniquely and universally define connection of a device (computer or now more commanly a router) to the internet.
</p>
<ul class="org-ul">
<li>IPv4 addresses are unique, each address defines a single connection to the internet</li>
<li>If a device wants \(n\) connections to the internet, it needs to have \(n\) addresses (router is one such device)</li>
<li>Universal means all devices on internet use the same IP addressing system</li>
</ul>
</div>
<div id="outline-container-org72a2df0" class="outline-4">
<h4 id="org72a2df0"><span class="section-number-4">7.1.1.</span> Address Space</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
For any protocol, the total number of possible addresses is called it's address space.
</p>

<p>
For IPv4, since it is 32-bit, the address space is \(2^{32}\) addresses.
</p>
<ul class="org-ul">
<li>Theoretically, IPv4 must support \(2^{32}\) connections</li>
<li>But actual number of addresses is less since there are restrictions on the adresses</li>
</ul>
</div>
</div>
<div id="outline-container-orgc192c73" class="outline-4">
<h4 id="orgc192c73"><span class="section-number-4">7.1.2.</span> Notation</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
There are two prevelant notations for IPv4 addresses
</p>
<ol class="org-ol">
<li>Binary notation : all 32-bits of the address are shown in this notation Eg, \(01110101 10010101 00011101 00000010\)</li>
<li>Dotted-decimal notation : the four bytes are written in decimal form, seperated by a dot (.) The address from previous example in this notation is \(117.149.29.2\)</li>
</ol>


<div id="orgc78fd15" class="figure">
<p><img src="Network_Layer/2023-11-25_13-45-30_Screenshot 2023-11-25 134522.png" alt="2023-11-25_13-45-30_Screenshot 2023-11-25 134522.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgdd3bb61" class="outline-4">
<h4 id="orgdd3bb61"><span class="section-number-4">7.1.3.</span> Classful addressing</h4>
<div class="outline-text-4" id="text-7-1-3">
<p>
IPv4 addresses used to have concept of class. This type of addressing is now obsolete
</p>

<p>
The address space is divided into five classes: A, B, C, D and E
</p>
<ul class="org-ul">
<li>The classes are divided based on the first byte</li>
</ul>

<div id="orgdf34155" class="figure">
<p><img src="Network_Layer/2023-11-25_13-53-41_Screenshot 2023-11-25 135335.png" alt="2023-11-25_13-53-41_Screenshot 2023-11-25 135335.png" />
</p>
</div>

<p>
In binary notion, we can tell class of address by looking at first few bits
</p>


<div id="org78e1983" class="figure">
<p><img src="Network_Layer/2023-11-25_13-57-01_Screenshot 2023-11-25 135655.png" alt="2023-11-25_13-57-01_Screenshot 2023-11-25 135655.png" />
</p>
</div>

<p>
Each class has fixed number of blocks and fixed fixed size
</p>
<ul class="org-ul">
<li>The class A addresses were designed for large organization with large number of hosts (or routers). Therefore it has a large host ID block (last 24 bits of IP address)</li>
<li>The class B addresses were desiged for mid sized organization. Therefore it has a mid sized host ID block (last 16 bits of IP address)</li>
<li>The class C addresse were designed for small sized organizations. Therefore, it has small host ID block (last 8 bits of IP address)</li>
<li>The class D IP addresse are for multi-casting</li>
<li>The class E IP addresses are reserved addresses. They were reserved for experimentation and research purposes</li>
</ul>

<div id="org2e7d06d" class="figure">
<p><img src="Network_Layer/2023-11-25_17-35-00_Untitled-2023-11-25-1427.png" alt="2023-11-25_17-35-00_Untitled-2023-11-25-1427.png" />
</p>
</div>
</div>

<div id="outline-container-org6a72f50" class="outline-5">
<h5 id="org6a72f50"><span class="section-number-5">7.1.3.1.</span> Network ID and Host ID</h5>
<div class="outline-text-5" id="text-7-1-3-1">
<p>
The network IDs were assigned to the organizations to use. The host IDs are added by the organization to uniquely identify the stations on their network
</p>
<ul class="org-ul">
<li>Network IDs will identify the network to which the IP address belongs.</li>
<li>Host ID will identify the host (devices) within the network</li>
</ul>

<div id="org6824421" class="figure">
<p><img src="Network_Layer/2023-11-25_18-57-36_Screenshot 2023-11-25 185732.png" alt="2023-11-25_18-57-36_Screenshot 2023-11-25 185732.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgcef158e" class="outline-5">
<h5 id="orgcef158e"><span class="section-number-5">7.1.3.2.</span> Mask</h5>
<div class="outline-text-5" id="text-7-1-3-2">
<p>
A mask is a 32-bit number with \(n\) leftmost bits being 1's and remaining \((32 - n)\) bits being 0's. The mask is used to seperate the host id and net id from a given IP address.
</p>

<div id="org23612b1" class="figure">
<p><img src="Network_Layer/2023-11-25_20-18-18_Screenshot 2023-11-25 201812.png" alt="2023-11-25_20-18-18_Screenshot 2023-11-25 201812.png" />
</p>
</div>

<p>
We use logical AND to get the network id and host id, from the IP address. The last column of table is called slash notation or Classless Interdomain Routing (CIDR) notation. This notation is used in classless addressing.
</p>
</div>
</div>
<div id="outline-container-orgb05e2ef" class="outline-5">
<h5 id="orgb05e2ef"><span class="section-number-5">7.1.3.3.</span> Supernetting</h5>
<div class="outline-text-5" id="text-7-1-3-3">
<p>
The number of hosts in class C blocks is \(2^8\) i.e, 256 hosts on the same network. This is too small for most organizations. The solution to this is supernetting
</p>
<ul class="org-ul">
<li>Several networks are combined to create a super network or supernet</li>
<li>An organization applies for set of class C blocks instead of one.</li>
<li>Example, if organization needs 1000 addresses, it will use 4 contiguous blocks of class C addresses</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org47a1c58" class="outline-4">
<h4 id="org47a1c58"><span class="section-number-4">7.1.4.</span> Classless addressing</h4>
<div class="outline-text-4" id="text-7-1-4">
<p>
In classless addressing, organizations are still granted block (range) of IP addresses. But unlike classful addressing, their size is not fixed.
</p>

<p>
There are three restrictions on classless adress blocks
</p>
<ol class="org-ol">
<li>The address blocks must be contiguous</li>
<li>Number of addresses in block must be power of 2</li>
<li>The first address must be divisible by the number of addresses in block (we are referring to first address in binary notation, i.e as a single number)</li>
</ol>

<div id="orgba2adf7" class="figure">
<p><img src="Network_Layer/2023-11-26_00-07-09_Screenshot 2023-11-26 000703.png" alt="2023-11-26_00-07-09_Screenshot 2023-11-26 000703.png" />
</p>
</div>

<p>
We can see that this block follows all three restrictions. The first IP address is converted as
\[ (11001101 00010000 00100101 00100000)_2 = (3,440,387,360)_{10} \]
Which is divisible by 16
</p>

<p>
We don't need to convert the first address of block to decimal to check if it is divisible my some \(2^m\). <b>If a binary number is divisible by a number \(2^m\) then it's last \(log_2 (m)\) bits have to be 0's</b>
</p>
</div>
<div id="outline-container-org3d8b8d6" class="outline-5">
<h5 id="org3d8b8d6"><span class="section-number-5">7.1.4.1.</span> Mask (CIDR notaion)</h5>
<div class="outline-text-5" id="text-7-1-4-1">
<p>
Mask is used to define block of addresses. In classless addressing, it is more important since the block sizes aren't fixed. In a mask, the first \(n\) bits are 1's and remaining \((32 - n)\) bits are 0's.
</p>
<ul class="org-ul">
<li>In CIDR notation, we define a mask by a single value \(n\). Where \(n\) is the number of leftmost bits that are 1's</li>
<li>This is written alongside the IP address seperated by a slash.</li>
</ul>
<p>
Example, \(205.16.37.32/28\) is the block is CIDR notation for the block of our previous example which has starting address \(205.16.37.32\) and 16 addresses
</p>

<p>
Therefore the \(n\) is calculated as
\[ n = 32 - log_2 (\text{number of addresses}) \]
Since that is the number required bits for all host IDs
</p>
</div>
</div>

<div id="outline-container-org72d0225" class="outline-5">
<h5 id="org72d0225"><span class="section-number-5">7.1.4.2.</span> First and last address of block</h5>
<div class="outline-text-5" id="text-7-1-4-2">
<p>
If we are given any address from a block in CIDR notation, we can get the first and last address of that block. Suppose the IP address is \(a.b.c.d/n\)
</p>
<ul class="org-ul">
<li>The first address in the block can be found by setting the rightmost \(32 - n\) bits to 0s</li>
<li>The last address in the block can be found by setting the rightmost \(32 - n\) bits to 1s</li>
</ul>

<p>
The first and last address in block are special addresses. They are not given to any of the devices on the network.
</p>
<ul class="org-ul">
<li><b>Network address</b> : The first address in block is called the network address. The router will use this address for unicast and multicast routing protcols. This will not be assigned to any device in the network</li>
<li><b>Broadcast address</b> : The last address in block is called the broadcast address. Packets that are destined to this address are sent to all devices on the network. This is also not assigned to any device in the network.</li>
</ul>

<p>
<b>Number of addresses in block</b>
</p>

<p>
The number of addresses in block for the address in CIDR notation is
\[ \text{number of addresses} = 2^{32 - n} \]
</p>
</div>
</div>

<div id="outline-container-org2aecacd" class="outline-5">
<h5 id="org2aecacd"><span class="section-number-5">7.1.4.3.</span> Hierarchy in IP addresses</h5>
<div class="outline-text-5" id="text-7-1-4-3">
<p>
IP address have levels of hierarchy, based on whether we have subnetting or not
</p>

<p>
<b>Two-level Hierarchy: No Subnetting</b>
</p>

<p>
When not subnetted, IP address have two levels of hierarchy. A Network ID (or network prefix) to identify the network. And the Host ID (or host address) to identify a host on the network.
</p>
<ul class="org-ul">
<li>The prefix remains same for all devices on the network</li>
<li>Only the host ID at the end changes for different devices on the network</li>
<li>If mask is \(n\) in CIDR notation :
<ul class="org-ul">
<li>The leftmost \(n\) bits are network ID</li>
<li>The rightmost \(32 - n\) bits are host ID</li>
</ul></li>
</ul>


<div id="orgca621a7" class="figure">
<p><img src="Network_Layer/2023-12-01_12-30-42_Untitled-2023-12-01-1215.png" alt="2023-12-01_12-30-42_Untitled-2023-12-01-1215.png" />
</p>
</div>

<p>
<b>Three-level Hierarchy: Subnetting</b>
</p>

<p>
If an organization has a large block of address, it can break it into smaller clusters of addresses (subnets).
</p>
<ul class="org-ul">
<li>Outside of the network, it is still treated as one big network</li>
<li>But internally, it is organized into several subnets. These subnets can be given to different departments of the organization</li>
<li>Internally, each subnet has it's own new mask. This subnet mask is only relevant inside the organization itself</li>
</ul>
<p>
<i>Example</i>, suppose an organization has a block 17.12.40.0/26, which has 64 addresses. It wants to break it into three subnets of sizes 32, 16 and 16 addresses.
</p>
<ul class="org-ul">
<li>subnet mask for 32 addresses is \(n_1 = 32 - log_2 (32) = 27\)</li>
<li>subnet mask for 16 addresses is \(n_2 = 32 - log_2 (16) = 28\)</li>
<li>subnet mask for 16 addresses is \(n_3 = 32 - log_2 (16) = 28\)</li>
</ul>
<p>
In general for the subnet with \(x\) addresses, the subnet is given by
\[ \text{subnet mask for $x$ addresses $(n_i)$} = 32 - log_2 (x) \]
The network prefix is the same for all the subnets, instead <i>we divide the host ID further into host ID and the subnet ID (or subnet prefix)</i>
</p>


<div id="org14b5be9" class="figure">
<p><img src="Network_Layer/2023-12-01_13-39-42_Untitled-2023-12-01-1215.png" alt="2023-12-01_13-39-42_Untitled-2023-12-01-1215.png" />
</p>
</div>

<ul class="org-ul">
<li>This ability to make subnets makes classless addressing more flexible</li>
<li>This is very useful since in real application, the ISPs divide their block of network into smaller subnets for local ISPs. Then local ISPs further divide it into even smaller blocks and give them to different organizations</li>
<li>The <i>Internet Corporation for Assigned Names and Addresses</i> (ICANN) is responsible for address allocation.
<ul class="org-ul">
<li>ICANN usually does not allocate to individual organizations</li>
<li>Instead ICANN assigns large blocks of IP address to ISPs who will distribute it to users</li>
<li>This is called <i>address aggregation by the ISPs</i></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org07a054c" class="outline-4">
<h4 id="org07a054c"><span class="section-number-4">7.1.5.</span> Network Address Translation (NAT)</h4>
<div class="outline-text-4" id="text-7-1-5">
<p>
With the increase in number of home users and small businesses. And the number of devices used by individuals, it was hard to assign an IP address to all of them. Previously, we used dial-up which gave the user an IP address for temporary amount of time. But now, we use Network Address Translation (NAT)
</p>
<ul class="org-ul">
<li>Internally, users have a large set of addresses that they can use for all their devices. The traffic inside the local network uses this set of addresses</li>
<li>Externally, there is a small set of addresses (usually a single address). This is the set of addresses that will connect to outside traffic (i.e, the internet)</li>
</ul>
<p>
The Internet authorities have reserved three sets of addresses as private addresses for this purpose.
</p>


<div id="orgb1dc7bb" class="figure">
<p><img src="Network_Layer/2023-12-01_13-57-24_Screenshot 2023-12-01 135718.png" alt="2023-12-01_13-57-24_Screenshot 2023-12-01 135718.png" />
</p>
</div>

<p>
Any organization can use addresses from this set without permission. These are the private addresses that are used within the local area networks (LANs) by homes and organizations.
</p>
<ul class="org-ul">
<li>These private addresses are not unique globally, so they can't be used to forward packets on the internet</li>
<li>There is usually a single connection to the global internet through the router</li>
<li><i>The router runs the NAT software</i></li>
<li>The private network is transparent to the rest of the Internet; the rest of the internet only sees the NAT router with the single outside connection address</li>
<li>This connection address to NAT router is given by the ISP</li>
</ul>


<div id="org2384bb4" class="figure">
<p><img src="Network_Layer/2023-12-01_14-02-12_Screenshot 2023-12-01 140202.png" alt="2023-12-01_14-02-12_Screenshot 2023-12-01 140202.png" />
</p>
</div>
</div>

<div id="outline-container-orgcf28ef9" class="outline-5">
<h5 id="orgcf28ef9"><span class="section-number-5">7.1.5.1.</span> Address translation</h5>
<div class="outline-text-5" id="text-7-1-5-1">
<p>
All packets to and from the internet go through NAT router. This modifies the outgoing packets
</p>
<ul class="org-ul">
<li>For outgoing packets, it will replace the source address of packet to gloabl NAT address</li>
<li>For incoming packets, it will replace the destination address of packet to the appropriate private address</li>
</ul>


<div id="orga6efd5f" class="figure">
<p><img src="Network_Layer/2023-12-01_14-08-18_Screenshot 2023-12-01 140703.png" alt="2023-12-01_14-08-18_Screenshot 2023-12-01 140703.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org2d4625a" class="outline-5">
<h5 id="org2d4625a"><span class="section-number-5">7.1.5.2.</span> Translation table</h5>
<div class="outline-text-5" id="text-7-1-5-2">
<p>
For outgoing packets, the process is simple. But for incoming packets, we need a way to know the destination address of the incoming packet.
There are three types of NAT that are used
</p>

<p>
<b><span class="underline">Static NAT</span></b>
</p>

<p>
In this NAT, the router only has a single external IP address.
</p>
<ul class="org-ul">
<li>The translation table marks a pair of information for outgoing packet
<ul class="org-ul">
<li>It notes the Private IP address that is sending the packet</li>
<li>It notes the External IP address that is receiving the packet</li>
</ul></li>
<li>When there is an incoming packet,
<ul class="org-ul">
<li>It matches the source address in the packet with the External IP in table</li>
<li>If found, it will replace the destination address in packet with the Private IP from table</li>
</ul></li>
</ul>


<div id="org1cf5daf" class="figure">
<p><img src="Network_Layer/2023-12-01_14-27-36_Screenshot 2023-12-01 142732.png" alt="2023-12-01_14-27-36_Screenshot 2023-12-01 142732.png" />
</p>
</div>

<p>
This strategy has following drawback
</p>
<ul class="org-ul">
<li>Communication can only be initiated by device from inside the private network (this is why we can't have server from inside private network, when using NAT)</li>
<li>Two devices in the private network cannot communicate to same public IP address at the same time</li>
</ul>

<p>
<b><span class="underline">Dynamic NAT</span></b>
</p>

<p>
In this NAT, the router has multiple external IP addresses. The translation process is the same, but it allows multiple hosts from private network to communicate to same external IP address at the same time.
</p>

<p>
So, if the NAT router has 4 global addresses assigned to it. Then 4 hosts in private network can communicate to the same external IP address at the same time.
</p>

<p>
<b><span class="underline">Port Address Translation</span></b>
</p>

<p>
In this strategy, instead of only storing a pair of data (Private IP and External IP), we will store 5 columns of data in translation table
</p>
<ul class="org-ul">
<li>5 columns of data is stored in translation table for every outgoing packet
<ul class="org-ul">
<li>The private IP address and it's private port number</li>
<li>The external IP address and it's external port number</li>
<li>The transport protocol that is used for communication</li>
</ul></li>
<li>For an incoming packet
<ul class="org-ul">
<li>It will try to match all the four extra column data i.e, Private Port, External Address, External Port and Transport Protocol</li>
<li>If the data matches, it will replace the destination address in packet with the corrosponding Private Address</li>
</ul></li>
</ul>


<div id="org8e37bf9" class="figure">
<p><img src="Network_Layer/2023-12-01_14-56-27_Screenshot 2023-12-01 145623.png" alt="2023-12-01_14-56-27_Screenshot 2023-12-01 145623.png" />
</p>
</div>

<p>
There can be a case where two hosts use the same private port, but it is extremely rare that this happens. Therefore, this is a very efficient way to have many-to-may communication in a NAT
</p>
</div>
</div>

<div id="outline-container-orge976dcf" class="outline-5">
<h5 id="orge976dcf"><span class="section-number-5">7.1.5.3.</span> Usuage of NAT by ISPs</h5>
<div class="outline-text-5" id="text-7-1-5-3">
<p>
NAT technology allows ISPs to have way more customers than the number of global IP addresses it is granted. The ISP can simply assign private IP addresses to it's customers and then it will use NAT on it's site to connect all of the users to the internet.
</p>

<p>
Example, if an ISP has 1000 addresses and 100,000 customers, it can translate packets from all 100,000 customers to one of the 1000 global addresses. As show in the example below
</p>


<div id="orgd2b3f40" class="figure">
<p><img src="Network_Layer/2023-12-01_15-01-47_Screenshot 2023-12-01 150143.png" alt="2023-12-01_15-01-47_Screenshot 2023-12-01 150143.png" />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org108ca2f" class="outline-3">
<h3 id="org108ca2f"><span class="section-number-3">7.2.</span> IPv6 Addresses</h3>
<div class="outline-text-3" id="text-7-2">
<p>
IPv6 address is 128 bits long. That is it is 16 bytes long. So the address space is \(2^{128}\) addresses
</p>
</div>
<div id="outline-container-org5365b49" class="outline-4">
<h4 id="org5365b49"><span class="section-number-4">7.2.1.</span> Notation</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
2 bytes of data can be shown by 4 hexadecimal digits. Therefore, we use 4 hexadecimal digits for every 2 bytes which is seperated by colons.
Example,
\[ FDEC:0074:0000:0000:0000:B0FF:0000:FFFF \]
</p>
</div>
<div id="outline-container-orgd4ab684" class="outline-5">
<h5 id="orgd4ab684"><span class="section-number-5">7.2.1.1.</span> Abbriviating notation</h5>
<div class="outline-text-5" id="text-7-2-1-1">
<p>
As we can see in the example, the four hexadecimal digits may have leading 0's (we can see it above in 0074). Rather than writing leading 0's, we can abbriviate them. We also write (0000) as just 0
\[ FDEC:74:0:0:0:B0FF:0:FFFF \]
This is much more convinient to write. But we can see that between 74 and B0FF, there are only 0's. This is sometimes further abbriviated to only
\[ FDEC:74::B0FF:0:FFFF \]
</p>


<div id="orgb6c8b9f" class="figure">
<p><img src="Network_Layer/2023-12-01_15-20-05_Screenshot 2023-12-01 152000.png" alt="2023-12-01_15-20-05_Screenshot 2023-12-01 152000.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org523a257" class="outline-4">
<h4 id="org523a257"><span class="section-number-4">7.2.2.</span> Address Space</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
The few leftmost bits in the IPv6 address are type prefix. The type prefix is variable in length
</p>

<div id="org1f61670" class="figure">
<p><img src="Network_Layer/2023-12-01_16-03-23_Screenshot 2023-12-01 160313.png" alt="2023-12-01_16-03-23_Screenshot 2023-12-01 160313.png" />
</p>
</div>


<div id="orged7e937" class="figure">
<p><img src="Network_Layer/2023-12-01_16-03-45_Screenshot 2023-12-01 160341.png" alt="2023-12-01_16-03-45_Screenshot 2023-12-01 160341.png" />
</p>
</div>
</div>

<div id="outline-container-org799c08e" class="outline-5">
<h5 id="org799c08e"><span class="section-number-5">7.2.2.1.</span> Unicast address</h5>
<div class="outline-text-5" id="text-7-2-2-1">
<p>
A unicast address define a single computer. Packet sent to a unicast address must be delivered to that specific computer. There are two types of unicast addresses
</p>
<ol class="org-ol">
<li>Geographic-based unicast addresses</li>
<li>Provider-based unicast addresses</li>
</ol>
<p>
The provider-based unicast address is discussed here. 
</p>

<div id="org3dcb74b" class="figure">
<p><img src="Network_Layer/2023-12-01_16-09-20_Screenshot 2023-12-01 160915.png" alt="2023-12-01_16-09-20_Screenshot 2023-12-01 160915.png" />
</p>
</div>

<p>
Fields for provider-based address is as follows
</p>
<ol class="org-ol">
<li>Type identifier : This is the first 3-bit field, this defines the address as provider-based address</li>
<li>Registry identifier : This is a 5-bit field, used to identify the agency that has registered the address. There are currently three registry centers. INTERNIC is for north america; RIPNIC is for center European; APNIC is for Asian and Pacific countries.</li>
<li>Provider identifier : varibale-length field identifies the provider for Internet access (such as ISP). 16-bit is recommended length</li>
<li>Subscriber identifier : variable-length field that identifies the subscriber to the ISP. A 24-bit length is recommended</li>
<li>Subnet identifier : each subscriber can have multiple subnets, and each subnet has different identifier. A 32-bit lenght is recommended</li>
<li>Node identifier : defines the node connected to the subnet. A length of 48-bits is recommended for this field to make it compatible with 48-bit MAC addresses.</li>
</ol>
</div>
</div>

<div id="outline-container-org7fc15f2" class="outline-5">
<h5 id="org7fc15f2"><span class="section-number-5">7.2.2.2.</span> Multicast addresses</h5>
<div class="outline-text-5" id="text-7-2-2-2">
<p>
Addresses define a group of hosts instead of just one.
</p>

<div id="orgdd340e4" class="figure">
<p><img src="Network_Layer/2023-12-01_16-18-28_Screenshot 2023-12-01 161823.png" alt="2023-12-01_16-18-28_Screenshot 2023-12-01 161823.png" />
</p>
</div>

<ul class="org-ul">
<li>The flag field is used to define group addresses as either permanent or transient. Some group addresses are permanent define by Internet authorities and can be accessed at all times. A transient group address is only used temporarily.</li>
<li>The scope field is used to define the scope of the group</li>
</ul>
</div>
</div>
<div id="outline-container-org2f6108c" class="outline-5">
<h5 id="org2f6108c"><span class="section-number-5">7.2.2.3.</span> Anycast addresses</h5>
<div class="outline-text-5" id="text-7-2-2-3">
<p>
IPv6 also defines anycast addresses which like multicast addresses also group nodes. However, in anycast addresses packet is delivered to only one of it's member. It is the member that is the nearest one (with shortest route)
</p>
</div>
</div>
<div id="outline-container-org71bdb39" class="outline-5">
<h5 id="org71bdb39"><span class="section-number-5">7.2.2.4.</span> Reserved addresses</h5>
<div class="outline-text-5" id="text-7-2-2-4">
<p>
These addressess start with eight 0s. 
</p>

<div id="orgaca5e98" class="figure">
<p><img src="Network_Layer/2023-12-01_16-30-51_Screenshot 2023-12-01 163046.png" alt="2023-12-01_16-30-51_Screenshot 2023-12-01 163046.png" />
</p>
</div>

<ul class="org-ul">
<li>Unspecified is used when host does not know it's own address and send inquiry to find it's address (in DHCP)</li>
<li>Loopback is used by host to test itself without going to the network</li>
<li>The compatible address is used during transition from IPv4 to IPv6</li>
<li>The mapped address is also used for this purpose, it is used when computer that migrated to IPv6 wants to send packet to computer using IPv4</li>
</ul>
</div>
</div>
<div id="outline-container-orgef1ed41" class="outline-5">
<h5 id="orgef1ed41"><span class="section-number-5">7.2.2.5.</span> Local addresses</h5>
<div class="outline-text-5" id="text-7-2-2-5">
<p>
These are addresses used by organizations that want to use IPv6 without being connected to global internet.
</p>
<ul class="org-ul">
<li>They are equivalent in role to the private addresses of IPv4</li>
<li>Link local address is used in an isolated subnet</li>
<li>Site local address is used in an isolated site with several subnets</li>
</ul>


<div id="orgd27f9dd" class="figure">
<p><img src="Network_Layer/2023-12-01_16-36-47_Screenshot 2023-12-01 163643.png" alt="2023-12-01_16-36-47_Screenshot 2023-12-01 163643.png" />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org2f0ef81" class="outline-3">
<h3 id="org2f0ef81"><span class="section-number-3">7.3.</span> The Internet Protocol</h3>
<div class="outline-text-3" id="text-7-3">
<p>
The internet is a connectionless network, i.e, there is no connection step where the route is fixed. Also  internet is a datagram network, i.e, it is packet-switched which means it uses universal addresses (IP addresses) to carry packets from source to destination.
</p>
</div>
<div id="outline-container-org115a3e5" class="outline-4">
<h4 id="org115a3e5"><span class="section-number-4">7.3.1.</span> IPv4</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
The IPv4 is the delivery mechanism used by TCP/IP protocols
</p>


<div id="orgcfa057c" class="figure">
<p><img src="Network_Layer/2023-12-01_17-30-49_Screenshot 2023-12-01 173044.png" alt="2023-12-01_17-30-49_Screenshot 2023-12-01 173044.png" />
</p>
</div>

<p>
IPv4 is unreliable and connectionaless datagram protocol.
</p>
<ul class="org-ul">
<li>It is a best-effort service, meaning it provides no error control or flow control (except error detection in header).</li>
<li>If reliability is important, we pair IPv4 with TCP.</li>
<li>Each datagram is handeled independently, and each can follow a different route to destination.</li>
</ul>
</div>
<div id="outline-container-orge0e1623" class="outline-5">
<h5 id="orge0e1623"><span class="section-number-5">7.3.1.1.</span> Datagram format</h5>
<div class="outline-text-5" id="text-7-3-1-1">
<p>
Packets in IPv4 are called datagrams. It is a variable-length packet consisting of two parts : header and data.
</p>

<p>
The header has following parts
</p>
<ol class="org-ol">
<li>Version (VER) : 4-bit field which defines the version of IPv4 protocol. Currently version is 4.</li>
<li>Header Length (HLEN) : 4-bit field defines total length of the header in 4-byte word. This number is between 5 and 15. The minimum is five 4-byte words i.e a total of 20 bytes. The maximum is fifteen 4-byte words i.e, total of 60 bytes. (Header of IPv4 datagram is always in form of 4-byte words)</li>
<li><p>
Services : 8-bit field which has two different interpretations service type and differentiated services. We will only see service-type interpretation
</p>


<div id="org8c59e36" class="figure">
<p><img src="Network_Layer/2023-12-01_18-03-53_Screenshot 2023-12-01 180348.png" alt="2023-12-01_18-03-53_Screenshot 2023-12-01 180348.png" />
</p>
</div>

<p>
The precedance is 3-bit subfield which ranges from 0 to 7 and holds the priority of a packet. TOS is 4-bit subfield that stores the type of service that this datagram requires
</p>


<div id="orgde507c1" class="figure">
<p><img src="Network_Layer/2023-12-01_18-06-31_Screenshot 2023-12-01 180628.png" alt="2023-12-01_18-06-31_Screenshot 2023-12-01 180628.png" />
</p>
</div></li>

<li>Total length : 16-bits field that stores the total lenght of packet (header + data) in bytes. This field is needed since underlying protocols (like ethernet) may add padding to the data which needs to be removed.</li>
<li>Identification : 16-bit field used in fragmentation</li>
<li>Flags : 16-bit field used in fragmentation</li>
<li>Fragmentation Offset : 13-bit field used in fragmentation</li>
<li>Time to live : 8-bit field. Datagram packets have limited lifetime in its travel.
<ul class="org-ul">
<li>Originally this held timestamp which decremented by each visited router.</li>
<li>When it is 0, packet is discarded</li>
<li>However, that meant all machines must be synchronized. So now it is used to control maximum number of hops (routers visited)</li>
<li>This field is needed because routing tables can become corrupted and datagram may get passed around forever if not destroyed</li>
<li>It can also be used to limit the journed to local network only by setting it to 1</li>
</ul></li>
<li><p>
Protocol : 8-bit field which defines the higher-level protocol being used.
</p>

<div id="org0d9eba7" class="figure">
<p><img src="Network_Layer/2023-12-01_18-37-24_Screenshot 2023-12-01 183720.png" alt="2023-12-01_18-37-24_Screenshot 2023-12-01 183720.png" />
</p>
</div></li>

<li>Checksum : 16-bit field. The IPv4 checksum only covers the header and not the data, this is because upper-layers are already storing checksums for data. It is calculated as follows
<ul class="org-ul">
<li>The checksum field is set to 0</li>
<li>The entire header is divided to 16-bit sections</li>
<li>All sections are added together, if the result is greater than 16-bit then extra bits are taken from left and added to the sum. Example, if sum is \((2479c)_{16}\), then we can do \(2 + 479c = 479e\) to get sum</li>
<li>The resulting sum is complemented and inserted to checksum field</li>
</ul></li>
<li>Source address : 32-bit field to store IPv4 address of source</li>
<li>Destination address : 32-bit field to store IPv4 address of destination</li>
<li>Options : it's size is between 0 bytes and 40 bytes. It is not required in a IPv4 datagram but is used for network testing and debugging. Without options field, a IPv4 datagram header is only 20 bytes</li>
</ol>


<div id="org5fe8405" class="figure">
<p><img src="Network_Layer/2023-12-01_18-57-01_Screenshot 2023-12-01 185506.png" alt="2023-12-01_18-57-01_Screenshot 2023-12-01 185506.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org792bf82" class="outline-5">
<h5 id="org792bf82"><span class="section-number-5">7.3.1.2.</span> Fragmentation</h5>
<div class="outline-text-5" id="text-7-3-1-2">
<p>
Every router decapsulated the IPv4 datagram from frame it receives, processes it and then encapsulates it into a new frame. The formats and sizes of frames depend on the protcols used by the lower layers
</p>

<p>
<b><span class="underline">Maximum Transfer Unit (MTU)</span></b>
</p>

<p>
All data link layer protcols have their own frame format. Each format has a different maximum size of data field. So before we can only pass datagrams to data link layer, we need to make sure it is smaller than this limit. This limit is called the Maximum Transfer Unit (MTU).
</p>

<p>
MTUs for some protocols in bytes are :
</p>

<div id="orga217a58" class="figure">
<p><img src="Network_Layer/2023-12-01_19-20-17_Screenshot 2023-12-01 192012.png" alt="2023-12-01_19-20-17_Screenshot 2023-12-01 192012.png" />
</p>
</div>

<p>
The maximum size of IPv4 datagram is 65,535 bytes. However, we must divide datagram to make it possible to pass through the network. This is called fragmentation.
</p>
<ul class="org-ul">
<li>When datagram is fragmented, each fragment has its own header with all fields repeated except three</li>
<li>A fragmented datagram may get further fragmented as it travels through different networks multiple times</li>
<li>The reassembly of all the fragments is done only by the destination host.</li>
</ul>
<p>
The host or router which fragments datagram needs to change three fields: flag, fragmentation offset and total length. The value of checksum is also recalculated (this is done regardless of fragmentation, to detect errors)
</p>

<p>
<b><span class="underline">Fields Related to Fragmentation</span></b>
</p>

<ul class="org-ul">
<li><b>Identification</b> : 16-bit field used to identify the datagram originating from the source.
<ul class="org-ul">
<li>During communication, every datagram that leaves the source host has a unique identification</li>
<li>A counter is intialized to a positive value before communication starts</li>
<li>When IPv4 sends a datagram, it will copy the current value of the counter. Then increment the counter. This makes sure that Identification is unique thourghout communication</li>
<li>When a datagram is fragmented, each fragment will get the same identification value, this will help destination in reassembling (since all fragments with same ID must assemble to one datagram)</li>
</ul></li>
<li><b>Flags</b> : 3-bit field.
<ul class="org-ul">
<li>The first bit is reserved.</li>
<li>The second bit is <i>do-not-fragment bit</i>. If it's value is 1, then datagram is never fragmented. If it is too big to travel, it is discarded and an ICMP error message is sent to source.</li>
<li>The third bit is <i>more fragment bit</i>. If it's value is 1, then it means it is not the last fragment of the datagram; there are more fragments after this one. If it is 0, it means it is either last or only fragment</li>
</ul></li>
<li><b>Fragmentation offset</b> : 13-bit field which will store the relative position of this fragment with relation to data field. <b>Note</b> : the header is not accounted for the offset, only the data field is. <i>The value of offset is measured in units of 8-bytes words.</i></li>
</ul>
<p>
<i>Example</i>, suppose data is of size 4000 bytes, and MTU is 1400 bytes.
</p>
<ul class="org-ul">
<li>The  data is 4000 bytes, i.e, it is \(ceil (4000 \div 8) = 500\) 8-byte words. In general there are \(ceil (x \div 8)\) 8-byte words in \(x\) bytes of data.</li>
<li>The eight byte words are numbered from 0 to 499.</li>
<li>The MTU is of size \(floor (1400 \div 8) = 175\) 8-byte words. We floor here, since we don't want more than the MTU</li>
<li>So the fragements are
<ul class="org-ul">
<li>First fragement has offset of \(0 \times 175 = 0\)</li>
<li>Second fragment has offset of \(1 \times 175 = 175\)</li>
<li>Third fragment has offset of \(2 \times 175 = 350\)</li>
<li>In general, \(n_{th}\) fragment has offset of \((n - 1) \times floor (MTU \div 8)\)</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgef3c990" class="outline-4">
<h4 id="orgef3c990"><span class="section-number-4">7.3.2.</span> IPv6</h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
IPv4 is bad because
</p>
<ul class="org-ul">
<li>we are running out of IPv4 addresses</li>
<li>can't support real time audio and video</li>
<li>no encryption and authentication</li>
</ul>
<p>
The adoption is slow for IPv6 because of developments such as classless addressing and NAT.
</p>

<p>
The advantages of IPv6 are
</p>
<ol class="org-ol">
<li>Larger address space</li>
<li>Better header format</li>
<li>New way to add options and new options</li>
<li>allowance for easy extension</li>
<li>support for resource allocation (for real time audio and video)</li>
<li>more security</li>
</ol>
</div>
<div id="outline-container-orgdfea950" class="outline-5">
<h5 id="orgdfea950"><span class="section-number-5">7.3.2.1.</span> Packet format</h5>
<div class="outline-text-5" id="text-7-3-2-1">
<p>
Packets in IPv6 composed of mandatory base header followed by payload. The payload consists of two parts : the optional extension headers and data from upper layer.
</p>

<p>
The base header is of 40 bytes, and extension headers + data from upper layer can go up to 65,535 bytes
</p>

<div id="org2658628" class="figure">
<p><img src="Network_Layer/2023-12-01_21-59-49_Screenshot 2023-12-01 215944.png" alt="2023-12-01_21-59-49_Screenshot 2023-12-01 215944.png" />
</p>
</div>

<p>
<b>Base Header</b>
</p>

<ol class="org-ol">
<li>Version : 4-bit field defines the version number of IP. value is 6</li>
<li><p>
Priority : 4-bit field define priority of the packet. Unlike IPv4 packets, the priority in IPv6 is with respect to other packets from the same source. Values from 0 to 7 are used in <i>congestion-controlled traffic</i> and values from 8 to 15 are used in <i>noncongestion-controlled traffic</i>
</p>
<ul class="org-ul">
<li>If source can adapt itself to traffic slowdown, it is refferred to as congestion-controlled traffic. Example, when using TCP
<ol class="org-ol">
<li>value of 0 means <i>no specefic traffic</i>, so no priority is defined</li>
<li>value of 1 means <i>background data</i>, this means data is to be delivered in the background i.e, least priority</li>
<li>value of 2 means <i>unattended data traffic</i>, a little bit of delay is of little consequence. example is Email</li>
<li>value of 4 means <i>attended bulk data traffic</i>, used for protocols where user is waiting (attending) to receive data. like FTP and HTTP</li>
<li>value of 6 means <i>interactive traffic</i>, protocols such as TELNET have second highest priority</li>
<li>value of 7 means <i>control traffic</i>, routing protocols such as OSPF and RIP have highest priority</li>
</ol></li>
</ul>

<div id="org0887e12" class="figure">
<p><img src="Network_Layer/2023-12-01_22-25-13_Screenshot 2023-12-01 222509.png" alt="2023-12-01_22-25-13_Screenshot 2023-12-01 222509.png" />
</p>
</div>

<ul class="org-ul">
<li><p>
In noncongestion-controlled traffic there is mimimum delay. Discarding packets is not desirable. Retransmission is mostly impossible, because source does not adapt to congestion. Data with least redundancy (low-fidelity audio or video) is given priority over data with high redundancy (high-fidelity audio or video)
</p>

<div id="org6a1346e" class="figure">
<p><img src="Network_Layer/2023-12-01_22-25-41_Screenshot 2023-12-01 222537.png" alt="2023-12-01_22-25-41_Screenshot 2023-12-01 222537.png" />
</p>
</div></li>
</ul></li>

<li>Flow label : 3-byte (24-bit) field provided for special handling of particular flow of data. A sequence of packets that needs special handling by routers is called <i>flow of packets</i>.
<ul class="org-ul">
<li>Combination of source address and value of flow label defines a flow of packets</li>
<li>A flow of packets will travel the same path, use same resources and have same kind of security</li>
<li>This is useful to support real time audio and video</li>
</ul></li>
<li>Payload length : 16-bit field, it stores unsigned number that indicates total size of payload including extension headers and data from upper layer. <i>If size is greater than \(2^{16} - 1\), it is set to 0 and jumbo payload option is used in hop-by-hop extension header</i></li>
<li>Next Header : 8-bits field that defines the type of the next header. <i>This field is used to chain multiple extension headers.</i></li>
<li>Hop limit : 8-bit field that serves same purpose as TTL field in IPv4. Discards frame when hop limit reaches 0</li>
<li>Source Address : the address to source machine of the packet</li>
<li>Destination Address : the address to destination machine of the packet</li>
</ol>

<p>
<b><span class="underline">Extension Headers</span></b>
</p>

<div id="org065d529" class="figure">
<p><img src="Network_Layer/2023-12-01_22-45-17_Screenshot 2023-12-01 224513.png" alt="2023-12-01_22-45-17_Screenshot 2023-12-01 224513.png" />
</p>
</div>

<p>
Each extension header can have a different size and adds some other option. Some of the common ones are
</p>
<ul class="org-ul">
<li>Hop-by-hop option : used when some information needs to be passed to all routers the packet visits. Only three defined thus far.
<ul class="org-ul">
<li>Pad1 is for alignment purposes</li>
<li>PadN is similar purpose but is used when 2 or more bytes need alignment</li>
<li><i>Jumbo payload</i> options is used when payload is greater than 65,535 bytes</li>
</ul></li>
<li>Fragmentation : in IPv6 only the source machine can fragment the packet. This is used when a packet is fragmented</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orge81c1df" class="outline-3">
<h3 id="orge81c1df"><span class="section-number-3">7.4.</span> Address Mapping</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>The physical address is a local address. It's jurisdriction is the local network. It is unique locally but not universally. Example, 48-bit MAC address</li>
<li>The logical address is required for host-to-host delivery on the internet</li>
</ul>
<p>
So for delivery of packet, two levels of addressing are required. So we need to map physical addresses to logical addresses. We can have either a static mapping or a dynamic mapping
</p>

<p>
Static mapping has a table that associates logical addresses with a physical address. The table is stored on each machine on the network. But static tables need to be updated periodically, so we can use dynamic mapping.
</p>
</div>
<div id="outline-container-org521e640" class="outline-4">
<h4 id="org521e640"><span class="section-number-4">7.4.1.</span> Mapping Logical to Physical Address : ARP</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
If a host or a router wants to know the physical address of some other device on network, whose logical address it knows, it sends an ARP query packet
</p>
<ul class="org-ul">
<li><i>This query packet is broadcasted</i> to all devices on network</li>
<li>This query packet contains the physical and IP address of the sender and IP address of receiver</li>
<li>Every host or router on network wil receive and process the ARP query packet, but only the intended recipient recognizes its own IP address and send back the ARP response</li>
<li>The response packet will contain the recipient's IP and physical address</li>
<li><i>The response packet is unicast</i></li>
</ul>

<div id="org62ca1bb" class="figure">
<p><img src="Network_Layer/2023-12-01_23-59-52_Screenshot 2023-12-01 235943.png" alt="2023-12-01_23-59-52_Screenshot 2023-12-01 235943.png" />
</p>
</div>
</div>
<div id="outline-container-org2d4a2f1" class="outline-5">
<h5 id="org2d4a2f1"><span class="section-number-5">7.4.1.1.</span> Cache memory</h5>
<div class="outline-text-5" id="text-7-4-1-1">
<p>
Using ARP is inefficient for every single packet sent between two systems
</p>
<ul class="org-ul">
<li>ARP reply is usually cached since normally several packets are sent to the same device</li>
<li>ARP reply are stored in cache for upto 20 to 30 minutes</li>
<li>Before sending an ARP request, the cache memory is always checked</li>
</ul>
</div>
</div>
<div id="outline-container-orgaad5ff9" class="outline-5">
<h5 id="orgaad5ff9"><span class="section-number-5">7.4.1.2.</span> Packet Format</h5>
<div class="outline-text-5" id="text-7-4-1-2">

<div id="org16fefb8" class="figure">
<p><img src="Network_Layer/2023-12-02_00-03-07_Screenshot 2023-12-02 000300.png" alt="2023-12-02_00-03-07_Screenshot 2023-12-02 000300.png" />
</p>
</div>

<ol class="org-ol">
<li>Hardware Type : 16-bit field defines the data link layer protocol type. Example : ethernet is 1</li>
<li>Protocol Type : 16-bit field defines the network layer protocol type. Example : IPv4 is 0x0800</li>
<li>Hardware Length : 8-bit field, length of physical address in bytes. Example, ethernet is 6 (since MAC address is 48-bits)</li>
<li>Protocol length : 8-bit field, length of the logical address in bytes. Example, IPv4 is 4</li>
<li>Operation : 16-bit field, specifies what the sender of this frame is performing. <i>1 for request, 2 for reply</i></li>
<li>Sender hardware address : variable-length field, the physical address of device sending this frame</li>
<li>Sender protocol address : variable-length field, the logical address of device sending this frame</li>
<li>Target hardware address : variable-length field, the hardware address of device receiving this frame.
<ul class="org-ul">
<li>For ARP query, this field is ignored</li>
<li>For ARP reply, this field has the address of host from which the query originated</li>
</ul></li>
<li>Target Protocol address : variable-length field, of the receiver of this packet</li>
</ol>

<p>
This packet is encapsulated directly into data link frame without any changes. As shown in the following ethernet frame.
</p>


<div id="orgae24a40" class="figure">
<p><img src="Network_Layer/2023-12-02_00-22-01_Screenshot 2023-12-02 002155.png" alt="2023-12-02_00-22-01_Screenshot 2023-12-02 002155.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org5aa5fe6" class="outline-5">
<h5 id="org5aa5fe6"><span class="section-number-5">7.4.1.3.</span> Proxy ARP</h5>
<div class="outline-text-5" id="text-7-4-1-3">

<div id="org217d4ef" class="figure">
<p><img src="Network_Layer/2023-12-02_00-40-02_Screenshot 2023-12-02 003957.png" alt="2023-12-02_00-40-02_Screenshot 2023-12-02 003957.png" />
</p>
</div>

<ul class="org-ul">
<li>ARP only works on the local network</li>
<li>If we want to support ARP for another subnetwork, connected via a router we can use PARP</li>
<li><b>The Proxy ARP router will give it's own physical address rather than one from subnet</b></li>
<li>After it gets the IP packet, it sends it to appropriate host on subnetwork</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org09dce48" class="outline-4">
<h4 id="org09dce48"><span class="section-number-4">7.4.2.</span> Mapping Physical to Logical Address : BOOTP and DHCP</h4>
<div class="outline-text-4" id="text-7-4-2">
</div>
<div id="outline-container-org18fb2fa" class="outline-5">
<h5 id="org18fb2fa"><span class="section-number-5">7.4.2.1.</span> BOOTP</h5>
<div class="outline-text-5" id="text-7-4-2-1">
<p>
The Bootstrap Protocol (BOOTP) is client/server protocol designed to provide physical address to logical address mapping.
</p>
<ul class="org-ul">
<li>BOOTP is an application layer protocol</li>
<li>Client and server can be on same or different networks</li>
<li>BOOTP uses UDP packets, and UDP packet are encapsulated in IP packet</li>
</ul>
<p>
The operation is as follows
</p>

<p>
<b><span class="underline">Case 1 : Client and server on same network</span></b>
</p>

<p>
The client broadcasts a packet called "BOOTP request" and it is picked up by the BOOTP server, which replies with the following information
</p>
<ol class="org-ol">
<li>The client's IP address, subnet mask, and default gateway address</li>
<li>IP address and host name of BOOTP server</li>
<li>IP address of the server that has boot image, which client needs to load. This server can be the same as the BOOTP server itself</li>
<li>The client loads the image to configure and initialize the TCP/IP stack</li>
</ol>

<p>
<b><span class="underline">Case 2 : Client and server on different network</span></b>
</p>

<p>
Since BOOTP request is a broadcast, it cannot pass through a router. The router will discard the packet. To solve this problem, a relay agent is used
</p>
<ol class="org-ol">
<li>The relay agent knows address of BOOTP server and listens for BOOTP request broadcasts</li>
<li>When it receives the broadcast, it will encapsulate the message and send it to BOOTP server</li>
<li>The relay agent also receives the reply and send it to the client</li>
</ol>


<div id="org58d50ca" class="figure">
<p><img src="Network_Layer/2023-12-02_01-25-54_Screenshot 2023-12-02 012550.png" alt="2023-12-02_01-25-54_Screenshot 2023-12-02 012550.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgd4f0175" class="outline-5">
<h5 id="orgd4f0175"><span class="section-number-5">7.4.2.2.</span> DHCP</h5>
<div class="outline-text-5" id="text-7-4-2-2">
<p>
BOOTP is not dynamic configuration protocol.
</p>
<ul class="org-ul">
<li>When it wants to give info to the client it uses a table which is manually filled by the administrator</li>
<li>This table is static and does not change, till modified by admin</li>
</ul>
<p>
So we have Dynamic Host Configuration Protocol (DHCP) to provide static and dynamic address allocation
</p>
<ul class="org-ul">
<li><i>For static allocation, DHCP acts as BOOTP does.</i> It is backwords compatible, so a BOOTP client can request address from a DHCP server. DHCP maintains a static database to maintain this backwards compatibility</li>
<li><i>For dynamic allocation</i>, DHCP has a second database which has a pool of available IP addresses. This second databse is dynamic
<ul class="org-ul">
<li>The DHCP server first checks it's static database. If physical address of client is found, it will give it the permanent IP address of the client</li>
<li>If client is not in static databse, it will take an unused IP address from dynamic database and give client the temporary IP address for a limited time.
<ul class="org-ul">
<li>When the time for lease of the address expires, the client either stops using the address or it must renew the lease</li>
<li>The DHCP server can decide to either agree or disagree to renewal</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf031f47" class="outline-4">
<h4 id="orgf031f47"><span class="section-number-4">7.4.3.</span> ICMP</h4>
<div class="outline-text-4" id="text-7-4-3">
<p>
The IP protocol lacks two very important things
</p>
<ol class="org-ol">
<li>It has no error-reporting mechanism</li>
<li>It lacks mechanism for host and management queries</li>
</ol>
<p>
The Internet Control Message Protocol (ICMP) is designed to compensate for both of these drawbacks
</p>
</div>
<div id="outline-container-org39fbf11" class="outline-5">
<h5 id="org39fbf11"><span class="section-number-5">7.4.3.1.</span> Types of messages</h5>
<div class="outline-text-5" id="text-7-4-3-1">
<p>
ICMP message can be divided into two broad categories : error-reporting messages and query messages.
</p>
<ul class="org-ul">
<li>error-reporting messages are to report problems a router or host may encounter when it processess an IP packet</li>
<li>query messages occur in pairs, some host or router has a query and it asks the question and specific information is recieved from another host. this is used when nodes want to discover their neighbours or learn about routers on network</li>
</ul>
</div>
</div>
<div id="outline-container-orgd11a400" class="outline-5">
<h5 id="orgd11a400"><span class="section-number-5">7.4.3.2.</span> Message format</h5>
<div class="outline-text-5" id="text-7-4-3-2">
<p>
An ICMP message has an 8-byte header and a variable size data section. The format is different for different types of messaages, but the first 4-bytes are common
</p>
<ol class="org-ol">
<li>Type : 8-bits, defines the type of the message</li>
<li>Code : 8-bits, defines the reason for the particular messaage type</li>
<li>Checksum : 16-bits, in ICMP the checksum is calculated over the entire message (header and the data)
<ul class="org-ul">
<li>Since we want 16-bits, we group the data into 16-bits i.e, 2 bytes</li>
<li>We sum all of the grouped data, if sum is larger than 16-bits, then extra leftmost bits are taken and added to the sum. Example, if sum is \((2479c)_{16}\), then we can do \(2 + 479c = 479e\) to get sum</li>
<li>We complement the received sum in-order to get the checksum</li>
</ul></li>
<li>Data section : in error messages, this will carry information about the original packet that had the error. In query messages, it carries information based on type of query</li>
</ol>

<div id="orgcf19299" class="figure">
<p><img src="Network_Layer/2023-12-02_02-22-27_Screenshot 2023-12-02 022217.png" alt="2023-12-02_02-22-27_Screenshot 2023-12-02 022217.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb514932" class="outline-5">
<h5 id="orgb514932"><span class="section-number-5">7.4.3.3.</span> Error reporting</h5>
<div class="outline-text-5" id="text-7-4-3-3">
<ul class="org-ul">
<li>ICMP cannot correct errors, it simply reports them. Correction is left to higher-level protocols.</li>
<li>Error messages are sent to the source where the problematic packet came from, by reading the datagram.</li>
</ul>
<p>
The datagrams for which no error messages are generated are
</p>
<ol class="org-ol">
<li>No ICMP messages are generated for other ICMP error messages</li>
<li>No ICMP messages are generated for fragmented datagram except the first one</li>
<li>No ICMP messages generated for multicast address datagrams</li>
<li>No ICMP messages for special addresses such as 127.0.0.0 or 0.0.0.0</li>
</ol>
<p>
<i>The content of data field in error message ICMP is the IP header of the problematic frame along with first 8 bytes of it's data</i>
</p>


<div id="orge90606c" class="figure">
<p><img src="Network_Layer/2023-12-02_13-30-54_Screenshot 2023-12-02 133040.png" alt="2023-12-02_13-30-54_Screenshot 2023-12-02 133040.png" />
</p>
</div>

<p>
Some of the types of error messages are
</p>

<p>
<b><span class="underline">Destination Unreachable</span></b>
</p>

<p>
When router can't route a datagram or host can't deliver a datagram, it will be discarded and destination-unreachable is sent
</p>

<p>
<b><span class="underline">Source Quench</span></b>
</p>

<p>
IP protocol does not have flow control, which creates congestion.
</p>
<ul class="org-ul">
<li>Routers and host have limited-size queues (buffers) to process datagrams, if datagrams are received faster than they are processed then buffer will overflow.</li>
<li>To avoid this, router or host will discard some of the datagrams</li>
<li>The source-quench message is sent to source to inform it that datagram was discarded and to slow down the sending process</li>
</ul>

<p>
<b><span class="underline">Time Exceeded</span></b>
</p>

<ul class="org-ul">
<li>If there are errors in routing table, then packet can travel in a loop. In this case, the TTL field eventually becomes 0 and datagram is discarded. This message is sent back to source to inform it about this.</li>
<li>This message is also generated when not all fragments arrive at the destination within a time limit</li>
</ul>

<p>
<b><span class="underline">Parameter Problem</span></b>
</p>

<p>
If there is ambiguity of missing value in datagram header, then it is discarded and this message is sent to source
</p>

<p>
<b><span class="underline">Redirection</span></b>
</p>

<p>
During routing process, hosts use a static routing table and routers use dynamic routing table. Host use static routing table to reduce traffic that would increase if it's table is constantly updated.  However, this means it can send datagram to wrong router. In this case, router will send the datagram to the correct router, but it will also send a redirection message to the device which sent the datagram to wrong router. The device then fixes it's routing table
</p>

<div id="org1d8163d" class="figure">
<p><img src="Network_Layer/2023-12-02_13-29-59_Screenshot 2023-12-02 132955.png" alt="2023-12-02_13-29-59_Screenshot 2023-12-02 132955.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org894ec85" class="outline-5">
<h5 id="org894ec85"><span class="section-number-5">7.4.3.4.</span> Query messages</h5>
<div class="outline-text-5" id="text-7-4-3-4">
<p>
Query messages can be used for diagnosing and debugging the network
</p>

<div id="org10cbf54" class="figure">
<p><img src="Network_Layer/2023-12-02_13-35-52_Screenshot 2023-12-02 133547.png" alt="2023-12-02_13-35-52_Screenshot 2023-12-02 133547.png" />
</p>
</div>

<p>
<b><span class="underline">Echo Request and Reply</span></b>
</p>

<p>
These are messages for diagnostic purposes. The combination of echo-reply and echo-request messages tells whether two devices can communicate with each other at IP level
</p>

<p>
<b><span class="underline">Timestamp Request and Reply</span></b>
</p>

<p>
Two machines can use timestamp request and reply messages to determine the <i>round-trip time</i> needed for IP datagram to travel. Also useful to synchronize clocks.
</p>

<p>
<b><span class="underline">Address-Mask Request and Reply</span></b>
</p>

<p>
A host may know it's IP address but not the mask.
</p>
<ul class="org-ul">
<li>To obtain the mask, it will send address-mask-request to a router on the LAN.</li>
<li>If it knows the address of router, it will unicast the message else it will broadcast</li>
<li>The router responds with address-mask-reply messaage</li>
</ul>

<p>
<b><span class="underline">Router Solicitation and Advertisement</span></b>
</p>

<p>
A host needs to know about routers on its network and if they are alive and working
</p>
<ul class="org-ul">
<li>Host broadcasts the router-soliciation message</li>
<li>Router or routers that recieve the message will broadcast their routing information using Router-advertisement message</li>
<li>This advertisement not only announces it's own info, but of all the routers on the network</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf632871" class="outline-4">
<h4 id="orgf632871"><span class="section-number-4">7.4.4.</span> ICMPv6</h4>
<div class="outline-text-4" id="text-7-4-4">
<p>
ICMP was modified for IPv6. The ARP and IGMP protocols were are combined in ICMPv6. Similar to ICMPv4, messages are of two types but we have more type of messages.
</p>
</div>
<div id="outline-container-org05960a3" class="outline-5">
<h5 id="org05960a3"><span class="section-number-5">7.4.4.1.</span> Error messages</h5>
<div class="outline-text-5" id="text-7-4-4-1">

<div id="org476e1e7" class="figure">
<p><img src="Network_Layer/2023-12-02_14-13-37_Screenshot 2023-12-02 141332.png" alt="2023-12-02_14-13-37_Screenshot 2023-12-02 141332.png" />
</p>
</div>

<p>
One new type of error message was added in ICMPv6 and Source quench was removed
</p>

<p>
<b><span class="underline">Packet too big</span></b>
</p>

<p>
Since IPv6 does not fragment packet unless it's the source host. If packet is too big to travel through a network, it has to be discarded and this message is sent to source.
</p>
</div>
</div>
<div id="outline-container-orgce1e901" class="outline-5">
<h5 id="orgce1e901"><span class="section-number-5">7.4.4.2.</span> Query messages</h5>
<div class="outline-text-5" id="text-7-4-4-2">

<div id="org0e5dcf4" class="figure">
<p><img src="Network_Layer/2023-12-02_14-16-12_Screenshot 2023-12-02 141607.png" alt="2023-12-02_14-16-12_Screenshot 2023-12-02 141607.png" />
</p>
</div>

<p>
<b><span class="underline">Neighbour Solicitation and Advertisement</span></b>
</p>

<p>
In IPv6, ARP was eliminated, and its duties were included in ICMPv6. The process is still the same, but format of message is changed.
</p>

<p>
<b><span class="underline">Group membership</span></b>
</p>

<p>
IGMP is eliminated and its duties are given to the ICMPv6
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgec4599a" class="outline-3">
<h3 id="orgec4599a"><span class="section-number-3">7.5.</span> Delivery</h3>
<div class="outline-text-3" id="text-7-5">
<p>
The network layer supervises the handling of packets by the physical network. This is called delivery of packets.
</p>

<p>
Delivery is of two types
</p>
<ol class="org-ol">
<li>Direct Delivery : the final destination of packet is a host on same physical network as deliverer.
<ul class="org-ul">
<li>There are two times this happens, either both host are on same network, or a router receives a packet from outside network which it will deliver to it's own network.</li>
<li>The mask is used for direct delivery.</li>
<li>The number of routers to hop for direct delivery is 0</li>
</ul></li>
<li>Indirect Delivery : when destination is not on same network, the packet is delivered indirectly
<ul class="org-ul">
<li>Packet goes from router to router till it reaches the correct network</li>
<li>Once it reaches the correct network, it is delivered finally by a direct delivery</li>
<li>The number of routers hopped for indirect delivery is non-zero</li>
<li><b>NOTE</b> : last delivery of the packet is always direct</li>
</ul></li>
</ol>


<div id="org9bee24b" class="figure">
<p><img src="Network_Layer/2023-12-02_14-50-35_Screenshot 2023-12-02 145029.png" alt="2023-12-02_14-50-35_Screenshot 2023-12-02 145029.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5e105fb" class="outline-3">
<h3 id="org5e105fb"><span class="section-number-3">7.6.</span> Forwarding</h3>
<div class="outline-text-3" id="text-7-6">
<p>
Forwarding means to to place packet on the route to its destination by host or router. Forwarding is done when we need to do an indirect delivery i.e, a hop of network is required
</p>
<ul class="org-ul">
<li>For correct forwarding, it is required that host/router has a routing table</li>
<li>When host/router gets a packet that is not addressed to itself, it will forward it by looking up the routing table</li>
<li>However, having entry for every single host is impossible considering the size of the modern internet.</li>
</ul>
</div>
<div id="outline-container-orge6efbda" class="outline-4">
<h4 id="orge6efbda"><span class="section-number-4">7.6.1.</span> Forwarding Techniques</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
Several forwarding techinques are used to make size of routing tables mangable and handle security issues as well
</p>
</div>
<div id="outline-container-orgb12bc0d" class="outline-5">
<h5 id="orgb12bc0d"><span class="section-number-5">7.6.1.1.</span> Next-Hop method vs Route Method</h5>
<div class="outline-text-5" id="text-7-6-1-1">
<ul class="org-ul">
<li>When routign tables hold all information of the complete route, it is called route method</li>
<li>When the routing tables will only hold the address of the next hop instead the information of the complete route, it is called the next-hop method</li>
</ul>


<div id="orgac71db9" class="figure">
<p><img src="Network_Layer/2023-12-02_17-14-12_Screenshot 2023-12-02 171406.png" alt="2023-12-02_17-14-12_Screenshot 2023-12-02 171406.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgba38b6f" class="outline-5">
<h5 id="orgba38b6f"><span class="section-number-5">7.6.1.2.</span> Network-specific method vs Host-specific method</h5>
<div class="outline-text-5" id="text-7-6-1-2">
<ul class="org-ul">
<li>When we have an entry for every destination host connected to same physical network, it is called host-specific method</li>
<li>When we have a single entry, that defines the address of the destination network itself, it is called network-specific method</li>
</ul>


<div id="orge5a04bc" class="figure">
<p><img src="Network_Layer/2024-02-03_23-20-43_Screenshot 2024-02-03 232026.png" alt="2024-02-03_23-20-43_Screenshot 2024-02-03 232026.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org2bf81af" class="outline-5">
<h5 id="org2bf81af"><span class="section-number-5">7.6.1.3.</span> Default method</h5>
<div class="outline-text-5" id="text-7-6-1-3">
<p>
In the routing table, we have an entry called the <i>default entry</i>. So the destination does not match with any other entry of the table, we just take the default hop. <i>So instead of listing all networks on the entire Internet, we simply use the default entry</i>
</p>


<div id="org7935958" class="figure">
<p><img src="Network_Layer/2023-12-02_18-24-54_Screenshot 2023-12-02 182449.png" alt="2023-12-02_18-24-54_Screenshot 2023-12-02 182449.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org971f801" class="outline-4">
<h4 id="org971f801"><span class="section-number-4">7.6.2.</span> Forwarding Process</h4>
<div class="outline-text-4" id="text-7-6-2">
<p>
We assume that hosts and routers are using classless addressing, classful addressing can be treated as special case of classless addressing.
</p>

<ul class="org-ul">
<li>The first address in the block will be treated as a special address called the <b>network address.</b>
<ul class="org-ul">
<li>It will not be assigned to any of the device on the network.</li>
<li>It is used by the routers to forward packets</li>
</ul></li>
<li>The routing table needs one row of information for each block involved.</li>
<li>The table needs to be searched based on the network address (first address in the block)</li>
<li>The routing table also includes the mask of the network</li>
<li>The last thing to store is the interface (port) of the router to which the network connects</li>
</ul>

<p>
Example, the configuration
</p>

<div id="orgc0bcb98" class="figure">
<p><img src="Network_Layer/2023-12-02_21-26-20_Untitled-2023-12-02-2019.png" alt="2023-12-02_21-26-20_Untitled-2023-12-02-2019.png" />
</p>
</div>

<p>
router R1 will have the corrosponding routing table
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Mask</th>
<th scope="col" class="org-right">Network Address</th>
<th scope="col" class="org-left">Next Hop</th>
<th scope="col" class="org-left">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">/26</td>
<td class="org-right">180.70.65.192</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">m2</td>
</tr>

<tr>
<td class="org-left">/25</td>
<td class="org-right">180.70.65.128</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">m0</td>
</tr>

<tr>
<td class="org-left">/24</td>
<td class="org-right">201.4.22.0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">m3</td>
</tr>

<tr>
<td class="org-left">/22</td>
<td class="org-right">201.4.16.0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">m1</td>
</tr>

<tr>
<td class="org-left">/30</td>
<td class="org-right">192.168.0.0</td>
<td class="org-left">201.5.16.3</td>
<td class="org-left">m1</td>
</tr>

<tr>
<td class="org-left">default</td>
<td class="org-right">default</td>
<td class="org-left">180.70.65.200</td>
<td class="org-left">m2</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>The first 4 rows have Next Hop empty, since the router does not send packet to another router, it can send them to destination itself</li>
<li>The entry for network \(192.168.0.0/30\) has Next Hop entry \(201.5.16.3\), since it needs to go to router with ip address of \(201.5.16.3\) to hop to network \(192.168.0.0/30\)</li>
<li>The default entry assumes that packet wants to go to internet and sends it to router with IP \(180.70.65.200\) to hop to internet</li>
</ul>
<p>
<b>NOTE :</b> a router is an intersection of different networks. It is considered a part of all the networks it connects
</p>
</div>
<div id="outline-container-org51842f5" class="outline-5">
<h5 id="org51842f5"><span class="section-number-5">7.6.2.1.</span> Address Aggregation</h5>
<div class="outline-text-5" id="text-7-6-2-1">
<p>
When using classless addressing, number of routing table entries can increase considerably.
</p>
<ul class="org-ul">
<li>This is because classless addressing divides address space into manageable blocks</li>
<li>The larger the routing table is, the more time it takes to search the table. This affects performance</li>
</ul>
<p>
To alliviate the problem address aggregation was designed
</p>

<div id="org574ddab" class="figure">
<p><img src="Network_Layer/2023-12-02_22-23-24_Screenshot 2023-12-02 222318.png" alt="2023-12-02_22-23-24_Screenshot 2023-12-02 222318.png" />
</p>
</div>

<p>
In this example
</p>
<ul class="org-ul">
<li>R1 is connected to 4 organizations networks, each have 64 addresses. So it has a large routing table</li>
<li>R2 is somewhere far from R1, it has a small routing table since any packet with destination from \(140.24.7.0\) to \(140.24.7.255\) is sent to same interface m0</li>
<li>Here, R2 is aggregating all the networks into a single block</li>
</ul>
</div>
</div>
<div id="outline-container-orgeeb9ad6" class="outline-5">
<h5 id="orgeeb9ad6"><span class="section-number-5">7.6.2.2.</span> Longest Mask Matching</h5>
<div class="outline-text-5" id="text-7-6-2-2">
<p>
What if organization 4 from the address aggregation example is not connected to the router R1 directly. <i>But we can still aggregate block by using principle of longest mask matching.</i>
</p>
<ul class="org-ul">
<li>This principle states that routing table is always sorted from longest mask to shortest mask</li>
<li>The network address will be matched from top to bottom</li>
</ul>
<p>
This principle allows us to send packets for organization 4 to its own router R4, before it checks for other organizations router
</p>

<div id="org33aabca" class="figure">
<p><img src="Network_Layer/2023-12-02_22-40-58_Screenshot 2023-12-02 224053.png" alt="2023-12-02_22-40-58_Screenshot 2023-12-02 224053.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orge9907d9" class="outline-5">
<h5 id="orge9907d9"><span class="section-number-5">7.6.2.3.</span> Hierarchical Routing</h5>
<div class="outline-text-5" id="text-7-6-2-3">
<p>
To solve problems of large routing tables, we create a hierarchy of routing tables
</p>
<ul class="org-ul">
<li>So the home router will be at the bottom of hierarchy</li>
<li>Above it will be the local ISP routing table</li>
<li>Above it will be state ISP routing table</li>
<li>And so on.</li>
</ul>

<div id="orgf117adb" class="figure">
<p><img src="Network_Layer/2023-12-02_22-46-17_Screenshot 2023-12-02 224613.png" alt="2023-12-02_22-46-17_Screenshot 2023-12-02 224613.png" />
</p>
</div>

<p>
<b><span class="underline">Geographical routing</span></b>
</p>

<p>
To decrease size of routing tables even further, we can extend hierarchical routing to include geographical routing
</p>
<ul class="org-ul">
<li>We assign block to large geographical portions</li>
<li>So there is a block for India, Europe, North America and so on.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9061114" class="outline-4">
<h4 id="org9061114"><span class="section-number-4">7.6.3.</span> Routing Table</h4>
<div class="outline-text-4" id="text-7-6-3">
<p>
The routing table can be either static or dynamic
</p>

<p>
<b><span class="underline">Static Routing table</span></b>
</p>

<p>
A static routing table contains information that is entered manually.
</p>
<ul class="org-ul">
<li>The admin will enter each destination into table manually</li>
<li>It is not updated automatically when there is change in Internet</li>
<li>This can be used for small networks or for troubleshooting</li>
</ul>

<p>
<b><span class="underline">Dynamic Routing table</span></b>
</p>

<p>
The dynamic routing table updates periodically by using a dynamic routing protocol such as RIP, OSPF or BGP. Whenever there is change in network, dynamic protocols update table of routers automatically
</p>
</div>
<div id="outline-container-org4ae17fa" class="outline-5">
<h5 id="org4ae17fa"><span class="section-number-5">7.6.3.1.</span> Format of routing table</h5>
<div class="outline-text-5" id="text-7-6-3-1">
<p>
Routing table need a minimum of 4 columns as we have seen, but some routing tables may have extra fields.
</p>
<ul class="org-ul">
<li>Minimum number of columns is 4</li>
<li>Number of columns is vendor-dependent</li>
</ul>
<p>
Usually, three more columns are added to routing table
</p>
<ol class="org-ol">
<li>Flags : this column will store flags that can be switched on/off. There are up to five flags. The five flags are
<ol class="org-ol">
<li>U (up) : indicates if router is up and running</li>
<li>G (gateway) : means that destination is in another network, so a hop is required (indirect delivery). Lack of this flag means it is direct delivery</li>
<li>H (host-specific) : specifies that entry is host-specific address and not network-specific</li>
<li>D (added by redirection) : indicates that this entry was added by a redirection message from ICMP</li>
<li>M (modified by redirection) : indicates that entry was modified by a redirection message</li>
</ol></li>
<li>Reference count : this field gives number of users of this route at the moment</li>
<li>Use : shows number of packets transmitted through router to this destination</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-orge9f804a" class="outline-3">
<h3 id="orge9f804a"><span class="section-number-3">7.7.</span> Unicast Routing protocols</h3>
<div class="outline-text-3" id="text-7-7">
<p>
One of the ways in which dynamic routing protocols work is by trying to optimize some metric for the hops.
</p>
<ul class="org-ul">
<li>Simple protocols treat each hop as equal; so each hop only adds a single hop count. So RIP will try to reduce the hop count for a route.</li>
<li>Open Shortest Path First (OSPF) allow admin to assign costs for passing through a network. Example, if maximum throughput is desired then satellite link has lower metric than fiber-optic line.
<ul class="org-ul">
<li>OSPF allows router to have multiple tables based on required type of service needed</li>
</ul></li>
<li>Border Gateway Protocol (BGP) uses a policy set by admin to find paths</li>
</ul>
</div>
<div id="outline-container-orgd5cd5c4" class="outline-4">
<h4 id="orgd5cd5c4"><span class="section-number-4">7.7.1.</span> Intra- and Interdomain Routing</h4>
<div class="outline-text-4" id="text-7-7-1">
<p>
Today, internet is too large for one routing protocol to handle. So internet is divided into autonomous systems.
</p>
<ul class="org-ul">
<li>Autonomous System (AS) is a group of networks and routher under a single administration</li>
<li>Routing inside the AS is intradomain routing</li>
<li>Routing across different AS is interdomain routing</li>
<li>An autonomous system can choose one or more intradomain routing protocol at the same time</li>
<li>For interdomain routing only one routng protocol can be used at a time</li>
</ul>

<div id="org8242f69" class="figure">
<p><img src="Network_Layer/2023-12-02_23-43-45_Screenshot 2023-12-02 234332.png" alt="2023-12-02_23-43-45_Screenshot 2023-12-02 234332.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgec8b403" class="outline-4">
<h4 id="orgec8b403"><span class="section-number-4">7.7.2.</span> Distance Vector Routing</h4>
<div class="outline-text-4" id="text-7-7-2">
<p>
In Distance Vector Routing, the least cost route is the route with minimum distance.
</p>
<ul class="org-ul">
<li>As name implies, each node maintains vector (table) of minimum distance to every other node</li>
<li>This protocol also uses next-hop method of routing. So the next node in route is also stored in the table</li>
</ul>

<div id="orgc5987ea" class="figure">
<p><img src="Network_Layer/2023-12-03_00-02-58_Screenshot 2023-12-03 000249.png" alt="2023-12-03_00-02-58_Screenshot 2023-12-03 000249.png" />
</p>
</div>

<p>
<b><span class="underline">Initialization</span></b>
</p>

<ul class="org-ul">
<li>Each node will know how to reach it's neighbour</li>
<li>Nodes that are not in immediate neighbour are initially given cost of infinite (unreachable)</li>
</ul>

<p>
<b><span class="underline">Sharing</span></b>
</p>

<ul class="org-ul">
<li>Neighbours share information with each other</li>
<li>They only send first two columns data (to and cost)</li>
<li>So if node A has marked node C as infinite, but receives a table from it's neighbour B which can reach C, it will update it's the entry with cost of (cost from A to B + cost from B to C) and till change Next field to B</li>
</ul>

<p>
<b><span class="underline">Updating</span></b>
</p>

<p>
Updating is done in three steps. Suppose a node B sent table to node A
</p>
<ol class="org-ol">
<li>If B claims that C is \(y\) away from it, and distance between A and B is \(x\), then total distance is \(x + y\)</li>
<li>The node A will set the distance to C as \(x + y\) and next as B and store this info as new</li>
<li>The node A will now compare new value with old
<ol class="org-ol">
<li>If next entry is now different, the one with smaller cost is selected, else old entry is kept</li>
<li>If next entry is still same, the  newer one is selected regardless of the cost. This is done because path may have changed and old route may not exist anymore</li>
</ol></li>
</ol>
</div>
<div id="outline-container-org40f4625" class="outline-5">
<h5 id="org40f4625"><span class="section-number-5">7.7.2.1.</span> When to share</h5>
<div class="outline-text-5" id="text-7-7-2-1">
<p>
There are two times when table is sent to the neighbours : periodically and when change occurs
</p>
<ol class="org-ol">
<li>Periodic update : A node sends its routing tables, normally every 30s in a periodic update</li>
<li>Triggered update : a node sends its routing tables when there is a change in its routing table. This can happen in two cases
<ol class="org-ol">
<li>a node receives table from neighbour and changes its own table when updating</li>
<li>a node detects change in its neighbouring links</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org5277bea" class="outline-5">
<h5 id="org5277bea"><span class="section-number-5">7.7.2.2.</span> Instability</h5>
<div class="outline-text-5" id="text-7-7-2-2">
<p>
The distance vector routing is unstable. There are times when the data in the tables is wrong.
</p>

<p>
<b><span class="underline">Two-node loop instability</span></b>
</p>

<p>
Suppose we have the following configuraton
</p>

<div id="org52cb3aa" class="figure">
<p><img src="Network_Layer/2023-12-03_01-25-34_Screenshot 2023-12-03 012527.png" alt="2023-12-03_01-25-34_Screenshot 2023-12-03 012527.png" />
</p>
</div>

<p>
Now suppose there is a failure between the link of X and A. The table in A is immediately updated to show that X is unreachable
</p>

<div id="orgf65b981" class="figure">
<p><img src="Network_Layer/2023-12-03_01-26-45_Screenshot 2023-12-03 012638.png" alt="2023-12-03_01-26-45_Screenshot 2023-12-03 012638.png" />
</p>
</div>

<p>
But before this new table is sent to B by A, the node B sends its table first. Now after reading table received from B, A will wrongly believe that a new path was found to X and will update its table
</p>

<div id="org7093276" class="figure">
<p><img src="Network_Layer/2023-12-03_01-28-26_Screenshot 2023-12-03 012821.png" alt="2023-12-03_01-28-26_Screenshot 2023-12-03 012821.png" />
</p>
</div>

<p>
Now B receives table from A and sees that there is some change in route, so it will update its own cost table
</p>

<div id="org6c030f9" class="figure">
<p><img src="Network_Layer/2023-12-03_01-33-03_Screenshot 2023-12-03 013258.png" alt="2023-12-03_01-33-03_Screenshot 2023-12-03 013258.png" />
</p>
</div>

<p>
This exchange will happen repeatedly till routing tables in A and B both become infinity and the routing tables are once again fixed.
</p>

<div id="org49ad2f0" class="figure">
<p><img src="Network_Layer/2023-12-03_01-34-02_Screenshot 2023-12-03 013358.png" alt="2023-12-03_01-34-02_Screenshot 2023-12-03 013358.png" />
</p>
</div>

<p>
But between the time that they are couting to infitiy, the routing tables of both A an B are wrong i.e, they are instable. This is called the count to infinity problem.
</p>

<p>
<b><span class="underline">Solution to problem</span></b>
</p>

<ol class="org-ol">
<li>Defining infinity to be a small number means that this problem is fixed quickly. Therefore, most implementation set inifnity to 16</li>
<li><b>Split Horizon</b> : suppose A is giving table to B. Instead of giving all of it's entries to B, node A will leave the entries who have B in their Next column. This will make system stable after first update, both A and B will know that X is not reachable</li>
<li><b>Split Horizon and Poison Reverse</b> : normally distance vector protocol uses timer to know if node is no longer functioning.
<ul class="org-ul">
<li>When timer runs out and it gets no table from a node, it removes the entry for it.</li>
<li>But this creates a problem, if some node's entry is absent from received table it is not possible to know whether that node is non-functioning or was removed by split horizon.</li>
<li>So rather than just omitting the entry via split horizon, we replace cost value with special number which tells that "Do not use this value". This is called Poison Reverse</li>
</ul></li>
</ol>

<p>
<b><span class="underline">Three-node Instability</span></b>
</p>

<p>
While split horizon and poison reverse works for two-node instability, it won't work for three-node instability. So for the configuration
</p>

<div id="orgb063018" class="figure">
<p><img src="Network_Layer/2023-12-03_01-49-01_Screenshot 2023-12-03 014853.png" alt="2023-12-03_01-49-01_Screenshot 2023-12-03 014853.png" />
</p>
</div>

<p>
Here, if X has a failure, there is a change that C will cause problem by exchaning table with B first and B thinking a path exists through C. Which is then told to A, who thinks path exists through B. It will still count to infinity in this case as well, so table will eventually become stable.
</p>
</div>
</div>
<div id="outline-container-org9aa57bf" class="outline-5">
<h5 id="org9aa57bf"><span class="section-number-5">7.7.2.3.</span> RIP</h5>
<div class="outline-text-5" id="text-7-7-2-3">
<p>
The routing information protocol (RIP) is used in autonomous systems. It is a very simple protocol based on distance vector routing
</p>
<ol class="org-ol">
<li>The destination is another network, so To column is a network address</li>
<li>The metric used by RIP is the number of networks (hops) to reach the destination. For this reason, metric in RIP is called hop count, i.e, Cost is Hop count</li>
<li>Infinity is defined as 16, so RIP cannot have more than 15 hops</li>
<li>The next-node column is the address of another router to which packet is sent in route</li>
</ol>

<div id="org041f83c" class="figure">
<p><img src="Network_Layer/2023-12-03_01-51-25_Screenshot 2023-12-03 015120.png" alt="2023-12-03_01-51-25_Screenshot 2023-12-03 015120.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbc71ea9" class="outline-4">
<h4 id="orgbc71ea9"><span class="section-number-4">7.7.3.</span> Link State Routing</h4>
<div class="outline-text-4" id="text-7-7-3">
<p>
Each node knows the complete topology of the entire list of nodes and links. Then it simply uses Dijkstra's algorithm to build the routing table. This topology info is dynamic, representing latest state of each node and each link. If there are changes, the topology must be updated.
</p>
<ul class="org-ul">
<li>Initially no node knows the complete topology</li>
<li>But it will have knowledge about it's links to it's neighbour nodes. This is called Link State Knowledge</li>
<li>So first step in this type of routing is building a complete topology using these Link State Knowledge</li>
</ul>
</div>
<div id="outline-container-orga5b36eb" class="outline-5">
<h5 id="orga5b36eb"><span class="section-number-5">7.7.3.1.</span> Link State Packet (LSP)</h5>
<div class="outline-text-5" id="text-7-7-3-1">
<p>
Each LSP will carry the following information
</p>
<ol class="org-ol">
<li>node identity : the identity of node that created the LSP</li>
<li>list of links : info it has about it's links and their costs</li>
<li>age : prevents old LSPs from remaining in domain for too long</li>
<li>sequence number : this is used to control flooding. Flooding is the process through which all the nodes get the LSPs of each other
<ol class="org-ol">
<li>The node creating the LSP sends a copy out to each interface</li>
<li>A node receives an LSP compares it with copy it may already have. If new LSP is older that it has, it discards it. If it is new it will:
<ol class="org-ol">
<li>Replace the old LSP with the new one</li>
<li>Send a copy of the new LSP to each interface, except the one from which younger one arrived</li>
</ol></li>
</ol></li>
</ol>

<p>
New LSPs are generated on two occasions
</p>
<ul class="org-ul">
<li>When there is change in topology of domain</li>
<li>On a periodic basis : all LSPs expire are a set amount of time, therefore they are produced periodically</li>
</ul>
</div>
</div>
<div id="outline-container-orgf5d79fa" class="outline-5">
<h5 id="orgf5d79fa"><span class="section-number-5">7.7.3.2.</span> Formation of shortest path tree</h5>
<div class="outline-text-5" id="text-7-7-3-2">
<p>
In this step, each node uses Dijkstra's algorithm to get it's own since source shortest path table
</p>
</div>
</div>
<div id="outline-container-orgf7b55f8" class="outline-5">
<h5 id="orgf7b55f8"><span class="section-number-5">7.7.3.3.</span> OSPF</h5>
<div class="outline-text-5" id="text-7-7-3-3">
<p>
The Open Shortest Path First protocol is an intradomain routing protocol based on link state routing.
</p>
<ul class="org-ul">
<li>Rather than flooding the whole Autonomous System, OSPF will divide the AS into smaller areas</li>
<li>The flooding happens within these smaller areas</li>
<li>Special Area Border routers then collect the summary of the results of the areas and send it to other areas.</li>
</ul>

<div id="orgaf7ecef" class="figure">
<p><img src="Network_Layer/2023-12-03_02-45-58_Screenshot 2023-12-03 024552.png" alt="2023-12-03_02-45-58_Screenshot 2023-12-03 024552.png" />
</p>
</div>

<p>
<b><span class="underline">Metric</span></b>
</p>

<p>
The OSPF protcol allows admin to assign cost called metric, to each route. The metric can be based on type of service (minimum delay, maximum througput, and so on). Routers can have multiple tables, each based on different metric
</p>

<p>
<b><span class="underline">Types of packets</span></b>
</p>

<p>
There are five different types of packets in OSPF:
</p>
<ol class="org-ol">
<li>Hello packet : used to check reachability of neighbour's</li>
<li>Database description : after sending hello packet to a router, it returns the database information about the topology</li>
<li>Link state request (LSR) : sent by area router to obtain information about a specific route</li>
<li>Link state update (LSU) : used by area routers to advertise the state of its links.</li>
<li>Link state acknowledgement (LSA) : makes routing more reliable by forcing each router to send ACK on each link state update.</li>
</ol>

<p>
<b><span class="underline">Types of Links</span></b>
</p>

<p>
In OSPF a connection is called a link. Four types of links have been deined
</p>
<ol class="org-ol">
<li><p>
Point-to-point : connects two routers without any other host or router in between.
</p>


<div id="org1e7af51" class="figure">
<p><img src="Network_Layer/2023-12-03_03-00-17_Screenshot 2023-12-03 030012.png" alt="2023-12-03_03-00-17_Screenshot 2023-12-03 030012.png" />
</p>
</div></li>

<li><p>
Transient link : a network with several routers attached to it. The data can enter through any of the routers and leave through any of the routers. Transient link can be of two types : unrealistic topology is when all routers are connected to each other, realistic topology is when there is a central designated router. In cases with unrealistic topology, OSPF elects a central designated router
</p>

<div id="org22b2eb3" class="figure">
<p><img src="Network_Layer/2023-12-03_03-02-17_Screenshot 2023-12-03 030210.png" alt="2023-12-03_03-02-17_Screenshot 2023-12-03 030210.png" />
</p>
</div></li>

<li><p>
Stub link : a network that is connected to only one router. The data packets enter through this single router and leave network through the single router. This is a special case of transient network. Here we can add a new designated router
</p>

<div id="org33c9df3" class="figure">
<p><img src="Network_Layer/2023-12-03_03-06-24_Screenshot 2023-12-03 030621.png" alt="2023-12-03_03-06-24_Screenshot 2023-12-03 030621.png" />
</p>
</div></li>

<li>Virtual link : this is created by admin when a link between two routers is broken. This is created using some other longer path that goes through several routers</li>
</ol>

<p>
<b><span class="underline">Graphical representation</span></b>
</p>

<p>
We represent the AS as a graph in OSPF, on which we apply the Dijkstra's algorithm to get shortest path
</p>

<div id="org157d088" class="figure">
<p><img src="Network_Layer/2023-12-03_03-17-46_Screenshot 2023-12-03 031645.png" alt="2023-12-03_03-17-46_Screenshot 2023-12-03 031645.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga72bfbc" class="outline-4">
<h4 id="orga72bfbc"><span class="section-number-4">7.7.4.</span> Path Vector Routing</h4>
<div class="outline-text-4" id="text-7-7-4">
<p>
Both Distance vector routing (RIP) and Link State Routing (OSPF) are not suitable when domain is large.
</p>
<ul class="org-ul">
<li>Distance Vector Routing is subject to instability</li>
<li>Link State Routing takes too many resources and creates heavy traffic because of flooding</li>
</ul>

<p>
Path vector routing is similar to distance vector router.
</p>
<ul class="org-ul">
<li>The autonomous systems will have a special node called speaker node which represents the whole autonomous system</li>
<li>This speaker node will create  communicate with speaker nodes of other AS and exchange info with them</li>
<li>Unlike in distance vector routing, cost is not shared. Only the path is shared</li>
</ul>
<p>
<b>NOTE :</b> path vector routing does not use next-hop method. It instead uses route-method for its routing tables
</p>

<p>
<b><span class="underline">Initialization</span></b>
</p>

<p>
Initially, each speaker node only knows about reachability of nodes inside it's autonomous system.
</p>

<div id="org7c87134" class="figure">
<p><img src="Network_Layer/2023-12-03_12-13-17_Screenshot 2023-12-03 121311.png" alt="2023-12-03_12-13-17_Screenshot 2023-12-03 121311.png" />
</p>
</div>

<p>
<b><span class="underline">Sharing</span></b>
</p>

<p>
Just as in distance vector routing, in path vector routing, speaker will share info with its neighbour AS speakers
</p>

<p>
<b><span class="underline">Updating</span></b>
</p>

<p>
When speaker receives two-column table from a neighbour, it updates its own table by adding nodes that are not in its own routing table. After a while of this, each AS will know how to reach another AS to get to any node
</p>

<p>
For the above network, the stabilized table will be
</p>

<div id="orgf20b17e" class="figure">
<p><img src="Network_Layer/2023-12-03_12-26-26_Screenshot 2023-12-03 122621.png" alt="2023-12-03_12-26-26_Screenshot 2023-12-03 122621.png" />
</p>
</div>

<p>
<b><span class="underline">Loop Prevention</span></b>
</p>

<p>
Unlike distance vector router, since the routing tables store the complete path, there will never be loops in this system.
</p>

<p>
<b><span class="underline">Policy routing</span></b>
</p>

<p>
Policy routing can be done in path vector routing. These policies can be set by the admin. When a speaker receives the table from it's neighbour, it can check the path to see if it complies with the policy. If it does not comply with the policy, then that path is ignored.
</p>

<p>
<b><span class="underline">Optimum path</span></b>
</p>

<p>
We cannot define metrics like we do in Link State Routing. This is because each of the AS will be using a different protocol. But we can choose path with criteria such as, shortest path length, reliability, security, etc.
</p>
</div>
<div id="outline-container-orgf0b87fe" class="outline-5">
<h5 id="orgf0b87fe"><span class="section-number-5">7.7.4.1.</span> Border Gateway Protocol (BGP)</h5>
<div class="outline-text-5" id="text-7-7-4-1">
<p>
<b><span class="underline">Types of autonomous systems</span></b>
</p>

<p>
Autonomous systems is of three types
</p>
<ol class="org-ol">
<li>Stub AS : it has only a single connection to another AS.
<ul class="org-ul">
<li>Hosts in stub AS receive data from hosts in other ASs</li>
<li>Data traffic, cannot pass through stub AS, it is either source or sink</li>
<li>Example, at home and small buildings</li>
</ul></li>
<li>Multihomed AS : it has more than one connction to other ASs, but is still either only a source of a sink for traffic.
<ul class="org-ul">
<li>There is no transient traffic, i.e, traffic passing through it to other ASs</li>
<li>Example, a large corporation with data coming from multiple sources</li>
</ul></li>
<li>Transit AS : it is a multihomed AS  which allows transient traffic through it
<ul class="org-ul">
<li>Example, national and international ISPs</li>
</ul></li>
</ol>

<p>
<b><span class="underline">BGP Sessions</span></b>
</p>

<p>
Exchange of routing information takes place in sessions. A session is connetion between two BGP routers only for exchanging routing info.
</p>
<ul class="org-ul">
<li>BGP uses TCP for sessions, therefore session is an application level program</li>
<li>Unlike normal TCP sessions, sessions for BGP can last for a long time. So BGP sessions are sometimes called semi-permanent connetions</li>
<li>The sessions used to exchange info between two speaker nodes are called External BGP sessions (E-BGP)</li>
<li>The sessions used to exchange info between routers inside the Autonomous Systems are called Internal BGP sessions (I-BGP)</li>
</ul>

<p>
<img src="Network_Layer/2023-12-03_13-10-35_Screenshot 2023-12-03 131031.png" alt="2023-12-03_13-10-35_Screenshot 2023-12-03 131031.png" />
<hr />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org51afdec" class="outline-2">
<h2 id="org51afdec"><span class="section-number-2">8.</span> Transport Layer</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>Transport layer has three protocols : UDP, TCP and SCTP</li>
<li>The transport layer does process-to-process delivery
<ul class="org-ul">
<li>UDP is simplest of the three</li>
<li>TCP is a complex transport layer protocol but more relibale than UDP</li>
<li>SCTP is protocol for multihomed, multistream applications such as multimedia</li>
</ul></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer</th>
<th scope="col" class="org-left">Delivery</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Data Link Layer</td>
<td class="org-left">Node-to-Node delivery</td>
</tr>

<tr>
<td class="org-left">Network Layer</td>
<td class="org-left">Host-to-Host delivery</td>
</tr>

<tr>
<td class="org-left">Transport Layer</td>
<td class="org-left">Process-to-Process delivery</td>
</tr>
</tbody>
</table>


<div id="orgf1d3827" class="figure">
<p><img src="Transport_Layer/2024-10-15_23-42-47_Screenshot 2024-10-15 234219.png" alt="2024-10-15_23-42-47_Screenshot 2024-10-15 234219.png" />
</p>
</div>

<p>
Both source and destination host will have multiple processes running on them, so need mechanism to deliver to correct processes
</p>
</div>

<div id="outline-container-org2cd0deb" class="outline-3">
<h3 id="org2cd0deb"><span class="section-number-3">8.1.</span> Client/Server Paradigm</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Most common way to achieve process-to-process communication is throught client/server paradigm.
</p>

<ul class="org-ul">
<li>We give same name to both server and client.
<ul class="org-ul">
<li>Eg, when fetching daytime info, we need Daytime client process and Daytime server process</li>
</ul></li>
<li>OS today are both multiprocessing and multiuser.
<ul class="org-ul">
<li>So host may also be running multiple server programs and/or multiple client programs</li>
</ul></li>
</ul>

<p>
For process-to-process delivery we have following terms
</p>
<ol class="org-ol">
<li>Local host</li>
<li>Local process</li>
<li>Remote host</li>
<li>Remote process</li>
</ol>
</div>

<div id="outline-container-orgc9dec6c" class="outline-4">
<h4 id="orgc9dec6c"><span class="section-number-4">8.1.1.</span> Addressing</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Data Link Layer uses MAC address for delivery. Network layer uses IP address for delivery. Similarly, at transport layer we need a way to identify the correct process
</p>

<ul class="org-ul">
<li>at transport layer, we use <b>port number for addressing</b>.</li>
<li>the port number is <b>unsigned 16-bit</b> number</li>
<li>transport layer at client chooses a random port number, this is called the <b>ephemeral port number</b>
<ul class="org-ul">
<li>they are ephemeral because they are short-lived; only assigned for single session</li>
<li>range of ephemeral port depends on OS, but IANA defines range 49,152 to 65,535</li>
<li>also called dynamic ports, private ports or client ports</li>
</ul></li>
<li>server port cannot be chosen randomly, server will use a defined <b>well-known port number</b>
<ul class="org-ul">
<li>if port at server is random, then client won't know the port number to use (we could send a custom packet to get port number of required service, but that is unnecessary overhead)</li>
<li>some example of well known ports are, port 80 for HTTP, port 53 for DNS, port 13 for daytime, etc.</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org0a2de9e" class="outline-5">
<h5 id="org0a2de9e"><span class="section-number-5">8.1.1.1.</span> IANA Ranges</h5>
<div class="outline-text-5" id="text-8-1-1-1">
<p>
The Internet Assigned Number Authority has divided ports to three ranges
</p>
<ul class="org-ul">
<li>Well-known ports : range 0 to 1023 are assigned and controlled by IANA</li>
<li>Registered ports : ranges 1024 to 49,151 are not assigned or controlled by IANA. They can be registered with IANA by other entities/organizations upon application</li>
<li>Dynamic ports : ranges 49,152 to 65,535; can be used by any process, ephemeral ports are chosen from this range</li>
</ul>
</div>
</div>

<div id="outline-container-orgcdc4206" class="outline-5">
<h5 id="orgcdc4206"><span class="section-number-5">8.1.1.2.</span> Socket Addresses</h5>
<div class="outline-text-5" id="text-8-1-1-2">
<p>
Process-to-process delivery needs two addresses, IP address and port number. The <i>combination of IP address and port number</i> is called socket address.
</p>

<p>
Client socket address defines client process uniquely and server socket address defines server process uniquely
</p>

<p>
So transport layer protocols work using socket addresses. The four pieces of information (2 IP addr and 2 port no) are part of the IP header and transport layer protocol header
</p>

<ul class="org-ul">
<li>IP header contains IP address</li>
<li>TCP or UDP header contains port numbers</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdcfc513" class="outline-4">
<h4 id="orgdcfc513"><span class="section-number-4">8.1.2.</span> Multiplexing and Demultiplexing</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
We can do multiplexing and demultiplexing at the transport layer
</p>


<div id="org786813b" class="figure">
<p><img src="Transport_Layer/2024-10-16_01-39-08_Screenshot 2024-10-16 013854.png" alt="2024-10-16_01-39-08_Screenshot 2024-10-16 013854.png" />
</p>
</div>

<p>
<span class="underline"><b>Multiplexing</b></span>
</p>

<p>
There may be multiple processes that need to send packets. However, there is only single transport layer protocol at a time between client and server.
</p>

<ul class="org-ul">
<li>This is many-to-one relationship</li>
<li>Protocol accepts messages from different processes, differentiated by port numbers</li>
<li>After adding header, transport layer passes packets to network layer</li>
</ul>

<p>
<span class="underline"><b>Demultiplexing</b></span>
</p>

<ul class="org-ul">
<li>The relationship is one-to-many</li>
<li>Transport layer recieves a datagram from network layer</li>
<li>After error checking and stripping header, it delivers each message to appropriate process based on port number</li>
</ul>
</div>
</div>

<div id="outline-container-org1f0a694" class="outline-4">
<h4 id="org1f0a694"><span class="section-number-4">8.1.3.</span> Connectionless vs Connection-Oriented service</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
Transport layer protocol can either be connecionless or connection-oriented
</p>

<p>
<span class="underline"><b>Connectionless Service</b></span>
</p>

<ul class="org-ul">
<li>no need for connection establishment or release</li>
<li>packets not numbered; they may be delayed or arrive out of sequence</li>
<li>no acknowledgment; example of protocol UDP</li>
</ul>

<p>
<span class="underline"><b>Connection-Oriented Service</b></span>
</p>

<ul class="org-ul">
<li>connection needs to be established between sender and receiver; it also needs to be released after data is transferred</li>
<li>packets are numbered and in order</li>
<li>acknowledgments are given for each packet; example of protcol is TCP and SCTP</li>
</ul>
</div>
</div>

<div id="outline-container-org186c10d" class="outline-4">
<h4 id="org186c10d"><span class="section-number-4">8.1.4.</span> Reliable vs Unreliable</h4>
<div class="outline-text-4" id="text-8-1-4">
<p>
The service can be reliable or unreliable. If application layer program needs reliability we will need to use reliable protocol at the transport layer.
</p>

<ul class="org-ul">
<li>Reliable protocol will make sure all packets are delivered process-to-process without loss
<ul class="org-ul">
<li>This is slower and complex service</li>
<li>Will have both flow and error control</li>
<li>A reliable protocol is connection-oriented to communicate if packets are delivered correctly</li>
</ul></li>
<li>Unreliable protcol will try to deliver packets as quickly as possible, but there is no guarentee of correct delivery
<ul class="org-ul">
<li>The protocol will be kept simple and fast</li>
<li>Does not have flow or error control</li>
<li>This is connectionless so that packets can be delivered quick</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org40b08e6" class="outline-5">
<h5 id="org40b08e6"><span class="section-number-5">8.1.4.1.</span> Why have reliability on transport layer?</h5>
<div class="outline-text-5" id="text-8-1-4-1">
<p>
If data link layer is reliable, why do we need reliability on transport layer?
</p>

<p>
This is because data link layer is reliable only for node-to-node delivery.
</p>

<p>
If link is bad between the path of the two hosts, network layer will just drop the packets (<i>best effort delivery</i>). Therefore, reliability needs to be implemented on the transport layer.
</p>
</div>
</div>
</div>

<div id="outline-container-org6cd7d14" class="outline-4">
<h4 id="org6cd7d14"><span class="section-number-4">8.1.5.</span> Three Protocols</h4>
<div class="outline-text-4" id="text-8-1-5">
<p>
TCP/IP protocol suite specifies two protocols TCP and UDP.
</p>

<ul class="org-ul">
<li>UDP is simpler connectionless, unreliable and fast protocol</li>
<li>TCP is connection-oriented, reliable and slow protocol</li>
</ul>

<p>
A new protocol SCTP was later added to the suite
</p>
</div>
</div>
</div>

<div id="outline-container-orgd476ee4" class="outline-3">
<h3 id="orgd476ee4"><span class="section-number-3">8.2.</span> User Datagram Protocol (UDP)</h3>
<div class="outline-text-3" id="text-8-2">
<p>
This protocol is connectionless, unreliable and fast. The goal is to add as little on top of IP expect provide process-to-process communication. It performs very limited error checking
</p>

<p>
Very simple protocol with minimum overhead. If process wants to send small message without care for reliability, it can use UDP
</p>

<p>
Sending packets with UDP requires way less interaction than TCP or SCTP
</p>
</div>

<div id="outline-container-orgde3e7c5" class="outline-4">
<h4 id="orgde3e7c5"><span class="section-number-4">8.2.1.</span> Well-known ports of UDP</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
Some well-known ports that support UDP are given. Some of these ports can be used by both UDP and TCP.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Port</th>
<th scope="col" class="org-left">Protocol</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">7</td>
<td class="org-left">ECHO</td>
<td class="org-left">Echoes a received datagram back to sender</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">Discard</td>
<td class="org-left">Discards datagram that is received</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">Users</td>
<td class="org-left">Active Users</td>
</tr>

<tr>
<td class="org-right">13</td>
<td class="org-left">Daytime</td>
<td class="org-left">Returns date and time</td>
</tr>

<tr>
<td class="org-right">17</td>
<td class="org-left">Quote</td>
<td class="org-left">Returns a quote of the day</td>
</tr>

<tr>
<td class="org-right">53</td>
<td class="org-left">Nameserver</td>
<td class="org-left">Domain Name Service</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgfd030e2" class="outline-4">
<h4 id="orgfd030e2"><span class="section-number-4">8.2.2.</span> User Datagram</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
UDP packets are called datagrams. They have fixed-size <b>header of 8 bytes (64bits)</b>
</p>

<p>
The UDP header has only 4 fields each of 16bit
</p>
<ol class="org-ol">
<li><b>Source port number</b> : port number used by the source process. It is 16 bits long.
<ul class="org-ul">
<li>if source is client it is a ephemeral port</li>
<li>if source is server it is a well-known port</li>
</ul></li>
<li><b>Destination port number</b> : port number of the destination. It is 16 bits long.
<ul class="org-ul">
<li>if destination is server it is well-known port</li>
<li>if destination is client it is an ephemeral port (server needs to remember port no. from the request)</li>
</ul></li>
<li><p>
<b>Length</b> : it is length of datagram in bytes. it is 16bits long
</p>
<ul class="org-ul">
<li>is size of header plus data</li>
<li>although 16 bit means maximum of 65,535 bytes; an actual UDP datagram stores less as IP datagram also has maximum length of 65,535 bytes</li>
<li>so maximum data length is 65,507 bytes in IPv4</li>
</ul>

<p>
This field is not necessary; since IP datagram also defines total length of datagram and well as of IP header. We can subtract the two to get UDP length
</p>

<blockquote>
<p>
UDP length = IP length - IP header's length
</p>
</blockquote>

<p>
However, we include the length in UDP header since IP software will drop the header before handing it to transport layer. Forcing network layer to calculate UDP length to pass it means coupling responsibilities (and we want to seperate responsibilities)
</p></li>
<li><b>Checksum</b> : this field is used for error detection over entire datagram (header plus data). It is 16bits long. The method to calculate checksum is different than for IP aand ICMP</li>
</ol>
</div>
</div>

<div id="outline-container-org8c2223b" class="outline-4">
<h4 id="org8c2223b"><span class="section-number-4">8.2.3.</span> Checksum</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
The checksum includes three sections for UDP : pseudoheader, UDP header and data from application layer
</p>


<div id="orgdf9dd5c" class="figure">
<p><img src="Transport_Layer/2024-10-16_12-54-23_Screenshot 2024-10-16 125414.png" alt="2024-10-16_12-54-23_Screenshot 2024-10-16 125414.png" />
</p>
</div>

<p>
The pseudoheader is made up of some fields of the IP header.
</p>

<p>
<span class="underline"><b>Need of pseudoheader</b></span>
</p>

<p>
If it is not included, then the user datagram may arrive safe and sound. However, IP header is corrupted, it may be delivered to wrong host.
</p>

<p>
The protocol needs to be included so that application knows packet is UDP <i>(set protocol to 17)</i> since same port can receive TCP and UDP packets
</p>

<p>
<span class="underline"><b>Checksum is optional</b></span>
</p>

<p>
In UDP, the inclusion of checksum in datagram is optional. <i>If no checksum is calculated, the value is all 1s in field.</i>
</p>

<p>
After adding pseudoheader, the calculation of checksum is same
</p>


<div id="org81c6f4e" class="figure">
<p><img src="Transport_Layer/2024-10-16_13-15-00_Screenshot 2024-10-16 131451.png" alt="2024-10-16_13-15-00_Screenshot 2024-10-16 131451.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5b86335" class="outline-4">
<h4 id="org5b86335"><span class="section-number-4">8.2.4.</span> UDP Operation</h4>
<div class="outline-text-4" id="text-8-2-4">
<p>
Some concepts  relating to operation of UDP are
</p>

<p>
<span class="underline"><b>Connecionless Service</b></span>
</p>

<p>
UDP is a connectionless service. Each datagram is independent. There is no relationship between them. Even if the source and destination is same.
</p>

<p>
They are also not numbered in any way. No connection establishment or termination, so packets can take any path.
</p>

<p>
So process <i>cannot give stream of data to UDP and expect it to chop them</i>. Every UDP request must be small enough to fit in a single packet
</p>

<p>
<span class="underline"><b>Flow and Error Control</b></span>
</p>

<p>
There is no flow control and receiver may overflow. There is no error control except for detection using a checksum.
</p>

<p>
Both receiver and sender won't know if message was lost or duplicated. If receiver detects error, it will silently discard the datagram
</p>

<p>
<span class="underline"><b>Encapsulation and Decapsulation</b></span>
</p>

<p>
UDP protocol encapsulates and decapsulates message in IP datagram
</p>

<p>
<span class="underline"><b>Queuing</b></span>
</p>

<p>
In UDP, queues are associated with ports. Some implementations create both incoming and outgoing queue; but some only implement an incoming queue
</p>

<p>
If process wants to communicate to multiple other processes, then the outgoing queue is necessary.
</p>


<div id="org152df1e" class="figure">
<p><img src="Transport_Layer/2024-10-16_13-35-02_Screenshot 2024-10-16 133454.png" alt="2024-10-16_13-35-02_Screenshot 2024-10-16 133454.png" />
</p>
</div>

<ul class="org-ul">
<li>At client side, when process starts, it requests a port number and initializes the queues
<ul class="org-ul">
<li>client can send messages to outgoing queues by using well-known source ports</li>
<li>UDP takes messages from queue one-by-one attaches header to them and hands them to network layer for delivery</li>
<li>this queue can overflow, if an overflow happens the OS will ask client to wait before sending more messages</li>
<li>When a message arrives, UDP checks if incoming queue is initialized, if it is then message is placed there</li>
<li>if not incoming queue is initialized then UDP discards the datagram and uses ICMP to send a <i>port unreachable</i> to where packet came from</li>
<li>this incoming queue can overflow, if this happens UDP drops the datagram and asks for <i>port unreachable</i> to be sent</li>
</ul></li>
<li>At server side, mechanism for creating queues is different
<ul class="org-ul">
<li>server places its incoming and outgoing queues on a well-known port</li>
<li>both queues remain open as long as server is running</li>
<li>when packet arrives, UDP checks if there is queue on the destination port</li>
<li>if there is no such queue, UDP discards datagram and ICMP sends <i>port unreachable</i></li>
<li>if incoming queue overflows, datagram discarded and send port unreachable</li>
<li>server responds to client by placing messages on outgoing queue</li>
<li>if outgoing queue overflows, OS will ask server to wait</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orga449c55" class="outline-4">
<h4 id="orga449c55"><span class="section-number-4">8.2.5.</span> Use of UDP</h4>
<div class="outline-text-4" id="text-8-2-5">
<ul class="org-ul">
<li>suitable for simple request-response communication</li>
<li>suitable for processes with internal flow and error control, example TFTP (Trivial File Transfer Protocol) includes flow and error control, so it can use UDP</li>
<li>multicasting capability is embedded in UDP software but not in TCP</li>
<li>can be used for Routing Information Protocol (RIP)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org708bc96" class="outline-3">
<h3 id="org708bc96"><span class="section-number-3">8.3.</span> Transmission Control Protocol (TCP)</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Connection-oriented protocol; it creates virtual connection to send data. Has flow and error control mechanisms at transport level
</p>
</div>

<div id="outline-container-org2841c40" class="outline-4">
<h4 id="org2841c40"><span class="section-number-4">8.3.1.</span> Well-known ports of TCP</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
Some well-known ports used by TCP are
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Port</th>
<th scope="col" class="org-left">Protocol</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">7</td>
<td class="org-left">Echo</td>
<td class="org-left">Echoes a datagram</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">Discard</td>
<td class="org-left">Discards datagram</td>
</tr>

<tr>
<td class="org-right">13</td>
<td class="org-left">Daytime</td>
<td class="org-left">Returns date and time</td>
</tr>

<tr>
<td class="org-right">25</td>
<td class="org-left">SMTP</td>
<td class="org-left">Simple Mail Transfer Protocol</td>
</tr>

<tr>
<td class="org-right">53</td>
<td class="org-left">DNS</td>
<td class="org-left">Domain Name Server</td>
</tr>

<tr>
<td class="org-right">67</td>
<td class="org-left">BOOTP</td>
<td class="org-left">Bootstrap Protocol</td>
</tr>

<tr>
<td class="org-right">80</td>
<td class="org-left">HTTP</td>
<td class="org-left">Hypertext Transfer Protocol</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8b9659d" class="outline-4">
<h4 id="org8b9659d"><span class="section-number-4">8.3.2.</span> Stream Delivery Service</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
Unlike UDP which cannot handle stream of data. TCP is stream-oriented protocol.
</p>

<p>
TCP creates an environment where it seems that two processes are connected by an imaginary "tube" that carries data.
</p>


<div id="orgaee7ab5" class="figure">
<p><img src="Transport_Layer/2024-10-16_16-41-12_Screenshot 2024-10-16 164059.png" alt="2024-10-16_16-41-12_Screenshot 2024-10-16 164059.png" />
</p>
</div>

<p>
<span class="underline"><b>Sending and Receiving Buffers</b></span>
</p>

<p>
Because, sending and receiving processes may not write or read data at same speed; TCP uses buffers for storage.
</p>

<p>
There are two buffers : sending buffers and receiving buffers, one for each direction. These buffers are necessary for flow and error control
</p>


<div id="org6f0b64f" class="figure">
<p><img src="Transport_Layer/2024-10-16_16-49-20_Screenshot 2024-10-16 164910.png" alt="2024-10-16_16-49-20_Screenshot 2024-10-16 164910.png" />
</p>
</div>

<p>
These buffers can be implemented using circular arrays as shown. These buffers are usually hundreds or thousands of bytes, depending on implementation.
</p>

<p>
It is not necessary for both buffers to be of same size.
</p>

<p>
The sender buffer has three sections :
</p>
<ul class="org-ul">
<li>white section is empty and can be filled by process</li>
<li>blue secion holds bytes that have been sent but not acknowledged
<ul class="org-ul">
<li>after bytes in this section are acknowledged, we can free them to be used by process again in the white section</li>
</ul></li>
<li>the pink section has bytes that are not yet sent</li>
</ul>

<p>
The reciever buffer is simpler:
</p>
<ul class="org-ul">
<li>white area contains empty chambers to be filled by bytes recieved</li>
<li>pink section section contains bytes that can be read by the process
<ul class="org-ul">
<li>after the byte is read, it is recycled and added back to white section</li>
</ul></li>
</ul>

<p>
<span class="underline"><b>Segments</b></span>
</p>

<p>
The IP layer cannot send data as stream of bytes. Therefore, TCP groups number of bytes together into a packet called segment.
</p>

<p>
TCP adds a header to each segment and delivers it to IP layer for transmission. These segments may be received  out of order, lost or corrupted; but by using the headers they can be resent.
</p>

<p>
TCP will recombine the segments before passing them to application. The process is unaware of the segments and recieves stream of data.
</p>

<p>
These segments are not necessarily the same size.
</p>


<div id="orgaab0804" class="figure">
<p><img src="Transport_Layer/2024-10-16_17-25-33_Screenshot 2024-10-16 172507.png" alt="2024-10-16_17-25-33_Screenshot 2024-10-16 172507.png" />
</p>
</div>

<p>
<span class="underline"><b>Full-Duplex Communication</b></span>
</p>

<p>
TCP offers full-duplex service, in which data can flow in both directions at same time. Each TCP will have sending and recieving buffers in this case and segments move in both directions
</p>

<p>
<span class="underline"><b>Connection-orientied service</b></span>
</p>

<p>
Before communication starts
</p>
<ol class="org-ol">
<li>two TCPs establish a connection between them</li>
<li>Data is exchanged in both directions</li>
<li>Connection is terminated</li>
</ol>

<p>
TCP creates a stream-oriented environment where it has reponsibility to deliver bytes in order, even when segments arrive out of order (or don't arrive at all).
</p>

<p>
<span class="underline"><b>Reliable service</b></span>
</p>

<p>
TCP is reliable service. It uses acknowledgement mechanism to check the safe and sound arrival of data.
</p>
</div>
</div>

<div id="outline-container-orgf572ecb" class="outline-4">
<h4 id="orgf572ecb"><span class="section-number-4">8.3.3.</span> Features</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
To fullfil it's promises, TCP requires certain features
</p>
</div>

<div id="outline-container-org750aec3" class="outline-5">
<h5 id="org750aec3"><span class="section-number-5">8.3.3.1.</span> Numbering System</h5>
<div class="outline-text-5" id="text-8-3-3-1">
<p>
There are two fields in segment header of TCP. A sequence number and acknowledgement number. These two fields refer to the byte number and not segment number
</p>

<p>
<span class="underline"><b>Byte Number</b></span>
</p>

<p>
TCP numbers the bytes rather than segments. Numbering is independent in each direction. The numbering does not start at 0. Instead it generates a random number between 0 and \(2^{32} - 1\) for the number of first byte
</p>

<p>
Example, if random number chosen is 1057 and total bytes to be sent are 6000 bytes, they are numbered from 1058 to 7057. (the number 1057 is used by special segment for establishing connection)
</p>

<p>
This is used for flow and error control.
</p>

<p>
<span class="underline"><b>Sequence Number</b></span>
</p>

<p>
After bytes have been numbered, TCP assigns sequence number to each segment that is sent. The sequence no. for each segment is the no. of the first byte carried in that segment
</p>

<p>
Example, if file is 5000 bytes. The first byte is numbered 10001. If each segment carries 1000 bytes, then we will send file in five segments
</p>
<ul class="org-ul">
<li>Segment 1 : Sequence Number 10,001 (byte range : 10,001 to 11,000)</li>
<li>Segment 2 : Sequence Number 11,001 (byte range : 11,001 to 12,000)</li>
<li>Segment 3 : Sequence Number 12,001 (byte range : 12,001 to 13,000)</li>
<li>Segment 4 : Sequence Number 13,001 (byte range : 13,001 to 14,000)</li>
<li>Segment 5 : Sequence Number 14,001 (byte range : 14,001 to 15,000)</li>
</ul>

<blockquote>
<p>
The value in sequence number field of segment is the number of the first data byte in that segment.
</p>
</blockquote>

<ul class="org-ul">
<li>If a segment carries combination of data and control info (piggy-backing) it uses sequence number</li>
<li>If segment does not carry data, it does not define a sequence number.
<ul class="org-ul">
<li>The exception to this rule is segments used for connection establishment, termination and abortion.</li>
<li>Each of these consume a segment number as if they were carrying 1 byte of data; so we call it a phony byte</li>
<li>Example, if randomly generated number is \(x\), then first byte is numbered \(x + 1\) and the \(x\) is considered a phony byte used to open connection</li>
</ul></li>
</ul>

<p>
<span class="underline"><b>Acknowledgment Number</b></span>
</p>

<p>
In TCP connection is full duplex; after connection is established, both can send and recieve data at same time.
</p>

<p>
Both parties will choose a different random number to start. So when a package is received we need to acknowledge it, either by piggy-backing or standalone acknowledgement
</p>

<p>
The acknowledgement is the <i>next byte number that the reciever expects</i>. So it will take the number of last byte that was recieved and adds 1 to it and sends that as acknowledgement.
</p>

<p>
The acknowledgement number is cumulative. So if one party recieves 5643 as acknowledgement, we can say all bytes numbered till 5642 have been delivered 
</p>
</div>
</div>

<div id="outline-container-orgfdf86d2" class="outline-5">
<h5 id="orgfdf86d2"><span class="section-number-5">8.3.3.2.</span> Flow Control</h5>
<div class="outline-text-5" id="text-8-3-3-2">
<p>
In TCP, the receiver of data controls the amount of data that is to be sent by the sender. This is to prevent receiver from being overwhelmed. The <i>numbering system allows byte-oriented flow control</i>
</p>
</div>
</div>

<div id="outline-container-org5528c70" class="outline-5">
<h5 id="org5528c70"><span class="section-number-5">8.3.3.3.</span> Error Control</h5>
<div class="outline-text-5" id="text-8-3-3-3">
<p>
Error control in TCP is both segment oriented when using acknowledgements; as well as byte-oriented as we will see later
</p>
</div>
</div>

<div id="outline-container-org2c8161b" class="outline-5">
<h5 id="org2c8161b"><span class="section-number-5">8.3.3.4.</span> Congestion Control</h5>
<div class="outline-text-5" id="text-8-3-3-4">
<p>
The amount of data sent will not only be controlled by receiver, TCP will also check the level of congestion in the network
</p>
</div>
</div>
</div>

<div id="outline-container-orga6f1558" class="outline-4">
<h4 id="orga6f1558"><span class="section-number-4">8.3.4.</span> Segment</h4>
<div class="outline-text-4" id="text-8-3-4">

<div id="orgc7ca504" class="figure">
<p><img src="Transport_Layer/2024-10-18_15-17-07_Screenshot 2024-10-18 151701.png" alt="2024-10-18_15-17-07_Screenshot 2024-10-18 151701.png" />
</p>
</div>

<p>
The header is 20 to 60 bytes in size.
</p>
<ul class="org-ul">
<li>size is 20 bytes with no options</li>
<li>size is upto 60 bytes with options</li>
</ul>

<p>
<span class="underline"><b>Source port address</b></span>
</p>

<p>
16-bit field that defines port of program sending the segment
</p>

<p>
<span class="underline"><b>Destination port address</b></span>
</p>

<p>
16-bit field that defines port of program receiving the segment
</p>

<p>
<span class="underline"><b>Sequence number</b></span>
</p>

<p>
32-bit field that holds sequence number of segment. When connetion is established, both sides will pick a random Initial Sequence Number (ISN), which usually is different for both
</p>

<p>
<span class="underline"><b>Acknowledgement number</b></span>
</p>

<p>
32-bit field used for acknowledgement. So if lastbyte number received is \(x\); the acknowledgement number sent back is \(x + 1\). Acknowledgement and data can be piggy-backed
</p>

<p>
<span class="underline"><b>Header length</b></span>
</p>

<p>
4-bit field indicates number of 4-byte words in TCP, i.e. if <i>size of header is \(x\) then value of this field is \((x \div 4)\)</i>. Therefore, it's value is between 5 (\(5 \times 4 = 20\)) and 15 (\(15 \times 4 = 60\))
</p>

<p>
<span class="underline"><b>Reserved</b></span>
</p>

<p>
6-bit field reserved for future use
</p>

<p>
<span class="underline"><b>Control</b></span>
</p>

<p>
6-bits, each of which is a flag. One or more of these can be set at a time
</p>

<p>
These bits are used for flow control; connection establishment, termination and abortion; and mode of data transfer
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Flag</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">URG</td>
<td class="org-left">Value of urgent pointer is valid</td>
</tr>

<tr>
<td class="org-left">ACK</td>
<td class="org-left">Value of acknowledgement is valid</td>
</tr>

<tr>
<td class="org-left">PSH</td>
<td class="org-left">Push data</td>
</tr>

<tr>
<td class="org-left">RST</td>
<td class="org-left">Reset connection</td>
</tr>

<tr>
<td class="org-left">SYN</td>
<td class="org-left">Synchronize sequence numbers</td>
</tr>

<tr>
<td class="org-left">FIN</td>
<td class="org-left">Terminate connection</td>
</tr>
</tbody>
</table>

<p>
<span class="underline"><b>Window Size</b></span>
</p>

<p>
16-bit field which tells size of window in bytes that other side must maintain.
</p>
<ul class="org-ul">
<li>This value is normally referred to as the receiving window (rwnd) and it determined by the receiver</li>
<li>The sender must obey dication of receiver in this case.</li>
<li>Since field is 16-bit the maximum size of window is 65,535 bytes.</li>
</ul>

<p>
<span class="underline"><b>Checksum</b></span>
</p>

<p>
16-bit field that contains the checksum.
</p>
<ul class="org-ul">
<li>Calculation is same as in UDP</li>
<li>The same pseudoheader, serving same purpose
<ul class="org-ul">
<li>value of protcol field is 6</li>
</ul></li>
</ul>

<p>
<span class="underline"><b>Urgent Pointer</b></span>
</p>

<p>
16-bit field which is valid if urgent flag is set, used when segment contains urgent data. This field added with sequence number gives number of urgent byte in data section.
</p>

<p>
<span class="underline"><b>Options</b></span>
</p>

<p>
There can be upto 40-bytes of optional information in TCP header. (Will not be discussed here)
</p>
</div>
</div>

<div id="outline-container-org703e9c6" class="outline-4">
<h4 id="org703e9c6"><span class="section-number-4">8.3.5.</span> TCP Connection</h4>
<div class="outline-text-4" id="text-8-3-5">
<p>
A TCP connection sets up a single virtual pathway which used used for both transmission, acknowledgement and retransmission
</p>
</div>

<div id="outline-container-org40174e2" class="outline-5">
<h5 id="org40174e2"><span class="section-number-5">8.3.5.1.</span> Connection Establishment</h5>
<div class="outline-text-5" id="text-8-3-5-1">
<p>
TCP is full-duplex. Two machines connected can send each other segments. Each party must initialize communication and get approval from other before any data transfer
</p>

<p>
<span class="underline"><b>Three-Way Handshaking</b></span>
</p>

<ul class="org-ul">
<li>The process starts with the server. Server program tells TCP that it is ready to accept connection. This is called <i>passive open</i></li>
<li>The client will issue request for <i>active open</i>. This starts the three-way handshake</li>
</ul>


<div id="org0439c16" class="figure">
<p><img src="Transport_Layer/2024-10-19_01-59-10_Screenshot 2024-10-19 015904.png" alt="2024-10-19_01-59-10_Screenshot 2024-10-19 015904.png" />
</p>
</div>

<ol class="org-ol">
<li>The client sends first segment, a SYN segment, in which only SYN flag is set. This segment synchronizes sequence numbers.
<ul class="org-ul">
<li>This will send the Initial Sequence Number (ISN)</li>
<li>This segment has 1 imaginary byte (phony byte)</li>
</ul></li>
<li>Server sends second segment, a SYN + ACK segment, with these 2 flags set.
<ul class="org-ul">
<li>The SYN is for synchronizing and ACK is for the previous segment sent by user</li>
</ul></li>
<li>Client sends third segment with just ACK
<ul class="org-ul">
<li>This acknowledges the SYN + ACK sent by server</li>
<li>It's sequence number is still the ISN of client. This is because ACK does not consume sequence number by itself</li>
</ul></li>
</ol>

<blockquote>
<p>
An ACK segment, if carrying no data, will not consume sequence number
</p>
</blockquote>

<p>
<span class="underline"><b>Simultaneous Open</b></span>
</p>

<p>
If both sides issue an active open; then both TCPs transmit a SYN + ACK segments to each other. TCP can handle this and one single connection is established between them.
</p>

<p>
<span class="underline"><b>SYN Flooding Attack</b></span>
</p>

<p>
A malicious attacker can send large number of SYN segments to a server, acting as independent clients by faking IP address.
</p>

<p>
The server is fooled and allocates large no. of resources for all the connections. When server tries to send SYN + ACK to fake clients, these segments are lost. But data is already allocated for connections; thus the server may crash.
</p>

<p>
This type of attack is denial-of-service attack. Some strategies to combat this are: filter datagrams from certain IPs, impose limit on connection requests; the most recent one is to postpone allocation till whole connection is established using cooking (used in SCTP)
</p>
</div>
</div>

<div id="outline-container-orgfd962dc" class="outline-5">
<h5 id="orgfd962dc"><span class="section-number-5">8.3.5.2.</span> Data transfer</h5>
<div class="outline-text-5" id="text-8-3-5-2">
<p>
An example of data transfer is as follows
</p>


<div id="org66736f5" class="figure">
<p><img src="Transport_Layer/2024-10-28_18-04-12_Screenshot 2024-10-28 180406.png" alt="2024-10-28_18-04-12_Screenshot 2024-10-28 180406.png" />
</p>
</div>

<ul class="org-ul">
<li>client wants to send 4000 bytes
<ul class="org-ul">
<li>it sends it in 2 segments (each 2000 bytes)</li>
</ul></li>
<li>then server sends 2000 bytes of data
<ul class="org-ul">
<li>server will piggyback acknowledgement with this data segment</li>
</ul></li>
<li>finally, client acknowledges the received data
<ul class="org-ul">
<li>since client doesn't have more data to send, it will send a ACK only segment</li>
</ul></li>
</ul>

<p>
Also notice that client has set the <b>PSH (push)</b> flag for first two segments
</p>

<p>
<span class="underline"><b>Pushing data</b></span>
</p>

<p>
The receiving TCP has a buffer where data is stored until the application demands it or buffer is full.
</p>

<p>
However, on occassion we need more interactivity (for example a game where client is sending keystrokes). In this situation, this buffering can cause delay.
</p>

<p>
To handle this, sender can request <i>push</i> operation. This is done by setting the <i>PSH flag</i>
</p>
<ul class="org-ul">
<li>This segment is not placed in the senders buffer, instead it is sent immediately.</li>
<li>The receiver will also give it to application as soon as possible without waiting for more to come</li>
<li>This feature is not required to be implemented. So some programs may ignore such requests.</li>
</ul>

<p>
<span class="underline"><b>Urgent data</b></span>
</p>

<p>
TCP is stream oriented. Application will only receive a stream of bytes and not know about the individual bytes.
</p>

<p>
On occasion, application program may need to send <i>urgent bytes</i>. This is piece of data not part of stream. 
</p>

<p>
This data is sent by setting the <i>URG flag</i>. The application tells TCP that these bytes of data is urgent.
</p>

<p>
The TCP then takes these bytes and puts them at the start of the segment to be sent next. The rest of the segment still contains the normal stream data.
</p>

<p>
The urgent pointer field in header defines end of urgent data and start of normal data.
</p>

<p>
If receiver gets a segment with URG flag set, it extracts urgent data from segment, using value of urgent pointer and delivers it to application before continuing the stream data.
</p>
</div>
</div>

<div id="outline-container-org4bbdcd1" class="outline-5">
<h5 id="org4bbdcd1"><span class="section-number-5">8.3.5.3.</span> Connection termination</h5>
<div class="outline-text-5" id="text-8-3-5-3">
<p>
Any of the two parties in TCP can terminate connection. But, it is usually done by the client. There are two options for termination
</p>
<ul class="org-ul">
<li>Three-way handshaking</li>
<li>Four-way handshaking with half-close option</li>
</ul>

<p>
<span class="underline"><b>Three-way Handshaking</b></span>
</p>

<ul class="org-ul">
<li>After getting close command for program, the client TCP sends the first segment, a <i>FIN</i> segment.
<ul class="org-ul">
<li>The <i>FIN</i> segment may also carry the last chunk of data sent by client, or may just be control segment</li>
<li>if not carrying data, FIN segment still consumes a sequence number (phony byte)</li>
</ul></li>
<li>The server TCP after getting FIN will inform the process and send the second segment, a <i>FIN + ACK</i> segment.
<ul class="org-ul">
<li>This can also contain last chunk of data from server.</li>
<li>if not carrying data, it also consumes sequence number (phony byte)</li>
</ul></li>
<li>The client sends last segment, it is the <i>ACK</i> to confirm the server's FIN
<ul class="org-ul">
<li>This cannot carry more data and thus consumes no sequence numbers.</li>
</ul></li>
</ul>


<div id="orgc1b096b" class="figure">
<p><img src="Transport_Layer/2024-10-28_18-56-17_Screenshot 2024-10-28 185611.png" alt="2024-10-28_18-56-17_Screenshot 2024-10-28 185611.png" />
</p>
</div>

<p>
<span class="underline"><b>Half close (Four way handshake)</b></span>
</p>

<p>
One end way want to stop sending data while still receiving. This is called a half-close.
</p>

<p>
Both sides can issue a half-close, but is usually done by client.
</p>



<div id="org18ce1df" class="figure">
<p><img src="Transport_Layer/2024-10-28_19-09-45_Screenshot 2024-10-28 190939.png" alt="2024-10-28_19-09-45_Screenshot 2024-10-28 190939.png" />
</p>
</div>

<p>
In this example,
</p>
<ul class="org-ul">
<li>client half-closes the connection after sending FIN.</li>
<li>server accepts half-close and sends ACK</li>
<li>after server has sent all remaining data to client it sends the FIN</li>
<li>finally, client will send ACK</li>
</ul>

<p>
Here, we can see that we had 4-segments to close connection on both sides. Thus it is called a 4-way handshake.
</p>
</div>
</div>
</div>

<div id="outline-container-org2d6636d" class="outline-4">
<h4 id="org2d6636d"><span class="section-number-4">8.3.6.</span> Flow Control</h4>
<div class="outline-text-4" id="text-8-3-6">
<p>
TCP uses sliding window for flow control. The protocol is something between Go-Back-N and Selective Repeat.
</p>

<ul class="org-ul">
<li>Similar to Go-Back-N, we don't use Negetive Acknowledgement (NAKs)</li>
<li>Similar to selective repeat, the receiver holds out-of-order segmets till missing ones arrive.</li>
</ul>

<p>
There are two main differences between sliding window in data link layer and TCP.
</p>
<ul class="org-ul">
<li>TCP sliding window is byte-oriented; the data link layer is frame-oriented.</li>
<li>The size of window is variable in TCP. The window in data link layer is fixed size</li>
</ul>

<p>
The window spans portion of the buffer used to send and receive bytes. This window has two walls left and right.
</p>

<p>
The window can be opened, closed or shrunk. All these are controlled by the receiver (and depend on congestion). The sender must obey commands of receiver
</p>


<div id="org6cec932" class="figure">
<p><img src="Transport_Layer/2024-10-28_20-11-58_Screenshot 2024-10-28 201150.png" alt="2024-10-28_20-11-58_Screenshot 2024-10-28 201150.png" />
</p>
</div>

<p>
When TCP is making a segment, it will take bytes only from the window.
</p>
<ul class="org-ul">
<li>Opening window means moving right wall, this allows new bytes to be eligible for sending</li>
<li>Closing window means moving left wall, this is done when acknowledgement for some bytes is recieved</li>
<li>Shrinking means moving right wall to left. This is strongly discouraged because sender may have already sent those bytes. Some implementations don't allow this operation</li>
</ul>

<p>
The size of window is determined by lesser of two values:
<i>receiver window (rwnd)</i> and <i>congention window (cwnd)</i>
</p>

<blockquote>
<p>
window size = min(rwnd, cwnd)
</p>
</blockquote>

<ul class="org-ul">
<li>The <i>receiver window</i> is advertised by opposite end by a segment containing acknowledgement.</li>
<li>The <i>congestion window</i> is value determined by the network to avoid congestion</li>
</ul>

<p>
Example, suppose that host A is sender and host B is receiver.
</p>
<ul class="org-ul">
<li>host B has total buffer size of 5000 bytes</li>
<li>host B also has 1000 bytes of received and unprocessed data in buffer</li>
<li>therefore, host B will have window size of (5000 - 1000) bytes, i.e, 4000 bytes</li>
<li>host B will send rwnd value of 4000 when sending next segment to host A</li>
</ul>
</div>
</div>

<div id="outline-container-org1d4e8ef" class="outline-4">
<h4 id="org1d4e8ef"><span class="section-number-4">8.3.7.</span> Error Control</h4>
<div class="outline-text-4" id="text-8-3-7">
<p>
TCP has error control for corrupted segmets, lost segments, out-of-order segments and duplicated segments
</p>

<p>
There are three tools to achieve this: checksum, acknowledgement and time-out
</p>
</div>

<div id="outline-container-org9320b90" class="outline-5">
<h5 id="org9320b90"><span class="section-number-5">8.3.7.1.</span> Checksum</h5>
<div class="outline-text-5" id="text-8-3-7-1">
<p>
The checksum is used to detect corrupted segments. If segment is corrupted it is discarded.
</p>

<p>
It is a 16-bit checksum like UDP and is calculated similarly to UDP by using a pseudoheader. Unlike, UDP this is mandatory.
</p>

<p>
(It is considered inadequate for corrupted segment detection now, but can't we change it. One of the reason SCTP was made was to fix this)
</p>
</div>
</div>

<div id="outline-container-orgda8496c" class="outline-5">
<h5 id="orgda8496c"><span class="section-number-5">8.3.7.2.</span> Acknowledgement</h5>
<div class="outline-text-5" id="text-8-3-7-2">
<p>
TCP uses acknowledgements to confirm receipt of segments. ACK segments that carry no data do not consume sequence numbers.
</p>

<p>
Other control segments even if not containing data consume a sequence number, we say they consume a phony byte
</p>
</div>
</div>

<div id="outline-container-orgf5f4397" class="outline-5">
<h5 id="orgf5f4397"><span class="section-number-5">8.3.7.3.</span> Out-of-order segments</h5>
<div class="outline-text-5" id="text-8-3-7-3">
<p>
Initially, TCP was designed to discard all out-of-order segments, so retransmission had to be done again.
</p>

<p>
However, today we don't discard out-of-order segments. They are stoed temporarily and flagged as out-of-order until missing ones arrive.
</p>

<p>
These out-of-order segments will not be delivered to application, since TCP guarentees delivery to process in order.
</p>
</div>
</div>

<div id="outline-container-org900d60c" class="outline-5">
<h5 id="org900d60c"><span class="section-number-5">8.3.7.4.</span> Retransmission</h5>
<div class="outline-text-5" id="text-8-3-7-4">
<p>
A segment is retransmitted on two occassions: when retransmission timer expires or sender receives three duplicate ACKs.
</p>

<p>
There is no retransmission for segments that don't consume sequenc numbers (like ACK only segments)
</p>

<p>
<span class="underline"><b>Retransmission after RTO</b></span>
</p>

<p>
Recent implementations of TCP maintain <i>retransmission-time-out (RTO)</i> for all outstanding (sent, not acknowledged) segments.
</p>

<p>
When timer matures, the segment is retransmitted. This may happen due to delayed segment, delayed ACK or lost ACK.
</p>

<p>
The value of <i>RTO is dynamic based on RTT</i> (round-trip time). The round-trip time is time needed for segment to reach destination and an ACK to be received.
</p>

<p>
Retransmission uses the back-off strategy similar to CSMA/CD
</p>


<div id="orgb11b30f" class="figure">
<p><img src="Transport_Layer/2024-10-28_23-43-00_Screenshot 2024-10-28 234253.png" alt="2024-10-28_23-43-00_Screenshot 2024-10-28 234253.png" />
</p>
</div>

<p>
<span class="underline"><b>Retransmission after Three duplicate ACKs</b></span>
</p>

<p>
Sometimes, one segment can get lost and the receiver gets so many out-of-order segments that they cannot be saved (full buffer).
</p>

<p>
To alliviate this, we have three-duplicate ACKs rule and retransmit misssing segment immediately. This is called <i>fast retransmission</i>
</p>


<div id="orgd656d03" class="figure">
<p><img src="Transport_Layer/2024-10-28_23-37-06_Screenshot 2024-10-28 233700.png" alt="2024-10-28_23-37-06_Screenshot 2024-10-28 233700.png" />
</p>
</div>

<p>
When receiver gets segment with seq number 401, 501 and 601 it triggers acknowledgements. The sender receives four acknowledgements with same number (three duplicates).
</p>

<p>
Even if timer has not matured for segment 301, fast tranmission causes it to be retransmitted immediately.
</p>

<p>
Note: only 301 is retransmitted although four segments are not acknowledged. When sender then gets ACK, it uses cumulative acknowledgement.
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Anmol Nawani</p>
<p class="date">Created: 2024-11-04 Mon 04:06</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
